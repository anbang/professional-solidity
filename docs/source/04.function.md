# 04.å‡½æ•°

å‡½æ•°æ˜¯ä¸€ç»„å¯é‡ç”¨ä»£ç çš„åŒ…è£…ï¼Œå¯æ¥å—å‚æ•°ä½œä¸ºè¾“å…¥ï¼Œå¯è¿”å›è¾“å‡ºã€‚å‡½æ•°ä¹Ÿè¢«ç§°ä¸ºä»£ç çš„å¯æ‰§è¡Œå•å…ƒã€‚

## 1ï¸âƒ£ å‡½æ•°çš„å®šä¹‰

å‡½æ•°ç”±å…³é”®å­— `function` å£°æ˜ï¼Œåé¢è·Ÿ**å‡½æ•°å**ã€**å‚æ•°**ã€**å¯è§†èŒƒå›´**ã€**çŠ¶æ€å¯å˜æ€§**ã€**è¿”å›å€¼**çš„å®šä¹‰ã€‚å‡½æ•°å¯ä»¥å®šä¹‰åœ¨åˆçº¦å†…éƒ¨ï¼Œä¹Ÿå¯ä»¥å®šä¹‰åœ¨åˆçº¦å¤–éƒ¨ã€‚

```
function fnName(<parameter list>)
    <visibility>
    <state mutability>
    [returns(<return type>)] {
    //è¯­å¥
}

function fnName(<parameter types>)
    {internal|external}
    [pure|view|payable]
    [returns (<return types>)]{
        //...
}
```

- function: å£°æ˜å‡½æ•°çš„å›ºå®šå…³é”®å­—
- fnName : å‡½æ•°åï¼Œæ¨èå°é©¼å³°å†™æ³•,æ›´å¤šå‚è€ƒ: åˆçº¦ç¼–ç è§„èŒƒ (`TODO:`)
- `<parameter list>` : å‚æ•°åˆ—è¡¨(å‚æ•°ç±»å‹ + å‚æ•°åå­—)
- `<visibility>`: å¯è§æ€§
  - public
  - external
  - internal
  - private
- `<state mutability>`: çŠ¶æ€å¯å˜æ€§
  - pure
  - view
  - payable
  - ä¸å†™ `pure/view/payable` ä¸­ä»»ä½•ä¸€ä¸ªï¼Œä»£è¡¨ï¼Œå‡½æ•°æ—¢å¯ä»¥è¯»å–ä¹Ÿå¯ä»¥å†™å…¥çŠ¶æ€å˜é‡ã€‚
- `returns (<return types>)`:è¿”å›å€¼å’Œè¿”å›å‚æ•°ç±»å‹

### åˆçº¦å†…çš„å‡½æ•°

æ³¨æ„ï¼šå¯ä»¥åœ¨åˆçº¦å†…éƒ¨æˆ–å¤–éƒ¨å®šä¹‰å‡½æ•°ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Fun {
    function add(uint256 x, uint256 y) external pure returns (uint256) {
        return x + y;
    }

    function minus(uint256 x, uint256 y) external pure returns (uint256) {
        return x - y;
    }
}
```

### åˆçº¦å¤–çš„å‡½æ•°

åˆçº¦ä¹‹å¤–çš„å‡½æ•°ï¼ˆä¹Ÿç§°ä¸ºâ€œè‡ªç”±å‡½æ•°â€ï¼‰å§‹ç»ˆå…·æœ‰éšå¼çš„ `internal` å¯è§æ€§ã€‚ å®ƒä»¬çš„ä»£ç åŒ…å«åœ¨æ‰€æœ‰è°ƒç”¨å®ƒä»¬åˆçº¦ä¸­ï¼Œç±»ä¼¼äºå†…éƒ¨åº“å‡½æ•°ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

function sum(uint256[] memory arr) pure returns (uint256 s) {
    for (uint256 i = 0; i < arr.length; i++) {
        s += arr[i];
    }
}

contract ArrayExample {
    bool public found;

    function f(uint256[] memory arr) public {
        // åœ¨å†…éƒ¨è°ƒç”¨ free å‡½æ•°ã€‚ç¼–è¯‘å™¨ä¼šå°†å…¶ä»£ç æ·»åŠ åˆ°åˆçº¦ä¸­ã€‚
        uint256 s = sum(arr);
        found = s >= 10 ? true :false;
    }
}
```

åœ¨åˆçº¦ä¹‹å¤–å®šä¹‰çš„å‡½æ•°ä»ç„¶åœ¨åˆçº¦çš„ä¸Šä¸‹æ–‡å†…æ‰§è¡Œã€‚ä»–ä»¬ä»ç„¶å¯ä»¥è®¿é—®å˜é‡ `this` ï¼Œä¹Ÿå¯ä»¥è°ƒç”¨å…¶ä»–åˆçº¦ï¼Œå°†å…¶å‘é€ä»¥å¤ªå¸æˆ–é”€æ¯è°ƒç”¨å®ƒä»¬åˆçº¦ç­‰å…¶ä»–äº‹æƒ…ã€‚

ä¸åœ¨åˆçº¦ä¸­å®šä¹‰çš„å‡½æ•°çš„ä¸»è¦åŒºåˆ«ä¸ºï¼šè‡ªç”±å‡½æ•°ä¸èƒ½ç›´æ¥è®¿é—®å­˜å‚¨å˜é‡å’Œä¸åœ¨ä»–ä»¬çš„ä½œç”¨åŸŸèŒƒå›´å†…å‡½æ•°ã€‚

### å‡½æ•°çš„è¾“å…¥å‚æ•°

å‡½æ•°å‚æ•°çš„å£°æ˜æ–¹å¼ä¸å˜é‡ç›¸åŒã€‚ä¸è¿‡æœªä½¿ç”¨çš„å‚æ•°å¯ä»¥çœç•¥å‚æ•°åã€‚

ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬å¸Œæœ›åˆçº¦æ¥å—æœ‰ä¸¤ä¸ªæ•´æ•°å½¢å‚çš„å‡½æ•°çš„å¤–éƒ¨è°ƒç”¨ï¼Œå¯ä»¥åƒä¸‹é¢è¿™æ ·å†™ï¼š

#### æ™®é€šç”¨æ³•

å‡½æ•°å‚æ•°å¯ä»¥å½“ä½œä¸ºæœ¬åœ°å˜é‡

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Simple {
    uint256 sum;

    function add(uint256 a, uint256 b) public {
        sum = a + b;
    }
}
```

#### å‡½æ•°å‚æ•°å¯ç”¨åœ¨ç­‰å·å·¦è¾¹è¢«èµ‹å€¼ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Simple {
    function demo(uint256 _a) public pure returns (uint256) {
        _a = 22;
        return _a;
    }
}

```

#### å¯ä»¥ä½¿ç”¨æ•°ç»„ä½œä¸ºå‡½æ•°å‚æ•°ï¼š

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Simple {
    uint256[] a;

    function demo(uint256[] memory _a) public returns (uint256[] memory) {
        a = _a;
        return _a;
    }
}
```

**ä¸åŒç‰ˆæœ¬çš„å¯¹æ¯”:äºŒç»´æ•°ç»„**

æ³¨è§£:0.8.0 ä¹‹å‰å¤–éƒ¨å‡½æ•°ä¸å¯ä»¥æ¥å—å¤šç»´æ•°ç»„ä½œä¸ºå‚æ•° å¦‚æœåŸæ–‡ä»¶åŠ å…¥ `pragma abicoder v2;` å¯ä»¥å¯ç”¨ ABI v2 ç‰ˆç¼–ç åŠŸèƒ½ï¼Œè¿™æ­¤åŠŸèƒ½å¯ç”¨ã€‚ï¼ˆæ³¨ï¼šåœ¨ 0.7.0 ä¹‹å‰æ˜¯ä½¿ç”¨ `pragma experimental ABIEncoderV2;` ï¼‰

å†…éƒ¨å‡½æ•° åˆ™ä¸éœ€è¦å¯ç”¨ ABI v2 å°±æ¥å—å¤šç»´æ•°ç»„ä½œä¸ºå‚æ•°ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.12;
pragma experimental ABIEncoderV2;

contract Simple {
    uint256[][2] a = [[1, 2], [3, 4]];

    function demo() public view returns (uint256[][2] memory) {
        return a;
    }
}
```

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Simple {
    uint256[][2] a = [[1, 2], [3, 4]];

    function demo() public view returns (uint256[][2] memory) {
        return a;
    }
}
```

**ä¸åŒç‰ˆæœ¬çš„å¯¹æ¯”:è‡ªå®šä¹‰ç»“æ„**

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.12;
pragma experimental ABIEncoderV2;

contract Simple {
    struct BillType {
        uint256 duration;
        uint256 multiplier;
    }
    BillType[] public allBillTypes;

    // constructor() public {
    //     allBillTypes.push(BillType({duration: 1, multiplier: 1}));
    // }

    function getAllBillType() public view returns (BillType[] memory) {
        return allBillTypes;
    }
}
```

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Simple {
    struct BillType {
        uint256 duration;
        uint256 multiplier;
    }
    BillType[] public allBillTypes;

    constructor() {
        allBillTypes.push(BillType({duration: 1, multiplier: 1}));
    }

    function getAllBillType() public view returns (BillType[] memory) {
        return allBillTypes;
    }
}
```

åœ¨ 0.8.X ç‰ˆæœ¬å·²ç»æ²¡æœ‰é—®é¢˜äº†ã€‚

## 2ï¸âƒ£ å‡½æ•°çš„è°ƒç”¨

è¦è°ƒç”¨å‡½æ•°ï¼Œåªéœ€ä½¿ç”¨å‡½æ•°åï¼Œå¹¶ä¼ å…¥å‚æ•°å³å¯ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    mapping(address => uint256) public balances;

    event WithdrawAll(uint256 amount);

    //  å­˜æ¬¾
    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    // å–æ¬¾
    function withdrawAll() public {
        uint256 amountBalance = amountAvailable();
        balances[msg.sender] = 0;
        (bool success, ) = msg.sender.call{value: amountBalance}("");
        require(success, "Failed to send");
        emit WithdrawAll(amountBalance);
    }

    // æ‰£é™¤ 1000 wei ä½œä¸ºåˆçº¦çš„ä½¿ç”¨æ‰‹ç»­è´¹
    function amountAvailable() public view returns (uint256) {
        require(balances[msg.sender] > 1000, "must > 1000");
        return balances[msg.sender] - 1000;
    }
}
```

ä¸Šé¢åˆçº¦ç§çš„ `amountAvailable` æ—¢å¯ä»¥åœ¨åˆçº¦å¤–ï¼Œç”¨æˆ·ç›´æ¥è°ƒç”¨ï¼Œä¹Ÿå¯ä»¥åœ¨åˆçº¦å†…éƒ¨ `withdrawAll` ä¸­ä½¿ç”¨ã€‚

## 3ï¸âƒ£ æ„é€ å‡½æ•°

æ„é€ å‡½æ•°å…³é”®å­— `constructor`ï¼ŒSolidity æ„é€ å‡½æ•°æ˜¯ä¸€ä¸ªç‰¹æ®Šå‡½æ•°ï¼Œå®ƒä»…èƒ½åœ¨æ™ºèƒ½åˆçº¦éƒ¨ç½²çš„æ—¶å€™è°ƒç”¨ä¸€æ¬¡ï¼Œåˆ›å»ºä¹‹åå°±ä¸èƒ½å†æ¬¡è¢«è°ƒç”¨ã€‚

æ„é€ å‡½æ•°æ˜¯å¯é€‰çš„ï¼Œåªå…è®¸æœ‰ä¸€ä¸ªæ„é€ å‡½æ•°ï¼Œè¿™æ„å‘³ç€ä¸æ”¯æŒé‡è½½ã€‚

**ç”¨å¤„**: **Solidity æ„é€ å‡½æ•°å¸¸ç”¨æ¥è¿›è¡ŒçŠ¶æ€å˜é‡çš„åˆå§‹åŒ–å·¥ä½œã€‚**

- æ¯”å¦‚è®¾ç½®åˆçº¦çš„ owner æƒé™
- è®¾ç½®çŠ¶æ€å˜é‡çš„åˆå§‹å€¼

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract ErrorModifier{
     address public owner;
    uint public count = 0;

     constructor(uint _x){
         owner = msg.sender;
         count = _x;
     }
}
```

**éœ€è¦æ³¨æ„çš„æ˜¯**ï¼šåœ¨åˆçº¦åˆ›å»ºçš„è¿‡ç¨‹ä¸­ï¼Œå®ƒçš„ä»£ç è¿˜æ˜¯ç©ºçš„ï¼Œæ‰€ä»¥ç›´åˆ°æ„é€ å‡½æ•°æ‰§è¡Œç»“æŸï¼Œæˆ‘ä»¬éƒ½ä¸åº”è¯¥åœ¨å…¶ä¸­è°ƒç”¨åˆçº¦è‡ªå·±çš„å‡½æ•°ã€‚(æˆ‘ä»¬å¯ä»¥è°ƒç”¨ï¼Œä½†æ˜¯ä¸æ¨èè°ƒç”¨)

**è¯·æ³¨æ„**ï¼šä¸å¯ä»¥åœ¨æ„é€ å‡½æ•°ä¸­é€šè¿‡ this æ¥è°ƒç”¨å‡½æ•°ï¼Œå› ä¸ºæ­¤æ—¶çœŸå®çš„åˆçº¦å®ä¾‹è¿˜æ²¡æœ‰è¢«åˆ›å»ºã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

contract ErrorModifier {
    address public owner;
    uint256 public count = 0;

    constructor(uint256 _x) {
        owner = msg.sender;
        count = _x;
        test();
    }

    function test() public returns (uint256) {
        count = 1;
        return count;
    }
}
```

## 4ï¸âƒ£ visibility:å¯è§æ€§

å¯è§æ€§æ ‡è¯†ç¬¦çš„å®šä¹‰ä½ç½®ï¼Œå¯¹äºçŠ¶æ€å˜é‡æ¥è¯´æ˜¯åœ¨ç±»å‹åé¢ï¼Œå¯¹äºå‡½æ•°æ˜¯åœ¨å‚æ•°åˆ—è¡¨å’Œè¿”å›å…³é”®å­—ä¸­é—´ã€‚

å‡½æ•°å¯¹ä¸åŒçš„åˆçº¦æœ‰ä¸åŒçš„å¯è§æ€§ã€‚visibility åˆç§°ä¸º:**å¯è§†èŒƒå›´**/**å¯è§æ€§**/**ä½œç”¨åŸŸ**,å‡½æ•°çš„å¯è§†èŒƒå›´æœ‰å››ç§ï¼š

- Privateï¼ˆç§æœ‰ï¼‰ï¼šå‡½æ•°åªèƒ½åœ¨æ‰€å®šä¹‰çš„æ™ºèƒ½åˆçº¦å†…éƒ¨è°ƒç”¨ã€‚
  - åœ¨ç»§æ‰¿çš„åˆçº¦å†…ä¸å¯è®¿é—®ã€‚
- Internalï¼ˆå†…éƒ¨ï¼‰ï¼šå¯ä»¥åœ¨æ‰€å®šä¹‰æ™ºèƒ½åˆçº¦å†…éƒ¨è°ƒç”¨è¯¥å‡½æ•°ï¼Œä¹Ÿå¯ä»¥ä»ç»§æ‰¿åˆçº¦ä¸­è°ƒç”¨è¯¥å‡½æ•°ã€‚
  - internal å‡½æ•°å’ŒçŠ¶æ€å˜é‡å¯ä»¥åœ¨å½“å‰åˆçº¦æˆ–ç»§æ‰¿åˆçº¦é‡Œè°ƒç”¨ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ä¸èƒ½åŠ å‰ç¼€ thisï¼Œå‰ç¼€ this æ˜¯è¡¨ç¤ºé€šè¿‡å¤–éƒ¨æ–¹å¼è®¿é—®ã€‚
- Externalï¼ˆå¤–éƒ¨ï¼‰ï¼šåªèƒ½ä»æ™ºèƒ½åˆçº¦å¤–éƒ¨è°ƒç”¨ã€‚ å¦‚æœè¦ä»æ™ºèƒ½åˆçº¦ä¸­è°ƒç”¨å®ƒï¼Œåˆ™å¿…é¡»ä½¿ç”¨ `this`ã€‚
  - å¤–éƒ¨å‡½æ•°æ˜¯åˆçº¦æ¥å£çš„ä¸€éƒ¨åˆ†ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä»å…¶å®ƒåˆçº¦æˆ–é€šè¿‡äº¤æ˜“æ¥å‘èµ·è°ƒç”¨ã€‚ä¸€ä¸ªå¤–éƒ¨å‡½æ•° fï¼Œä¸èƒ½é€šè¿‡å†…éƒ¨çš„æ–¹å¼æ¥å‘èµ·è°ƒç”¨ï¼Œå¦‚ f()ä¸å¯ä»¥è°ƒç”¨ï¼Œä½†å¯ä»¥é€šè¿‡ this.f()ã€‚
  - å¤–éƒ¨å‡½æ•°åœ¨æ¥æ”¶å¤§çš„æ•°ç»„æ•°æ®æ—¶æ›´åŠ æœ‰æ•ˆã€‚
- Publicï¼ˆå…¬å¼€ï¼‰ï¼šå¯ä»¥ä»ä»»ä½•åœ°æ–¹è°ƒç”¨ã€‚

å†…éƒ¨å‡½æ•°åªèƒ½åœ¨å½“å‰åˆçº¦å†…è¢«è°ƒç”¨ï¼ˆæ›´å…·ä½“æ¥è¯´ï¼Œåœ¨å½“å‰ä»£ç å—å†…ï¼ŒåŒ…æ‹¬å†…éƒ¨åº“å‡½æ•°å’Œç»§æ‰¿çš„å‡½æ•°ä¸­ï¼‰ï¼Œå› ä¸ºå®ƒä»¬ä¸èƒ½åœ¨å½“å‰åˆçº¦ä¸Šä¸‹æ–‡çš„å¤–éƒ¨è¢«æ‰§è¡Œã€‚

- è°ƒç”¨ä¸€ä¸ªå†…éƒ¨å‡½æ•°æ˜¯é€šè¿‡è·³è½¬åˆ°å®ƒçš„å…¥å£æ ‡ç­¾æ¥å®ç°çš„ï¼Œå°±åƒåœ¨å½“å‰åˆçº¦çš„å†…éƒ¨è°ƒç”¨ä¸€ä¸ªå‡½æ•°ã€‚
- å¤–éƒ¨å‡½æ•°ç”±**ä¸€ä¸ªåœ°å€**å’Œ**ä¸€ä¸ªå‡½æ•°ç­¾å**ç»„æˆï¼Œå¯ä»¥é€šè¿‡å¤–éƒ¨å‡½æ•°è°ƒç”¨ä¼ é€’æˆ–è€…è¿”å›ã€‚

å‡½æ•°ç±»å‹é»˜è®¤æ˜¯å†…éƒ¨å‡½æ•°ï¼Œå› æ­¤ä¸éœ€è¦å£°æ˜ `internal` å…³é”®å­—ã€‚è¯·æ³¨æ„ï¼Œè¿™ä»…é€‚ç”¨äºå‡½æ•°ç±»å‹ï¼Œåˆçº¦ä¸­å®šä¹‰çš„å‡½æ•°æ˜ç¡®æŒ‡å®šå¯è§æ€§ï¼Œå®ƒä»¬æ²¡æœ‰é»˜è®¤å€¼ã€‚

æ›´å¤šå†…å®¹å‚è€ƒ [å˜é‡çš„ä½œç”¨åŸŸ&å¯è§†èŒƒå›´](/source/03.variable.html#id12)

### private

private å‡½æ•°å’ŒçŠ¶æ€å˜é‡ä»…åœ¨å½“å‰å®šä¹‰å®ƒä»¬çš„åˆçº¦ä¸­ä½¿ç”¨ï¼Œå¹¶ä¸”ä¸èƒ½è¢«æ´¾ç”Ÿåˆçº¦ä½¿ç”¨ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;
contract C {
    function f(uint a) private pure returns (uint b) { return a + 1; }
    function setData(uint a) internal { data = a; }
    uint public data;
}
```

åœ¨ä¸‹é¢çš„ä¾‹å­ä¸­ï¼Œ`D` å¯ä»¥è°ƒç”¨ `c.getDataï¼ˆï¼‰` æ¥è·å–çŠ¶æ€å­˜å‚¨ä¸­ `data`
çš„å€¼ï¼Œä½†ä¸èƒ½è°ƒç”¨ `f` ã€‚ åˆçº¦ `E` ç»§æ‰¿è‡ª `C` ï¼Œå› æ­¤å¯ä»¥è°ƒç”¨ `compute`ã€‚

```
pragma solidity >=0.4.16 <0.9.0;

contract C {
    uint private data;

    function f(uint a) private returns(uint b) { return a + 1; }
    function setData(uint a) public { data = a; }
    function getData() public returns(uint) { return data; }
    function compute(uint a, uint b) internal returns (uint) { return a+b; }
}

// ä¸‹é¢ä»£ç ç¼–è¯‘é”™è¯¯
contract D {
    function readData() public {
        C c = new C();
        uint local = c.f(7); // é”™è¯¯ï¼šæˆå‘˜ `f` ä¸å¯è§
        c.setData(3);
        local = c.getData();
        local = c.compute(3, 5); // é”™è¯¯ï¼šæˆå‘˜ `compute` ä¸å¯è§
    }
}

contract E is C {
    function g() public {
        C c = new C();
        uint val = compute(3, 5); // è®¿é—®å†…éƒ¨æˆå‘˜ï¼ˆä»ç»§æ‰¿åˆçº¦è®¿é—®çˆ¶åˆçº¦æˆå‘˜ï¼‰
    }
}
```

è­¦å‘Š: è®¾ç½®ä¸º `private`æˆ– `internal`ï¼Œåªèƒ½é˜²æ­¢å…¶ä»–åˆçº¦è¯»å–æˆ–ä¿®æ”¹ä¿¡æ¯ï¼Œä½†å®ƒä»ç„¶å¯ä»¥åœ¨é“¾å¤–æŸ¥çœ‹åˆ°ã€‚

### internal

ä¸€ä¸ªå†…éƒ¨å‡½æ•°å¯ä»¥è¢«åˆ†é…ç»™ä¸€ä¸ªå†…éƒ¨å‡½æ•°ç±»å‹çš„å˜é‡ï¼Œæ— è®ºå®šä¹‰åœ¨å“ªé‡Œï¼ŒåŒ…æ‹¬åˆçº¦å’Œåº“çš„ç§æœ‰ã€å†…éƒ¨å’Œ public å‡½æ•°ï¼Œä»¥åŠè‡ªç”±å‡½æ•°ã€‚

å¦ä¸€æ–¹é¢ï¼Œå¤–éƒ¨å‡½æ•°ç±»å‹åªä¸ public å’Œå¤–éƒ¨åˆçº¦å‡½æ•°å…¼å®¹ã€‚åº“æ˜¯ä¸å¯ä»¥çš„ï¼Œå› ä¸ºåº“ä½¿ç”¨ delegatecallï¼Œå¹¶ä¸” ä»–ä»¬çš„å‡½æ•°é€‰æ‹©å™¨æœ‰ä¸åŒçš„ ABI è½¬æ¢ ã€‚ æ¥å£ä¸­å£°æ˜çš„å‡½æ•°æ²¡æœ‰å®šä¹‰ï¼Œæ‰€ä»¥æŒ‡å‘å®ƒä»¬ä¹Ÿæ²¡æœ‰æ„ä¹‰ã€‚

å†…éƒ¨å¯è§æ€§å‡½æ•°è®¿é—®å¯ä»¥åœ¨å½“å‰åˆçº¦æˆ–æ´¾ç”Ÿçš„åˆçº¦è®¿é—®ï¼Œä¸å¯ä»¥å¤–éƒ¨è®¿é—®ã€‚ ç”±äºå®ƒä»¬æ²¡æœ‰é€šè¿‡åˆçº¦çš„ ABI å‘å¤–éƒ¨å…¬å¼€ï¼Œå®ƒä»¬å¯ä»¥æ¥å—å†…éƒ¨å¯è§æ€§ç±»å‹çš„å‚æ•°ï¼šæ¯”å¦‚æ˜ å°„æˆ–å­˜å‚¨å¼•ç”¨ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

library ArrayUtils {
    // å†…éƒ¨å‡½æ•°å¯ä»¥åœ¨å†…éƒ¨åº“å‡½æ•°ä¸­ä½¿ç”¨ï¼Œ
    // å› ä¸ºå®ƒä»¬ä¼šæˆä¸ºåŒä¸€ä»£ç ä¸Šä¸‹æ–‡çš„ä¸€éƒ¨åˆ†
    function map(
        uint256[] memory self,
        function(uint256) pure returns (uint256) f
    ) internal pure returns (uint256[] memory r) {
        r = new uint256[](self.length);
        for (uint256 i = 0; i < self.length; i++) {
            r[i] = f(self[i]);
        }
    }

    function reduce(
        uint256[] memory self,
        function(uint256, uint256) pure returns (uint256) f
    ) internal pure returns (uint256 r) {
        r = self[0];
        for (uint256 i = 1; i < self.length; i++) {
            r = f(r, self[i]);
        }
    }

    function range(uint256 length) internal pure returns (uint256[] memory r) {
        r = new uint256[](length);
        for (uint256 i = 0; i < r.length; i++) {
            r[i] = i;
        }
    }
}

contract Pyramid {
    using ArrayUtils for *;

    function pyramid(uint256 l) public pure returns (uint256) {
        return ArrayUtils.range(l).map(square).reduce(sum);
    }

    function square(uint256 x) internal pure returns (uint256) {
        return x * x;
    }

    function sum(uint256 x, uint256 y) internal pure returns (uint256) {
        return x + y;
    }
}
```

å½“å‰åˆçº¦ä¸­çš„å‡½æ•°å¯ä»¥ç›´æ¥ï¼ˆâ€œä»å†…éƒ¨â€ï¼‰è°ƒç”¨ï¼Œä¹Ÿå¯ä»¥é€’å½’è°ƒç”¨ï¼Œå°±åƒä¸‹è¾¹è¿™ä¸ªæ— æ„ä¹‰çš„ä¾‹å­ä¸€æ ·ã€‚ï¼ˆè¾“å‡º`"uint256: ret 0"`ï¼‰

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

// ç¼–è¯‘å™¨ä¼šæœ‰è­¦å‘Šæç¤º
contract C {
    function g(uint256 a) public pure returns (uint256 ret) {
        return f();
    }

    function f() internal pure returns (uint256 ret) {
        return g(7) + f();
    }
}
```

è¿™äº›å‡½æ•°è°ƒç”¨åœ¨ EVM ä¸­è¢«è§£é‡Šä¸ºç®€å•çš„è·³è½¬ã€‚è¿™æ ·åšçš„æ•ˆæœå°±æ˜¯å½“å‰å†…å­˜ä¸ä¼šè¢«æ¸…é™¤ï¼Œä¾‹å¦‚ï¼Œå‡½æ•°ä¹‹é—´é€šè¿‡ä¼ é€’å†…å­˜å¼•ç”¨è¿›è¡Œå†…éƒ¨è°ƒç”¨æ˜¯éå¸¸é«˜æ•ˆçš„ã€‚ åªèƒ½åœ¨åŒä¸€åˆçº¦å®ä¾‹çš„å‡½æ•°ï¼Œå¯ä»¥è¿›è¡Œå†…éƒ¨è°ƒç”¨ã€‚

åªæœ‰åœ¨åŒä¸€åˆçº¦çš„å‡½æ•°å¯ä»¥å†…éƒ¨è°ƒç”¨ã€‚ä»ç„¶åº”è¯¥é¿å…è¿‡å¤šçš„é€’å½’è°ƒç”¨, å› ä¸ºæ¯ä¸ªå†…éƒ¨å‡½æ•°è°ƒç”¨è‡³å°‘ä½¿ç”¨ä¸€ä¸ªå †æ ˆæ§½, å¹¶ä¸”æœ€å¤šæœ‰ 1024 å †æ ˆæ§½å¯ç”¨ã€‚

### external

external å¤–éƒ¨å¯è§æ€§å‡½æ•°ä½œä¸ºåˆçº¦æ¥å£çš„ä¸€éƒ¨åˆ†ï¼Œæ„å‘³ç€æˆ‘ä»¬å¯ä»¥ä»å…¶ä»–åˆçº¦å’Œäº¤æ˜“ä¸­è°ƒç”¨ã€‚ ä¸€ä¸ªå¤–éƒ¨å‡½æ•° `f` ä¸èƒ½ä»å†…éƒ¨è°ƒç”¨ï¼ˆå³ `f` ä¸èµ·ä½œç”¨ï¼Œä½† `this.f()` å¯ä»¥ï¼‰ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Oracle {
    struct Request {
        bytes data;
        function(uint256) external callback;
    }
    Request[] private requests;
    event NewRequest(uint256);

    function query(bytes memory data, function(uint256) external callback)
        public
    {
        requests.push(Request(data, callback));
        emit NewRequest(requests.length - 1);
    }

    function reply(uint256 requestID, uint256 response) public {
        // è¿™é‡Œæ£€æŸ¥å›å¤æ¥è‡ªå¯ä¿¡æ¥æº
        requests[requestID].callback(response);
    }
}

contract OracleUser {
    Oracle private constant ORACLE_CONST =
        Oracle(address(0x00000000219ab540356cBB839Cbe05303d7705Fa)); // known contract
    uint256 private exchangeRate;

    function buySomething() public {
        ORACLE_CONST.query("USD", this.oracleResponse);
    }

    function oracleResponse(uint256 response) public {
        require(
            msg.sender == address(ORACLE_CONST),
            "Only oracle can call this."
        );
        exchangeRate = response;
    }
}
```

æ–¹å¼ä¹Ÿå¯ä»¥ä½¿ç”¨è¡¨è¾¾å¼ `this.g(8)`; å’Œ `c.g(2)`; è¿›è¡Œè°ƒç”¨ï¼Œå…¶ä¸­ c æ˜¯åˆçº¦å®ä¾‹ï¼Œ g åˆçº¦å†…å®ç°çš„å‡½æ•°ï¼Œä½†æ˜¯è¿™ä¸¤ç§æ–¹å¼è°ƒç”¨å‡½æ•°ï¼Œç§°ä¸ºâ€œå¤–éƒ¨è°ƒç”¨â€ï¼Œ**å®ƒæ˜¯é€šè¿‡æ¶ˆæ¯è°ƒç”¨æ¥è¿›è¡Œï¼Œè€Œä¸æ˜¯ç›´æ¥çš„ä»£ç è·³è½¬**ã€‚è¯·æ³¨æ„ï¼Œä¸å¯ä»¥åœ¨æ„é€ å‡½æ•°ä¸­é€šè¿‡ `this` æ¥è°ƒç”¨å‡½æ•°ï¼Œå› ä¸ºæ­¤æ—¶çœŸå®çš„åˆçº¦å®ä¾‹è¿˜æ²¡æœ‰è¢«åˆ›å»ºã€‚

å¦‚æœæƒ³è¦è°ƒç”¨å…¶ä»–åˆçº¦çš„å‡½æ•°ï¼Œéœ€è¦å¤–éƒ¨è°ƒç”¨ã€‚å¯¹äºä¸€ä¸ªå¤–éƒ¨è°ƒç”¨ï¼Œæ‰€æœ‰çš„å‡½æ•°å‚æ•°éƒ½éœ€è¦è¢«å¤åˆ¶åˆ°å†…å­˜ã€‚

> ä»ä¸€ä¸ªåˆçº¦åˆ°å¦ä¸€ä¸ªåˆçº¦çš„å‡½æ•°è°ƒç”¨ä¸ä¼šåˆ›å»ºè‡ªå·±çš„äº¤æ˜“, å®ƒæ˜¯ä½œä¸ºæ•´ä¸ªäº¤æ˜“çš„ä¸€éƒ¨åˆ†çš„æ¶ˆæ¯è°ƒç”¨ã€‚

#### è°ƒç”¨å‡½æ•°å¹¶è½¬è´¦

å½“è°ƒç”¨å…¶ä»–åˆçº¦çš„å‡½æ•°æ—¶ï¼Œéœ€è¦åœ¨å‡½æ•°è°ƒç”¨æ˜¯æŒ‡å®šå‘é€çš„ Wei å’Œ gas æ•°é‡ï¼Œå¯ä»¥ä½¿ç”¨ç‰¹å®šé€‰é¡¹ã€€`{value: 10, gas: 10000}`,è¯·æ³¨æ„ï¼Œä¸å»ºè®®æ˜ç¡®æŒ‡å®š gasï¼Œå› ä¸ºæ“ä½œç çš„ gas æ¶ˆè€—å°†æ¥å¯èƒ½ä¼šå‘ç”Ÿå˜åŒ–ã€‚ ä»»ä½•å‘é€ç»™åˆçº¦ Wei å°†è¢«æ·»åŠ åˆ°ç›®æ ‡åˆçº¦çš„æ€»ä½™é¢ä¸­ï¼š

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

contract InfoFeed {
    function info() external payable returns (uint256 ret) {
        return 42;
    }
}

contract Consumer {
    InfoFeed feed;

    function setFeed(InfoFeed addr) public {
        feed = addr;
    }

    function callFeed() public payable{
        feed.info{value: 10, gas: 800}();
    }
}
```

payable ä¿®é¥°ç¬¦è¦ç”¨äºä¿®é¥° info å‡½æ•°ï¼Œå¦åˆ™ï¼Œ value é€‰é¡¹å°†ä¸å¯ç”¨ã€‚

æ³¨æ„ `feed.info{value: 10, gas: 800}` ä»…ï¼ˆå±€éƒ¨åœ°ï¼‰è®¾ç½®äº†ä¸å‡½æ•°è°ƒç”¨ä¸€èµ·å‘é€çš„ Wei å€¼å’Œ gas çš„æ•°é‡ï¼Œåªæœ‰æœ€åçš„å°æ‹¬å·æ‰æ‰§è¡Œäº†çœŸæ­£çš„è°ƒç”¨ã€‚ å› æ­¤ï¼Œ `feed.info{value: 10, gas: 800}` æ˜¯æ²¡æœ‰è°ƒç”¨å‡½æ•°çš„ï¼Œ `value` å’Œ `gas` è®¾ç½®æ˜¯æ— æ•ˆçš„ã€‚

#### extcodesize æ“ä½œç æ¥æ£€æŸ¥è¦è°ƒç”¨çš„åˆçº¦æ˜¯å¦ç¡®å®å­˜åœ¨

ç”±äº EVM è®¤ä¸ºå¯ä»¥è°ƒç”¨ä¸å­˜åœ¨çš„åˆçº¦çš„è°ƒç”¨ï¼Œå› æ­¤åœ¨ Solidity è¯­è¨€å±‚é¢é‡Œä¼šä½¿ç”¨ extcodesize æ“ä½œç æ¥æ£€æŸ¥è¦è°ƒç”¨çš„åˆçº¦æ˜¯å¦ç¡®å®å­˜åœ¨ï¼ˆåŒ…å«ä»£ç ï¼‰ï¼Œå¦‚æœä¸å­˜åœ¨è¯¥åˆçº¦ï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸ã€‚å¦‚æœè¿”å›æ•°æ®åœ¨è°ƒç”¨åè¢«è§£ç ï¼Œåˆ™è·³è¿‡è¿™ä¸ªæ£€æŸ¥ï¼Œå› æ­¤ ABI è§£ç å™¨å°†æ•æ‰åˆ°ä¸å­˜åœ¨çš„åˆçº¦çš„æƒ…å†µã€‚

è¯·æ³¨æ„ï¼Œè¿™ä¸ªæ£€æŸ¥åœ¨ **ä½çº§ call** æ—¶ä¸è¢«æ‰§è¡Œï¼Œè¿™äº›è°ƒç”¨æ˜¯å¯¹åœ°å€è€Œä¸æ˜¯åˆçº¦å®ä¾‹è¿›è¡Œæ“ä½œã€‚

å½“ä½¿ç”¨é«˜çº§åˆ«çš„æ–¹å¼è°ƒç”¨ é¢„ç¼–è¯‘åˆçº¦æ—¶ éœ€è¦æ³¨æ„ï¼Œå› ä¸ºå› ä¸ºæ ¹æ®ä¸Šé¢çš„é€»è¾‘ï¼Œç¼–è¯‘å™¨è®¤ä¸ºå®ƒä»¬ä¸å­˜åœ¨ï¼Œå³ä½¿å®ƒä»¬æ‰§è¡Œä»£ç å¹¶è¿”å›æ•°æ®ã€‚

å¦‚æœè¢«è°ƒç”¨åˆçº¦æœ¬èº«æŠ›å‡ºå¼‚å¸¸æˆ–è€… gas ç”¨å®Œç­‰ï¼Œå‡½æ•°è°ƒç”¨ä¹Ÿä¼šæŠ›å‡ºå¼‚å¸¸ã€‚

#### ä¸å…¶ä»–åˆçº¦äº¤äº’æ—¶å€™æœ‰ä»€ä¹ˆéœ€è¦æ³¨æ„çš„ï¼Ÿ

> ä»»ä½•ä¸å…¶ä»–åˆçº¦çš„äº¤äº’éƒ½ä¼šäº§ç”Ÿæ½œåœ¨å±é™©ï¼Œå°¤å…¶æ˜¯åœ¨ä¸èƒ½é¢„å…ˆçŸ¥é“åˆçº¦ä»£ç çš„æƒ…å†µä¸‹ã€‚ äº¤äº’æ—¶å½“å‰åˆçº¦ä¼šå°†æ§åˆ¶æƒç§»äº¤ç»™è¢«è°ƒç”¨åˆçº¦ï¼Œè€Œè¢«è°ƒç”¨åˆçº¦å¯èƒ½åšä»»ä½•äº‹ã€‚å³ä½¿è¢«è°ƒç”¨åˆçº¦ä»ä¸€ä¸ªå·²çŸ¥çˆ¶åˆçº¦ç»§æ‰¿ï¼Œç»§æ‰¿çš„åˆçº¦ä¹Ÿåªéœ€è¦æœ‰ä¸€ä¸ªæ­£ç¡®çš„æ¥å£å°±å¯ä»¥äº†ã€‚ è¢«è°ƒç”¨åˆçº¦çš„å®ç°å¯ä»¥å®Œå…¨ä»»æ„çš„å®ç°ï¼Œå› æ­¤ä¼šå¸¦æ¥å±é™©ã€‚ æ­¤å¤–ï¼Œè¯·å°å¿ƒè¿™ä¸ªäº¤äº’è°ƒç”¨åœ¨è¿”å›ä¹‹å‰å†å›è°ƒæˆ‘ä»¬çš„åˆçº¦ï¼Œè¿™æ„å‘³ç€è¢«è°ƒç”¨åˆçº¦å¯ä»¥é€šè¿‡å®ƒè‡ªå·±çš„å‡½æ•°æ”¹å˜è°ƒç”¨åˆçº¦çš„çŠ¶æ€å˜é‡ã€‚ ä¸€ä¸ªå»ºè®®çš„å‡½æ•°å†™æ³•æ˜¯ï¼Œä¾‹å¦‚ï¼Œåœ¨åˆçº¦ä¸­çŠ¶æ€å˜é‡è¿›è¡Œå„ç§å˜åŒ–åå†è°ƒç”¨å¤–éƒ¨å‡½æ•°ï¼Œè¿™æ ·ï¼Œä½ çš„åˆçº¦å°±ä¸ä¼šè½»æ˜“è¢«æ»¥ç”¨çš„é‡å…¥æ”»å‡» (reentrancy) æ‰€å½±å“

### public

è¯·æ³¨æ„ï¼Œå½“å‰åˆçº¦çš„ public å‡½æ•°æ—¢å¯ä»¥è¢«å½“ä½œå†…éƒ¨å‡½æ•°ä¹Ÿå¯ä»¥è¢«å½“ä½œå¤–éƒ¨å‡½æ•°ä½¿ç”¨ã€‚ å¦‚æœæƒ³å°†ä¸€ä¸ªå‡½æ•°å½“ä½œå†…éƒ¨å‡½æ•°ä½¿ç”¨ï¼Œå°±ç”¨ `f` è°ƒç”¨ï¼Œå¦‚æœæƒ³å°†å…¶å½“ä½œå¤–éƒ¨å‡½æ•°ï¼Œä½¿ç”¨ `this.f` ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Example {
  function f() public payable returns (bytes4) {
    assert(this.f.address == address(this));
    return this.f.selector;
  }
  function g() public {
    this.f{gas: 10, value: 800}();
  }
}
```

### public & external å‡½æ•°çš„å±æ€§

publicï¼ˆæˆ– externalï¼‰å‡½æ•°éƒ½æœ‰ä¸‹é¢çš„æˆå‘˜ï¼š

- `.address` è¿”å›å‡½æ•°çš„åˆçº¦åœ°å€ã€‚
- `.selector` è¿”å› ABI å‡½æ•°é€‰æ‹©å™¨

ç”±äº Solidity æœ‰ä¸¤ç§å‡½æ•°è°ƒç”¨ï¼šå¤–éƒ¨è°ƒç”¨åˆ™ä¼šäº§ç”Ÿä¸€ä¸ª EVM è°ƒç”¨ï¼Œè€Œå†…éƒ¨è°ƒç”¨ä¸ä¼šã€‚

### ä¾‹å­: `internal` å’Œ `external` æ­é…åš DAO çš„ç®¡ç†å‘˜çš„å°æ¡ˆä¾‹ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract DAO {
    // çŠ¶æ€å˜é‡
    mapping(address => bool) public admins;

    // äº‹ä»¶
    event AddAdmin(address indexed ads);

    // å‡½æ•°ä¿®æ”¹å™¨
    modifier onlyRole() {
        require(admins[msg.sender], "Not Authorized");
        _;
    }

    constructor() {
        _addAdmin(msg.sender);
    }

    function _addAdmin(address _ads) internal {
        admins[_ads] = true;
        emit AddAdmin(_ads);
    }

    function addAdmin(address _ads) external onlyRole {
        _addAdmin(_ads);
    }
}
```

ä¾‹å­å°ç»“:

- è¯¥ç‰¹æ€§å¸¸ç”¨äºæƒé™çš„åŒºåˆ†ï¼›
  - æ¯”å¦‚ `internal _fn` ç”¨äºåœ¨ `constructor` å†…ä½¿ç”¨ã€‚è€Œ `external fn` ç”¨äºå¤–éƒ¨å¸¦éªŒè¯ä½¿ç”¨ï¼Œå¹¶ä¸”åœ¨ `fn` å†…éƒ¨è°ƒç”¨ `_fn`;

### ä¾‹å­:åˆçº¦ç»§æ‰¿çš„ä¾‹å­

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract A {
    uint256 private varPrivate = 0;
    uint256 internal varInternal = 1;
    // ä¸èƒ½å£°æ˜ external å¯è§æ€§çš„çŠ¶æ€å˜é‡
    // uint256 external varExternal = 2; // Expected identifier but got 'external'
    uint256 public varPublic = 3;

    function testPrivate() private pure returns (uint256) {
        return 0;
    }

    function testInternal() internal pure returns (uint256) {
        return 1;
    }

    function testExternal() external pure returns (uint256) {
        return 2;
    }

    function testPublic() public pure returns (uint256) {
        return 3;
    }
}

contract B is A {
    function getVal() external view returns (uint256, uint256) {
        // return varPrivate; // private ä»…åœ¨Aå†…ï¼Œä¸èƒ½è¢«ç»§æ‰¿,æ— æ³•è®¿é—®
        return (varInternal, varPublic);
    }

    function getFn()
        external
        view
        returns (
            uint256,
            uint256,
            uint256
        )
    {
        // uint256 p = testPrivate(); // private ä»…åœ¨Aå†…ï¼Œä¸èƒ½è¢«ç»§æ‰¿,æ— æ³•è®¿é—®
        uint256 i = testInternal(); // å¯è®¿é—® internal å‡½æ•°

        // external åªèƒ½åœ¨å¤–éƒ¨è®¿é—®ï¼Œä¸èƒ½ç›´æ¥è®¿é—® external å‡½æ•°
        // uint256 e = testExternal();
        // è™½ç„¶ä¸èƒ½ç›´æ¥è®¿é—®ï¼Œä½†æ˜¯å¯ä»¥ä½¿ç”¨ this ä»£è¡¨åˆçº¦å¤–éƒ¨ï¼Œ
        // ç„¶åè°ƒç”¨å¤–éƒ¨å‡½æ•°ï¼›è¯¥æ–¹æ³•ä¸æ¨èã€‚
        uint256 e2 = this.testExternal();

        uint256 p2 = this.testPublic();
        return (i, e2, p2);
    }
}
```

**æ€»ç»“:**

```
/**
 -----------------------
| contract A            |
|                       |
| æœ‰æ•ˆå˜é‡ç±»å‹:           |
| varPrivate            |
| varInternal           |
| varPublic             | <------------ å¤–éƒ¨
| ä¸å­˜åœ¨externalå˜é‡      |     å˜é‡: varPublic
|                       |     æ–¹æ³•: testPublic / testExternal
| æœ‰æ•ˆå‡½æ•°ç±»å‹:           |
| testPrivate           |
| testInternal          |
| testExternal          |
| testPublic            |
 -----------------------

 -----------------------
| contract B            |
|                       |
| æœ‰æ•ˆå˜é‡ç±»å‹:           |
| varInternal           |
| varPublic             | <------------ å¤–éƒ¨
|                       |     å˜é‡: varPublic
|                       |     æ–¹æ³•: testPublic / testExternal
| æœ‰æ•ˆå‡½æ•°ç±»å‹:           |
| testInternal          |
| testPublic            |
 -----------------------
 */
```

## 5ï¸âƒ£ mutability:çŠ¶æ€å¯å˜æ€§

- `pure`: æ—¢ä¸è¯»å–ä¹Ÿä¸ä¿®æ”¹çŠ¶æ€å˜é‡
  - è¿™ç§å‡½æ•°è¢«ç§°ä¸º**çº¯å‡½æ•°**
- `view`: è¯»å–çŠ¶æ€å˜é‡ï¼Œä½†æ˜¯ä¸ä¿®æ”¹çŠ¶æ€å˜é‡
  - è¿™ç§å‡½æ•°è¢«ç§°ä¸º**è§†å›¾å‡½æ•°**
  - çŠ¶æ€å˜é‡çš„ Getter æ–¹æ³•é»˜è®¤æ˜¯ view å‡½æ•°ã€‚
- `payable`ï¼šç”¨ payable å£°æ˜çš„å‡½æ•°å¯ä»¥æ¥å—å‘é€ç»™åˆçº¦çš„ä»¥å¤ªå¸.
  - å¦‚æœæœªæŒ‡å®šï¼Œè¯¥å‡½æ•°å°†è‡ªåŠ¨æ‹’ç»æ‰€æœ‰å‘é€ç»™å®ƒçš„ä»¥å¤ªå¸

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract ViewAndPure{
    uint public num ;

    function viewFn() external view returns(uint){
        return num;
    }
    function pureFn(uint x) external pure returns(uint){
        return x + 1;
    }

}
```

### 1.pure ä¸å…è®¸çš„æ“ä½œ

å£°æ˜ä¸º pure å‡½æ•°ï¼Œå¯ä»¥åœ¨å‡½æ•°å£°æ˜é‡Œï¼Œæ·»åŠ  pure å…³é”®å­—ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

contract C {
    function f(uint256 a, uint256 b) public pure returns (uint256) {
        return a * (b + 42);
    }
}
```

å¦‚æœå‡½æ•°ä¸­å­˜åœ¨ä»¥ä¸‹è¯­å¥ï¼Œåˆ™è¢«è§†ä¸ºè¯»å–çŠ¶æ€ï¼Œç¼–è¯‘å™¨å°†æŠ›å‡ºè­¦å‘Šã€‚

- è¯»å–çŠ¶æ€å˜é‡ã€‚
  - è¿™ä¹Ÿæ„å‘³ç€è¯»å– `immutable` å˜é‡ä¹Ÿä¸æ˜¯ä¸€ä¸ª `pure` æ“ä½œã€‚
- è®¿é—® `address(this).balance` æˆ– `<address>.balance`
- è®¿é—® `block`ï¼Œ`tx`ï¼Œ `msg` ä¸­ä»»æ„æˆå‘˜ ï¼ˆé™¤ `msg.sig` å’Œ `msg.data` ä¹‹å¤–ï¼‰ã€‚
- è°ƒç”¨ä»»ä½•æœªæ ‡è®°ä¸º `pure` çš„å‡½æ•°ã€‚
- **ä½¿ç”¨åŒ…å«ç‰¹å®šæ“ä½œç çš„å†…è”æ±‡ç¼–ã€‚**
  - `TODO:` è¿™ä¸ªä¸äº†è§£ï¼Œéœ€è¦ç”¨ä¾‹å­åŠ æ·±å°è±¡ã€‚
- ä½¿ç”¨æ“ä½œç  `STATICCALL` , è¿™å¹¶ä¸ä¿è¯çŠ¶æ€æœªè¢«è¯»å–, ä½†è‡³å°‘ä¸è¢«ä¿®æ”¹ã€‚

å¦‚æœå‘ç”Ÿé”™è¯¯ï¼Œ`pure` å‡½æ•°å¯ä»¥ä½¿ç”¨ `revert()`å’Œ `require()` å‡½æ•°æ¥è¿˜åŸæ½œåœ¨çš„çŠ¶æ€æ›´æ”¹ã€‚è¿˜åŸçŠ¶æ€æ›´æ”¹ä¸è¢«è§†ä¸º **çŠ¶æ€ä¿®æ”¹**, å› ä¸ºå®ƒåªè¿˜åŸä»¥å‰åœ¨æ²¡æœ‰`view` æˆ– `pure` é™åˆ¶çš„ä»£ç ä¸­æ‰€åšçš„çŠ¶æ€æ›´æ”¹, å¹¶ä¸”ä»£ç å¯ä»¥é€‰æ‹©æ•è· revert å¹¶ä¸ä¼ é€’è¿˜åŸã€‚è¿™ç§è¡Œä¸ºä¹Ÿç¬¦åˆ STATICCALL æ“ä½œç ã€‚

**è­¦å‘Š**:ä¸å¯èƒ½åœ¨ EVM çº§åˆ«é˜»æ­¢å‡½æ•°è¯»å–çŠ¶æ€, åªèƒ½é˜»æ­¢å®ƒä»¬å†™å…¥çŠ¶æ€ (å³åªèƒ½åœ¨ EVM çº§åˆ«å¼ºåˆ¶æ‰§è¡Œ `view` , è€Œ `pure` ä¸èƒ½å¼ºåˆ¶)ã€‚

> åœ¨ 0.5.0 ç‰ˆæœ¬ä¹‹å‰, ç¼–è¯‘å™¨æ²¡æœ‰å¯¹ pure å‡½æ•°ä½¿ç”¨ STATICCALL æ“ä½œç ã€‚è¿™æ ·é€šè¿‡ä½¿ç”¨æ— æ•ˆçš„æ˜¾å¼ç±»å‹è½¬æ¢å¯ç”¨ pure å‡½æ•°ä¸­çš„çŠ¶æ€ä¿®æ”¹ã€‚ é€šè¿‡å¯¹ pure å‡½æ•°ä½¿ç”¨ STATICCALL , å¯ä»¥é˜²æ­¢åœ¨ EVM çº§åˆ«ä¸Šå¯¹çŠ¶æ€è¿›è¡Œä¿®æ”¹ã€‚

> åœ¨ 0.4.17 ç‰ˆæœ¬ä¹‹å‰ï¼Œç¼–è¯‘å™¨ä¸ä¼šå¼ºåˆ¶ pure å‡½æ•°ä¸è¯»å–çŠ¶æ€ã€‚å®ƒæ˜¯ä¸€ä¸ªç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥, å¯ä»¥é¿å…åœ¨åˆçº¦ç±»å‹ä¹‹é—´è¿›è¡Œæ— æ•ˆçš„æ˜¾å¼è½¬æ¢, å› ä¸ºç¼–è¯‘å™¨å¯ä»¥éªŒè¯åˆçº¦ç±»å‹æ²¡æœ‰çŠ¶æ€æ›´æ”¹æ“ä½œ, ä½†å®ƒä¸ä¼šåœ¨è¿è¡Œæ—¶èƒ½æ£€æŸ¥è°ƒç”¨å®é™…çš„ç±»å‹ã€‚

### 2.view ä¸å…è®¸çš„æ“ä½œ

å¯ä»¥å°†å‡½æ•°å£°æ˜ä¸º view ç±»å‹ï¼Œè¿™ç§æƒ…å†µä¸‹è¦ä¿è¯ä¸ä¿®æ”¹çŠ¶æ€ã€‚å£°æ˜ä¸º view å›¾å‡½æ•°ï¼Œå¯ä»¥åœ¨å‡½æ•°å£°æ˜é‡Œï¼Œæ·»åŠ  view å…³é”®å­—ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

contract C {
    function f(uint256 a, uint256 b) public view returns (uint256) {
        return a * (b + 42) + block.timestamp;
    }
}
```

**æ³¨è§£**: Getter æ–¹æ³•è‡ªåŠ¨è¢«æ ‡è®°ä¸º viewã€‚

å¦‚æœå‡½æ•°ä¸­å­˜åœ¨ä»¥ä¸‹è¯­å¥ï¼Œåˆ™è¢«è§†ä¸ºä¿®æ”¹çŠ¶æ€ï¼Œç¼–è¯‘å™¨å°†æŠ›å‡ºè­¦å‘Šã€‚

- ä¿®æ”¹çŠ¶æ€å˜é‡ã€‚
- è§¦å‘äº‹ä»¶ã€‚
- åˆ›å»ºå…¶å®ƒåˆçº¦ã€‚
- ä½¿ç”¨ `selfdestruct`ã€‚
- é€šè¿‡è°ƒç”¨å‘é€ä»¥å¤ªå¸ã€‚
- è°ƒç”¨ä»»ä½•æ²¡æœ‰æ ‡è®°ä¸º view æˆ–è€… pure çš„å‡½æ•°ã€‚
- ä½¿ç”¨åº•å±‚è°ƒç”¨
  - (TODO:è¿™é‡Œæ˜¯ call æ“ä½œä¹ˆï¼Ÿ)
- ä½¿ç”¨åŒ…å«æŸäº›æ“ä½œç çš„å†…è”ç¨‹åºé›†ã€‚

### payable

### ä¸€ä¸ªåŠ å’Œå‡çš„ DEMO

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Counter{
    uint public count ;

    function add() external {
        count+=1;
    }

    function minus() external {
        count-=1;
    }
}
```

### çŠ¶æ€å¯å˜æ€§çš„ç±»å‹è½¬æ¢

å¦‚æœæ»¡è¶³ä¸‹åˆ—æ¡ä»¶ï¼Œå‡½æ•°ç±»å‹ A å¯ä»¥éšå¼è½¬æ¢ä¸ºå‡½æ•°ç±»å‹:

- å®ƒä»¬çš„å‚æ•°ç±»å‹ç›¸åŒï¼Œè¿”å›ç±»å‹ç›¸åŒï¼Œå®ƒä»¬çš„å†…éƒ¨/å¤–éƒ¨å±æ€§æ˜¯ç›¸åŒçš„ï¼Œå¹¶ä¸” A çš„çŠ¶æ€å¯å˜æ€§æ¯” B çš„çŠ¶æ€å¯å˜æ€§æ›´å…·é™åˆ¶æ€§

æ¯”å¦‚ï¼š

- pure å‡½æ•°å¯ä»¥è½¬æ¢ä¸º view å’Œ non-payable å‡½æ•°
- view å‡½æ•°å¯ä»¥è½¬æ¢ä¸º non-payable å‡½æ•°
- payable å‡½æ•°å¯ä»¥è½¬æ¢ä¸º non-payable å‡½æ•°
- å…¶ä»–çš„è½¬æ¢åˆ™ä¸å¯ä»¥ã€‚

å…³äº `payable` å’Œ `non-payable` çš„è§„åˆ™å¯èƒ½æœ‰ç‚¹ä»¤äººå›°æƒ‘ï¼Œä½†å®è´¨ä¸Šï¼Œå¦‚æœä¸€ä¸ªå‡½æ•°æ˜¯ `payable` ï¼Œè¿™æ„å‘³ç€å®ƒ ä¹Ÿæ¥å—é›¶ä»¥å¤ªçš„æ”¯ä»˜ï¼Œå› æ­¤å®ƒä¹Ÿæ˜¯ `non-payable` ã€‚ å¦ä¸€æ–¹é¢ï¼Œ`non-payable` å‡½æ•°å°†æ‹’ç»å‘é€ç»™å®ƒçš„ ä»¥å¤ªå¸ Ether ï¼Œ æ‰€ä»¥ `non-payable` å‡½æ•°ä¸èƒ½è½¬æ¢ä¸º `payable` å‡½æ•°ã€‚

## 6ï¸âƒ£ å‡½æ•°çš„è¿”å›å€¼ returns/return

å‡½æ•°è¿”å›ç±»å‹ä¸èƒ½ä¸ºç©º â€”â€” å¦‚æœå‡½æ•°ç±»å‹ä¸éœ€è¦è¿”å›ï¼Œåˆ™éœ€è¦åˆ é™¤æ•´ä¸ª `returns (<return types>)` éƒ¨åˆ†ã€‚

å‡½æ•°å¯èƒ½è¿”å›ä»»æ„æ•°é‡çš„å‚æ•°ä½œä¸ºè¾“å‡ºã€‚å‡½æ•°çš„è¿”å›å€¼æœ‰ä¸¤ä¸ªå…³é”®å­—ï¼Œä¸€ä¸ªæ˜¯`returns`,ä¸€ä¸ªæ˜¯ `return`;

- `returns` æ˜¯åœ¨å‡½æ•°ååé¢çš„ï¼Œç”¨æ¥æ ‡ç¤ºè¿”å›å€¼çš„æ•°é‡ï¼Œç±»å‹ï¼Œåå­—ä¿¡æ¯ã€‚
- `return` æ˜¯åœ¨å‡½æ•°ä¸»ä½“å†…ï¼Œç”¨äºè¿”å› `returns` æŒ‡å®šçš„æ•°æ®ä¿¡æ¯

### å¤šç§è¿”å›å€¼

å‡½æ•°è¿”å›å˜é‡çš„å£°æ˜æ–¹å¼åœ¨å…³é”®è¯ `returns` ä¹‹åï¼Œä¸å‚æ•°çš„å£°æ˜æ–¹å¼ç›¸åŒã€‚å‡½æ•°æœ‰ä»¥ä¸‹å‡ ä¸ªè¿”å›å€¼ã€‚

1. å•ä¸ªè¿”å›å€¼
2. å¤šä¸ªè¿”å›å€¼
3. å¸¦æœ‰åå­—çš„è¿”å›å€¼
4. éšå¼è¿”å›

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract FunctionOutputs {
    // å•ä¸ªè¿”å›å€¼
    function returnSingle() public pure returns (uint256) {
        return 1;
    }

    // å¤šä¸ªè¿”å›å€¼
    function returnMultiple() public pure returns (uint256, bool) {
        return (1, true);
    }

    // å¸¦æœ‰åå­—çš„è¿”å›å€¼
    // è¿™ä¸ªå½¢å¼ç­‰åŒäºèµ‹å€¼ç»™è¿”å›å‚æ•°ï¼Œç„¶åç”¨ return; é€€å‡ºã€‚
    function returnName() public pure returns (uint256 u, bool b) {
        return (1, true);
    }

    // éšå¼è¿”å›
    function returnAssigned() public pure returns (uint256 u, bool b) {
        u = 1;
        b = true;
    }
}
```

**è¿”å›å˜é‡åå¯ä»¥è¢«çœç•¥**ã€‚ è¿”å›å˜é‡å¯ä»¥å½“ä½œä¸ºå‡½æ•°ä¸­çš„æœ¬åœ°å˜é‡ï¼Œæ²¡æœ‰æ˜¾å¼è®¾ç½®çš„è¯ï¼Œä¼šä½¿ç”¨ :é»˜è®¤å€¼ã€‚è¿”å›å˜é‡å¯ä»¥æ˜¾å¼ç»™å®ƒé™„ä¸€ä¸ªå€¼

å¦‚æœä½¿ç”¨ return æå‰é€€å‡ºæœ‰è¿”å›å€¼çš„å‡½æ•°ï¼Œ å¿…é¡»åœ¨ç”¨ return æ—¶æä¾›è¿”å›å€¼ã€‚

**æ³¨è§£**ï¼šéå†…éƒ¨å‡½æ•°æœ‰äº›ç±»å‹æ²¡æ³•è¿”å›ï¼Œæ¯”å¦‚é™åˆ¶çš„ç±»å‹æœ‰ï¼šå¤šç»´åŠ¨æ€æ•°ç»„ã€ç»“æ„ä½“ç­‰ã€‚å¦‚æœæ·»åŠ  `pragma abicoder v2;` å¯ç”¨ ABI V2 ç¼–ç å™¨ï¼Œåˆ™æ˜¯å¯ä»¥çš„è¿”å›æ›´å¤šç±»å‹ï¼Œä¸è¿‡ mapping ä»ç„¶æ˜¯å—é™çš„ã€‚

### å°æµ‹è¯•:å¦‚ä¸‹åˆçº¦ï¼Œtest è°ƒç”¨åè¿”å›ä»€ä¹ˆ

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    //å½“ç»™è¿”å›å€¼èµ‹å€¼åï¼Œå¹¶ä¸”æœ‰ä¸ªreturnï¼Œä»¥æœ€åçš„returnä¸ºä¸»
    function test() public pure returns (uint256 mul) {
        uint256 a = 10;
        mul = 100;
        return a;
    }
}
```

ç­”æ¡ˆ: è¿”å›ç»“æœæ˜¯: `0:uint256: mul 10`

### åˆçº¦å†…å‡½æ•°è¿”å›å€¼çš„æ¥æ”¶

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract FunctionOutputs {
    // å¤šä¸ªè¿”å›å€¼
    function returnMultiple() public pure returns (uint256, bool) {
        return (1, true);
    }

    function a() external pure returns (uint256 u, bool b) {
        // æ¥æ”¶è¿”å›å€¼
        (uint256 uu, bool bb) = returnMultiple();

        // åªæ¥å—ä¸€ä¸ªè¿”å›å€¼
        (, bool bbb) = returnMultiple();

        // æ¥æ”¶å¹¶è¿”å›
        (u, b) = returnMultiple();
    }
}
```

### è§£æ„èµ‹å€¼å’Œè¿”å›å¤šå€¼

Solidity å†…éƒ¨å…è®¸å…ƒç»„ (tuple) ç±»å‹ï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªåœ¨ç¼–è¯‘æ—¶å…ƒç´ æ•°é‡å›ºå®šçš„å¯¹è±¡åˆ—è¡¨ï¼Œåˆ—è¡¨ä¸­çš„å…ƒç´ å¯ä»¥æ˜¯ä¸åŒç±»å‹çš„å¯¹è±¡ã€‚è¿™äº›å…ƒç»„å¯ä»¥ç”¨æ¥åŒæ—¶è¿”å›å¤šä¸ªæ•°å€¼ï¼Œä¹Ÿå¯ä»¥ç”¨å®ƒä»¬æ¥åŒæ—¶ç»™å¤šä¸ªæ–°å£°æ˜çš„å˜é‡æˆ–è€…æ—¢å­˜çš„å˜é‡ï¼ˆæˆ–é€šå¸¸çš„ LValuesï¼‰ï¼š

```
pragma solidity >=0.5.0 <0.9.0;

contract C {
    uint index;

    function f() public pure returns (uint, bool, uint) {
        return (7, true, 2);
    }

    function g() public {
        //åŸºäºè¿”å›çš„å…ƒç»„æ¥å£°æ˜å˜é‡å¹¶èµ‹å€¼
        (uint x, bool b, uint y) = f();
        //äº¤æ¢ä¸¤ä¸ªå€¼çš„é€šç”¨çªé—¨â€”â€”ä½†ä¸é€‚ç”¨äºéå€¼ç±»å‹çš„å­˜å‚¨ (storage) å˜é‡ã€‚
        (x, y) = (y, x);
        //å…ƒç»„çš„æœ«å°¾å…ƒç´ å¯ä»¥çœç•¥ï¼ˆè¿™ä¹Ÿé€‚ç”¨äºå˜é‡å£°æ˜ï¼‰ã€‚
        (index,,) = f(); // è®¾ç½® index ä¸º 7
    }
}
```

ä¸å¯èƒ½æ··åˆå˜é‡å£°æ˜å’Œéå£°æ˜å˜é‡å¤åˆ¶, å³ä»¥ä¸‹æ˜¯æ— æ•ˆçš„: `(x, uint y) = (1, 2);`

åœ¨ 0.5.0 ç‰ˆæœ¬ä¹‹å‰ï¼Œç»™å…·æœ‰æ›´å°‘çš„å…ƒç´ æ•°çš„å…ƒç»„èµ‹å€¼éƒ½å¯ä»¥å¯èƒ½çš„ï¼Œæ— è®ºæ˜¯åœ¨å·¦è¾¹è¿˜æ˜¯å³è¾¹ï¼ˆæ¯”å¦‚åœ¨æœ€åç©ºå‡ºè‹¥å¹²å…ƒç´ ï¼‰ã€‚ç°åœ¨ï¼Œè¿™å·²ç»ä¸å…è®¸äº†ï¼Œèµ‹å€¼æ“ä½œçš„ä¸¤è¾¹åº”è¯¥å…·æœ‰ç›¸åŒä¸ªæ•°çš„ç»„æˆå…ƒç´ ã€‚

å½“æ¶‰åŠå¼•ç”¨ç±»å‹æ—¶ï¼Œåœ¨åŒæ—¶åˆ†é…ç»™å¤šä¸ªå˜é‡æ—¶è¦å°å¿ƒ, å› ä¸ºè¿™å¯èƒ½ä¼šå¯¼è‡´æ„å¤–çš„å¤åˆ¶è¡Œä¸ºã€‚

### æ•°ç»„å’Œç»“æ„ä½“çš„å¤æ‚æ€§

`TODO:` èµ‹å€¼è¯­ä¹‰å¯¹äºåƒæ•°ç»„å’Œç»“æ„ä½“(åŒ…æ‹¬ bytes å’Œ string) è¿™æ ·çš„éå€¼ç±»å‹æ¥è¯´ä¼šæœ‰äº›å¤æ‚ã€‚å‚è€ƒ æ•°æ®ä½ç½®åŠèµ‹å€¼è¡Œä¸º äº†è§£æ›´å¤š ã€‚

åœ¨ä¸‹é¢çš„ç¤ºä¾‹ä¸­, å¯¹ `g(x)` çš„è°ƒç”¨å¯¹ `x` æ²¡æœ‰å½±å“, å› ä¸ºå®ƒåœ¨å†…å­˜ä¸­åˆ›å»ºäº†å­˜å‚¨å€¼ç‹¬ç«‹å‰¯æœ¬ã€‚ä½†æ˜¯, `h(x)` æˆåŠŸä¿®æ”¹ `x` , å› ä¸ºåªä¼ é€’å¼•ç”¨è€Œä¸ä¼ é€’å‰¯æœ¬ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

 contract C {
    uint[20] public x;

     function f() public {
        g(x);
        h(x);
    }

     function g(uint[20] memory y) internal pure {
        y[2] = 3;
    }

     function h(uint[20] storage y) internal {
        y[3] = 4;
    }
}
```

## 7ï¸âƒ£ å‡½æ•°çš„ç­¾å/å‡½æ•°æ ‡è¯†ç¬¦

åœ¨å˜é‡çš„å…¨å±€å˜é‡é‚£ä¸€ç« ï¼Œæˆ‘ä»¬ä»‹ç»äº† `msg.data` `msg.sig`,åˆ†åˆ«æ˜¯è°ƒç”¨åˆçº¦çš„å®Œæ•´çš„ calldataï¼Œä»¥åŠ**å‡½æ•°æ ‡è¯†ç¬¦**ï¼ˆcalldata çš„å‰å››ä¸ªå­—èŠ‚ï¼‰

### æŸ¥çœ‹ msg.data

ä»£ç å¦‚ä¸‹

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Receiver {
    event Log(bytes data1, bytes4 data2);

    function transfer(address recipient, uint256 amount)
        external
        payable
        returns (address, uint256)
    {
        emit Log(msg.data, msg.sig);
        return (msg.sender, msg.value);
    }
}
```

- **è¾“å…¥**:
  - `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4`
  - `1`
- **logs ç»“æœ**:
  - **data1** ï¼ˆä¸ºäº†æ–¹ä¾¿é˜…è¯»ï¼Œæˆ‘æ‹†åˆ†æˆå¦‚ä¸‹ï¼‰
    ```
    0xa9059cbb
    0000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc4
    0000000000000000000000000000000000000000000000000000000000000001
    ```
  - **data2** ç»“æœå¦‚ä¸‹
    - `0xa9059cbb`
- **output ç»“æœ**:
  - `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4`
  - `2`

### msg.data ä¸­**å‡½æ•°æ ‡è¯†ç¬¦**çš„å®ç°é€»è¾‘

æ ¸å¿ƒ: `bytes4(keccak256(bytes("transfer(address,uint256)")))`

ä¸€ä¸ªå‡½æ•°è°ƒç”¨æ•°æ®çš„å‰ 4 å­—èŠ‚ï¼ŒæŒ‡å®šäº†è¦è°ƒç”¨çš„å‡½æ•°ã€‚è¿™å°±æ˜¯æŸä¸ªå‡½æ•°ç­¾åçš„ Keccak å“ˆå¸Œçš„å‰ 4 å­—èŠ‚ï¼ˆbytes32 ç±»å‹æ˜¯ä»å·¦å–å€¼ï¼‰ã€‚

å‡½æ•°ç­¾åè¢«å®šä¹‰ä¸ºåŸºç¡€åŸå‹çš„è§„èŒƒè¡¨è¾¾ï¼Œè€ŒåŸºç¡€åŸå‹æ˜¯**å‡½æ•°åç§°åŠ ä¸Šç”±æ‹¬å·æ‹¬èµ·æ¥çš„å‚æ•°ç±»å‹åˆ—è¡¨ï¼Œå‚æ•°ç±»å‹é—´ç”±ä¸€ä¸ªé€—å·åˆ†éš”å¼€ï¼Œä¸”æ²¡æœ‰ç©ºæ ¼ã€‚**.

ä»£ç å¦‚ä¸‹ï¼Œè·å– Hash åçš„å€¼ï¼Œå’Œæˆªå–åçš„å€¼

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract FunctionSelector {
    function getSelector(string calldata _func)
        external
        pure
        returns (bytes32, bytes4)
    {
        // _func å­—ç¬¦ä¸²é€šè¿‡ bytes è½¬ä¸º bytes
        // ä½¿ç”¨ keccak256 è¿›è¡Œ Hashå€¼è¿ç®—
        // ä½¿ç”¨ bytes4 æˆªå– keccak256 è¿”å›çš„32ä½æ•°æ®
        return (keccak256(bytes(_func)), bytes4(keccak256(bytes(_func))));
    }
}
```

**æµ‹è¯•ï¼š**

1. éƒ¨ç½²
2. è¾“å…¥ `"transfer(address,uint256)"`
3. è·å–ç»“æ„
   1. `0xa9059cbb2ab09eb219583f4a59a5d0623ade346d962bcd4e46b11da047c9049b`
   2. `0xa9059cbb`

æ³¨æ„ï¼šä»¥ä¸Šä»…ä»…æ˜¯èƒŒåçš„åŸç†å±•ç¤ºï¼Œå¦‚æœæƒ³è¦è·å–å€¼ï¼Œå¯ä»¥é€šè¿‡`.selector` è¿”å› ABI å‡½æ•°é€‰æ‹©å™¨

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

library L {
    function f(uint256) external {}
}

contract C {
    function g() public pure returns (bytes4) {
        return L.f.selector;
    }
}
```

å°½ç®¡å¯ä»¥å¯¹ public æˆ– external çš„åº“å‡½æ•°è¿›è¡Œå¤–éƒ¨è°ƒç”¨ï¼Œä½†æ­¤ç±»è°ƒç”¨ä¼šè¢«è§†ä¸º Solidity çš„å†…éƒ¨è°ƒç”¨ï¼Œä¸å¸¸è§„çš„ contract ABI è§„åˆ™ä¸åŒã€‚å¤–éƒ¨åº“å‡½æ•°æ¯”å¤–éƒ¨åˆçº¦å‡½æ•°æ”¯æŒæ›´å¤šçš„å‚æ•°ç±»å‹ï¼Œä¾‹å¦‚é€’å½’ç»“æ„å’ŒæŒ‡å‘å­˜å‚¨çš„æŒ‡é’ˆã€‚

å› æ­¤ï¼Œè®¡ç®—ç”¨äºè®¡ç®— 4 å­—èŠ‚é€‰æ‹©å™¨çš„å‡½æ•°ç­¾åéµå¾ªå†…éƒ¨å‘½åæ¨¡å¼ä»¥åŠå¯å¯¹åˆçº¦ ABI ä¸­ä¸æ”¯æŒçš„ç±»å‹çš„å‚æ•°ä½¿ç”¨å†…éƒ¨ç¼–ç ã€‚

ä»¥ä¸‹æ ‡è¯†ç¬¦å¯ä»¥ä½œä¸ºå‡½æ•°ç­¾åä¸­çš„ç±»å‹ï¼š

- å€¼ç±»å‹, éå­˜å‚¨çš„ï¼ˆnon-storageï¼‰ `string` åŠéå­˜å‚¨çš„ `bytes`
  ä½¿ç”¨å’Œåˆçº¦ ABI ä¸­åŒæ ·çš„æ ‡è¯†ç¬¦ã€‚
- éå­˜å‚¨çš„æ•°ç»„ç±»å‹éµå¾ªåˆçº¦ ABI ä¸­åŒæ ·çš„è§„åˆ™ï¼Œä¾‹å¦‚ `<type>[]`
  ä¸ºåŠ¨æ€æ•°ç»„ä»¥åŠ `<type>[M]` ä¸º `M` ä¸ªå…ƒç´ çš„åŠ¨æ€æ•°ç»„ã€‚
- éå­˜å‚¨çš„ç»“æ„ä½“ä½¿ç”¨å®Œæ•´çš„å‘½åå¼•ç”¨ï¼Œä¾‹å¦‚ `C.S` ç”¨äº
  `contract C { struct S { ... } }`.
- å­˜å‚¨çš„æ˜ å°„æŒ‡é’ˆä½¿ç”¨ `mapping(<keyType> => <valueType>) storage` å½“
  `<keyType>` å’Œ `<valueType>` æ˜¯æ˜ å°„çš„é”®å’Œå€¼ç±»å‹ã€‚
- å…¶ä»–çš„å­˜å‚¨çš„æŒ‡é’ˆç±»å‹ä½¿ç”¨å…¶å¯¹åº”çš„éå­˜å‚¨ç±»å‹çš„ç±»å‹æ ‡è¯†ç¬¦ï¼Œä½†åœ¨å…¶åé¢é™„åŠ ä¸€ä¸ªç©ºæ ¼åŠ
  `storage` ã€‚

## 8ï¸âƒ£ å‡½æ•°çš„é‡è½½

Solidity çš„å‡½æ•°é‡è½½ï¼Œæ˜¯æŒ‡åŒä¸€ä¸ªä½œç”¨åŸŸå†…ï¼Œç›¸åŒå‡½æ•°åå¯ä»¥å®šä¹‰å¤šä¸ªå‡½æ•°ã€‚

**è¿™äº›ç›¸åŒå‡½æ•°åçš„å‡½æ•°ï¼Œå‚æ•°(å‚æ•°ç±»å‹æˆ–å‚æ•°æ•°é‡)å¿…é¡»ä¸ä¸€æ ·ã€‚**ï¼Œå› ä¸ºåªæœ‰è¿™æ ·ä¸Šä¸€èŠ‚ä»‹ç»çš„å‡½æ•°ç­¾åä¸­ï¼Œæ‰èƒ½ç­¾å‡ºæ¥ä¸åŒçš„å‡½æ•°é€‰æ‹©å™¨ã€‚

åˆçº¦å¯ä»¥å…·æœ‰å¤šä¸ªä¸åŒå‚æ•°çš„åŒåå‡½æ•°ï¼Œç§°ä¸ºâ€é‡è½½â€ï¼ˆoverloadingï¼‰ï¼Œè¿™ä¹Ÿé€‚ç”¨äºç»§æ‰¿å‡½æ•°ã€‚

ä¸‹é¢æ˜¯ä¸¤ç§ sum æ–¹æ³•ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    function sum(uint256 a, uint256 b) public pure returns (uint256) {
        return a + b;
    }

    function sum(uint256[] memory _arr) public pure returns (uint256 temp) {
        for (uint256 index = 0; index < _arr.length; index++) {
            temp += _arr[index];
        }
    }

    function callSum1() public pure returns (uint256) {
        return sum(1, 2);
    }

    function callSum2() public pure returns (uint256) {
        // ä¸‹é¢ nums1 è¿™ç§åŠ¨æ€åˆ›å»ºæ•°ç»„çš„æ–¹æ³•æ˜¯ä¸å¯¹çš„ï¼Œä¼šæŠ¥é”™
        // uint256[] memory nums1 = [1, 2, 3];
        uint256[] memory nums = new uint256[](5);
        nums[0] = 1;
        nums[1] = 2;
        nums[2] = 3;
        nums[3] = 4;
        nums[4] = 5;
        return sum(nums);
    }
}
```

é‡è½½å‡½æ•°ä¹Ÿå­˜åœ¨äºå¤–éƒ¨æ¥å£ä¸­ã€‚å¦‚æœä¸¤ä¸ªå¤–éƒ¨å¯è§å‡½æ•°ä»…åŒºåˆ«äº Solidity
å†…çš„ç±»å‹ï¼Œè€Œä¸æ˜¯å®ƒä»¬çš„å¤–éƒ¨ç±»å‹åˆ™ä¼šå¯¼è‡´é”™è¯¯ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

// Function overload clash during conversion to external types for arguments.Ã
contract A {
    function f(B value) public pure returns (B out) {
        out = value;
    }

    function f(address value) public pure returns (address out) {
        out = value;
    }
}

contract B {}
```

ä»¥ä¸Šä¸¤ä¸ª `f` å‡½æ•°é‡è½½éƒ½æ¥å—äº† ABI çš„åœ°å€ç±»å‹ï¼Œè™½ç„¶å®ƒä»¬åœ¨ Solidity
ä¸­è¢«è®¤ä¸ºæ˜¯ä¸åŒçš„ã€‚

#### é€‰æ‹©é‡è½½å‡½æ•° & å‚æ•°åŒ¹é…

é€‰æ‹©é‡è½½å‡½æ•°ï¼šé€šè¿‡å°†å½“å‰èŒƒå›´å†…çš„å‡½æ•°å£°æ˜ä¸å‡½æ•°è°ƒç”¨ä¸­æä¾›çš„å‚æ•°ç›¸åŒ¹é…ï¼Œè¿™æ ·å°±å¯ä»¥é€‰æ‹©é‡è½½å‡½æ•°ã€‚

å¦‚æœæ‰€æœ‰å‚æ•°éƒ½å¯ä»¥éšå¼åœ°è½¬æ¢ä¸ºé¢„æœŸç±»å‹ï¼Œåˆ™è¯¥å‡½æ•°ä½œä¸ºé‡è½½å€™é€‰é¡¹ã€‚å¦‚æœä¸€ä¸ªåŒ¹é…çš„éƒ½æ²¡æœ‰ï¼Œè§£æå¤±è´¥ã€‚

âš ï¸ï¼šè¿”å›å‚æ•°ä¸ä½œä¸ºé‡è½½è§£æçš„ä¾æ®ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

contract A {
    function f(uint8 val) public pure returns (uint8 out) {
        out = val;
    }

    function f(uint256 val) public pure returns (uint256 out) {
        out = val;
    }
}

contract B {
    A a;

    // Member "f" not unique after argument-dependent lookup in contract A.
    // function test1() public view returns (uint256) {
    //     uint256 tar = a.f(8);
    //     return tar;
    // }

    function test2() public view returns (uint256) {
        uint256 tar = a.f(256);
        return tar;
    }
}
```

åœ¨ Remix é‡Œ,éƒ¨ç½² A åˆçº¦ï¼Œä¼šå°†ä¸¤ä¸ªæ–¹æ³•éƒ½æ¸²æŸ“å‡ºæ¥ï¼Œè°ƒç”¨ `f(50)`/`f(256)` éƒ½å¯ä»¥ã€‚

ä½†æ˜¯å®é™…è°ƒç”¨é‡Œï¼Œåœ¨å…¶ä»–åˆçº¦å†…è°ƒç”¨ `f(50)` ä¼šå¯¼è‡´ç±»å‹é”™è¯¯ï¼Œå› ä¸º `50` æ—¢å¯ä»¥è¢«éšå¼è½¬æ¢ä¸º `uint8`ä¹Ÿå¯ä»¥è¢«éšå¼è½¬æ¢ä¸º `uint256`ã€‚ å¦ä¸€æ–¹é¢ï¼Œè°ƒç”¨ `f(256)` åˆ™ä¼šè§£æä¸º`f(uint256)` é‡è½½ï¼Œå› ä¸º `256` ä¸èƒ½éšå¼è½¬æ¢ä¸º `uint8`ã€‚

## 9ï¸âƒ£ modifier:å‡½æ•°ä¿®æ”¹å™¨

Solidity ä¸­å…³é”®å­— `modifier` ç”¨äºå£°æ˜ä¸€ä¸ªå‡½æ•°ä¿®æ”¹å™¨ã€‚

- **æ„ä¹‰**:æˆ‘ä»¬å¯ä»¥å°†ä¸€äº›é€šç”¨çš„æ“ä½œæå–å‡ºæ¥ï¼ŒåŒ…è£…ä¸ºå‡½æ•°ä¿®æ”¹å™¨ï¼Œæ¥æé«˜ä»£ç çš„å¤ç”¨æ€§ï¼Œæ”¹å–„ç¼–ç æ•ˆç‡ã€‚æ˜¯å‡½æ•°é«˜å†…èšï¼Œä½è€¦åˆçš„å»¶ä¼¸ã€‚
- **ä½œç”¨**: `modifier` å¸¸ç”¨äºåœ¨å‡½æ•°æ‰§è¡Œå‰æ£€æŸ¥æŸç§å‰ç½®æ¡ä»¶ã€‚
  - æ¯”å¦‚åœ°å€å¯¹ä¸å¯¹ï¼Œä½™é¢æ˜¯å¦å……è¶³ï¼Œå‚æ•°å€¼æ˜¯å¦å…è®¸ç­‰
  - ä¿®æ”¹å™¨å†…å¯ä»¥å†™é€»è¾‘
- **ç‰¹ç‚¹**: `modifier` æ˜¯ä¸€ç§åˆçº¦å±æ€§ï¼Œå¯è¢«ç»§æ‰¿ï¼ŒåŒæ—¶è¿˜å¯è¢«æ´¾ç”Ÿçš„åˆçº¦é‡å†™(override)ã€‚ï¼ˆä¿®æ”¹å™¨ modifier æ˜¯åˆçº¦çš„å¯ç»§æ‰¿å±æ€§ï¼Œå¹¶å¯èƒ½è¢«æ´¾ç”Ÿåˆçº¦è¦†ç›– , ä½†å‰ææ˜¯å®ƒä»¬è¢«æ ‡è®°ä¸º virtualï¼‰ã€‚
  - `_` ç¬¦å·å¯ä»¥åœ¨ä¿®æ”¹å™¨ä¸­å‡ºç°å¤šæ¬¡ï¼Œæ¯å¤„éƒ½ä¼šæ›¿æ¢ä¸ºå‡½æ•°ä½“ã€‚

### æ­£å¸¸çš„åˆ¤æ–­

ä¸‹é¢æ˜¯æ­£å¸¸çš„å‰ç½®åˆ¤æ–­ï¼Œéå¸¸çš„å•°å—¦ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract ErrorModifier{
     address public owner;
    uint public count = 0;
     constructor(){
         owner = msg.sender;
     }
     function add() external{
         require(msg.sender==owner,"must owner address");
         count++;
     }
     function minus() external{
         require(msg.sender==owner,"must owner address");
         count--;
     }
}
```

### å‡½æ•°ä¿®æ”¹å™¨:æ™®é€š

å°†é€šç”¨çš„åˆ¤æ–­æŠ½å‡ºä¸ºå‡½æ•°ä¿®æ”¹å™¨ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract ErrorModifier{
     address public owner;
     uint public count = 0;

     constructor(){
         owner = msg.sender;
     }

    // ä¸‹é¢å°±æ˜¯å‡½æ•°ä¿®æ”¹å™¨
     modifier onlyOwner(){
         require(msg.sender==owner,"must owner address");
         _;
     }
     function add() external onlyOwner{
         count++;
     }
     function minus() external onlyOwner{
         count--;
     }

}
```

### å‡½æ•°ä¿®æ”¹å™¨:å¸¦å‚æ•°

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract ErrorModifier{
     address public owner;
    uint public count = 0;
     constructor(){
         owner = msg.sender;
     }

    // ä¸‹é¢å°±æ˜¯å‡½æ•°ä¿®æ”¹å™¨
     modifier onlyOwner(){
         require(msg.sender==owner,"must owner address");
         _;
     }

     modifier greaterThan(uint _x){
         require(_x > 10,"must be greater than 10");
         _;
     }

     function fnA(uint _x) external onlyOwner greaterThan( _x){
         count=_x;
     }

}
```

### å‡½æ•°ä¿®æ”¹å™¨:ä¿®æ”¹å™¨å†…å†™é€»è¾‘

ä¸‹é¢æ˜¯ä¸€ä¸ªé˜²é‡è½½çš„å‡½æ•°ä¿®æ”¹å™¨ï¼Œè¿™ç§ä½¿ç”¨æ–¹æ³•ï¼Œåœ¨ä½ç‰ˆæœ¬çš„ solidity ä¸­å¯ä»¥é˜²æ­¢é‡å…¥æ”»å‡»ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    bool internal locked;

    modifier noReentrant() {
        require(!locked, "no reentrant");
        locked = true;
        _;
        locked = false;
    }

    function test() public noReentrant returns (bool) {
        return locked;
    }
}
```

**æ‰©å±•:`TODO:`**

- é‡å…¥æ”»å‡»çš„æ›´å¤šä»‹ç»,å‚ç…§æ–‡ç«  [é‡å…¥æ”»å‡»](/forever/901.safe.html#id2) è¯¦ç»†é˜…è¯»ã€‚
- æ›´å¤šåˆçº¦å®‰å…¨,å‚ç…§æ–‡ç«  [åˆçº¦å®‰å…¨](/forever/901.safe.html#) è¯¦ç»†é˜…è¯»ã€‚

### ä¸€ä¸ª ownable çš„ DEMO

è¿™ä¸ªä¾‹å­ä½¿ç”¨äº† **æ„é€ å‡½æ•°** å’Œ **å‡½æ•°ä¿®æ”¹å™¨**ã€‚è¿™æ˜¯å‡½æ•°ä¿®æ”¹å™¨çš„ç»å…¸åº”ç”¨ï¼Œæ˜¯ OpenZeppelin åº“ä¸­çš„ Ownable åˆçº¦æ ¸å¿ƒé€»è¾‘ï¼š

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Ownable {
    address public owner;

    // å‘å¸ƒäº‹ä»¶ - æ­¤åˆçº¦ownerå·²ç»æ¢äººï¼ˆæ­¤é€»è¾‘ä¸modifieræ— å…³ï¼Œå¯ä»¥å¿½ç•¥ï¼‰
    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "must owner");
        _;
    }
    modifier notZeroAddress(address _newOwner) {
        require(_newOwner != address(0), "invalid address");
        _;
    }

    function transferOwnership(address _newOwner)
        external
        onlyOwner
        notZeroAddress(_newOwner)
    {
        emit OwnershipTransferred(msg.sender, _newOwner);
        owner = _newOwner;
    }

    function getByOwner() external view onlyOwner returns (address) {
        return owner;
    }

    function getByany() external view returns (address) {
        return owner;
    }
}
```

**æ‰©å±•**:è¯¦ç»†å†…å®¹ï¼Œè¯·æŸ¥çœ‹ [OpenZeppelin åº“ä¸­çš„ Ownable æºç ](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol)

### å‡½æ•° ä¿®æ”¹å™¨ çš„å¤æ‚ä¾‹å­

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract owned {
    address owner;

    constructor() { owner = payable(msg.sender); }

    // è¿™ä¸ªåˆçº¦åªå®šä¹‰ä¸€ä¸ªä¿®æ”¹å™¨ï¼Œä½†å¹¶æœªä½¿ç”¨ï¼š å®ƒå°†ä¼šåœ¨æ´¾ç”Ÿåˆçº¦ä¸­ç”¨åˆ°ã€‚
    // ä¿®æ”¹å™¨æ‰€ä¿®é¥°çš„å‡½æ•°ä½“ä¼šè¢«æ’å…¥åˆ°ç‰¹æ®Šç¬¦å· _; çš„ä½ç½®ã€‚
    // è¿™æ„å‘³ç€å¦‚æœæ˜¯ owner è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œåˆ™å‡½æ•°ä¼šè¢«æ‰§è¡Œï¼Œå¦åˆ™ä¼šæŠ›å‡ºå¼‚å¸¸ã€‚
    modifier onlyOwner {
        require(
            msg.sender == owner,
            "Only owner can call this function."
        );
        _;
    }
}

contract destructible is owned {
    // è¿™ä¸ªåˆçº¦ä» `owned` ç»§æ‰¿äº† `onlyOwner` ä¿®é¥°ç¬¦ï¼Œå¹¶å°†å…¶åº”ç”¨äº `destroy` å‡½æ•°ï¼Œ
    // åªæœ‰åœ¨åˆçº¦é‡Œä¿å­˜çš„ owner è°ƒç”¨ `destroy` å‡½æ•°ï¼Œæ‰ä¼šç”Ÿæ•ˆã€‚
    function destroy() public onlyOwner {
        selfdestruct(owner);
    }
}

contract priced {
    // ä¿®æ”¹å™¨å¯ä»¥æ¥æ”¶å‚æ•°ï¼š
    modifier costs(uint price) {
        if (msg.value >= price) {
            _;
        }
    }
}

contract Register is priced, destructible {
    mapping (address => bool) registeredAddresses;
    uint price;

    constructor(uint initialPrice) { price = initialPrice; }

    // åœ¨è¿™é‡Œä¹Ÿä½¿ç”¨å…³é”®å­— `payable` éå¸¸é‡è¦ï¼Œå¦åˆ™å‡½æ•°ä¼šè‡ªåŠ¨æ‹’ç»æ‰€æœ‰å‘é€ç»™å®ƒçš„ä»¥å¤ªå¸ã€‚
    function register() public payable costs(price) {
        registeredAddresses[msg.sender] = true;
    }

    function changePrice(uint price_) public onlyOwner {
        price = price_;
    }
}

contract Mutex {
    bool locked;
    modifier noReentrancy() {
        require(
            !locked,
            "Reentrant call."
        );
        locked = true;
        _;
        locked = false;
    }

    // è¿™ä¸ªå‡½æ•°å—äº’æ–¥é‡ä¿æŠ¤ï¼Œè¿™æ„å‘³ç€ `msg.sender.call` ä¸­çš„é‡å…¥è°ƒç”¨ä¸èƒ½å†æ¬¡è°ƒç”¨  `f`ã€‚
    // `return 7` è¯­å¥æŒ‡å®šè¿”å›å€¼ä¸º 7ï¼Œä½†ä¿®æ”¹å™¨ä¸­çš„è¯­å¥ `locked = false` ä»ä¼šæ‰§è¡Œã€‚
    function f() public noReentrancy returns (uint) {
        (bool success,) = msg.sender.call("");
        require(success);
        return 7;
    }
}
```

å¦‚æœä½ æƒ³è®¿é—®å®šä¹‰åœ¨åˆçº¦ C çš„ ä¿®æ”¹å™¨ modifier m ï¼Œ å¯ä»¥ä½¿ç”¨ C.m å»å¼•ç”¨å®ƒï¼Œè€Œä¸éœ€è¦ä½¿ç”¨è™šæ‹Ÿè¡¨æŸ¥æ‰¾ã€‚

åªèƒ½ä½¿ç”¨åœ¨å½“å‰åˆçº¦æˆ–åœ¨åŸºç±»åˆçº¦ä¸­å®šä¹‰çš„ ä¿®æ”¹å™¨ modifier , ä¿®æ”¹å™¨ modifier ä¹Ÿå¯ä»¥å®šä¹‰åœ¨åº“é‡Œé¢ï¼Œä½†æ˜¯ä»–ä»¬è¢«é™å®šåœ¨åº“å‡½æ•°ä½¿ç”¨ã€‚

å¦‚æœåŒä¸€ä¸ªå‡½æ•°æœ‰å¤šä¸ª ä¿®æ”¹å™¨ modifierï¼Œå®ƒä»¬ä¹‹é—´ä»¥ç©ºæ ¼éš”å¼€ï¼Œä¿®æ”¹å™¨ modifier ä¼šä¾æ¬¡æ£€æŸ¥æ‰§è¡Œã€‚

ä¿®æ”¹å™¨ä¸èƒ½éšå¼åœ°è®¿é—®æˆ–æ”¹å˜å®ƒä»¬æ‰€ä¿®é¥°çš„å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼ã€‚ è¿™äº›å€¼åªèƒ½åœ¨è°ƒç”¨æ—¶æ˜ç¡®åœ°ä»¥å‚æ•°ä¼ é€’ã€‚

ä¿®æ”¹å™¨ modifier æˆ–å‡½æ•°ä½“ä¸­æ˜¾å¼çš„ return è¯­å¥ä»…ä»…è·³å‡ºå½“å‰çš„ ä¿®æ”¹å™¨ modifier å’Œå‡½æ•°ä½“ã€‚ è¿”å›å˜é‡ä¼šè¢«èµ‹å€¼ï¼Œä½†æ•´ä¸ªæ‰§è¡Œé€»è¾‘ä¼šä»å‰ä¸€ä¸ª ä¿®æ”¹å™¨ modifier ä¸­çš„å®šä¹‰çš„ `_` ä¹‹åç»§ç»­æ‰§è¡Œã€‚

è­¦å‘Š:åœ¨æ—©æœŸçš„ Solidity ç‰ˆæœ¬ä¸­ï¼Œæœ‰ ä¿®æ”¹å™¨ modifier çš„å‡½æ•°ï¼Œ return è¯­å¥çš„è¡Œä¸ºè¡¨ç°ä¸åŒã€‚ç”¨ `return`; ä»ä¿®æ”¹å™¨ä¸­æ˜¾å¼è¿”å›å¹¶ä¸å½±å“å‡½æ•°è¿”å›å€¼ã€‚ ç„¶è€Œï¼Œä¿®æ”¹å™¨å¯ä»¥é€‰æ‹©å®Œå…¨ä¸æ‰§è¡Œå‡½æ•°ä½“ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¿”å›çš„å˜é‡è¢«è®¾ç½®ä¸ºé»˜è®¤å€¼ï¼Œå°±åƒè¯¥å‡½æ•°æ˜¯ç©ºå‡½æ•°ä½“ä¸€æ ·ã€‚

`_` ç¬¦å·å¯ä»¥åœ¨ä¿®æ”¹å™¨ä¸­å‡ºç°å¤šæ¬¡ï¼Œæ¯å¤„éƒ½ä¼šæ›¿æ¢ä¸ºå‡½æ•°ä½“ã€‚

ä¿®æ”¹å™¨ modifier çš„å‚æ•°å¯ä»¥æ˜¯ä»»æ„è¡¨è¾¾å¼ï¼Œåœ¨æ­¤ä¸Šä¸‹æ–‡ä¸­ï¼Œæ‰€æœ‰åœ¨å‡½æ•°ä¸­å¯è§çš„ç¬¦å·ï¼Œåœ¨ ä¿®æ”¹å™¨ modifier ä¸­å‡å¯è§ã€‚ åœ¨ ä¿®æ”¹å™¨ modifier ä¸­å¼•å…¥çš„ç¬¦å·åœ¨å‡½æ•°ä¸­ä¸å¯è§ï¼ˆå¯èƒ½è¢«é‡è½½æ”¹å˜ï¼‰ã€‚

## ğŸ”Ÿ å…¨å±€ï¼šæ•°å­¦å’Œå¯†ç å­¦å‡½æ•°

åœ¨å…¨å±€å‘½åç©ºé—´ä¸­å·²ç»é¢„è®¾äº†ä¸€äº›ç‰¹æ®Šçš„å˜é‡å’Œå‡½æ•°ï¼Œä»–ä»¬ä¸»è¦ç”¨æ¥æä¾›å…³äºåŒºå—é“¾çš„ä¿¡æ¯æˆ–ä¸€äº›é€šç”¨çš„å·¥å…·å‡½æ•°ã€‚åç»­ä¼šè¯¦ç»†ä»‹ç»ï¼Œè¿™é‡Œç®€å•çš„ä»‹ç»å‡ ä¸ªå…¨å±€å‡½æ•°

### 1.æ•°å­¦å’Œå¯†ç å­¦å‡½æ•°

Solidity ä¹Ÿæä¾›äº†å†…ç½®çš„æ•°å­¦å’Œå¯†ç å­¦å‡½æ•°ï¼š

æ•°å­¦å‡½æ•°ï¼š

- `addmod(uint x, uint y, uint k) returns (uint)`
  - è®¡ç®— `(x + y) % k`ï¼ŒåŠ æ³•ä¼šåœ¨ä»»æ„ç²¾åº¦ä¸‹æ‰§è¡Œï¼Œå¹¶ä¸”åŠ æ³•çš„ç»“æœå³ä½¿è¶…è¿‡ `2**256` ä¹Ÿä¸ä¼šè¢«æˆªå–ã€‚ä» 0.5.0 ç‰ˆæœ¬çš„ç¼–è¯‘å™¨å¼€å§‹ä¼šåŠ å…¥å¯¹ `k != 0` çš„æ ¡éªŒï¼ˆassertï¼‰ã€‚
- `mulmod(uint x, uint y, uint k) returns (uint)`
  - è®¡ç®— `(x * y) % k`ï¼Œä¹˜æ³•ä¼šåœ¨ä»»æ„ç²¾åº¦ä¸‹æ‰§è¡Œï¼Œå¹¶ä¸”ä¹˜æ³•çš„ç»“æœå³ä½¿è¶…è¿‡ `2**256` ä¹Ÿä¸ä¼šè¢«æˆªå–ã€‚ä» 0.5.0 ç‰ˆæœ¬çš„ç¼–è¯‘å™¨å¼€å§‹ä¼šåŠ å…¥å¯¹ `k != 0` çš„æ ¡éªŒï¼ˆassertï¼‰ã€‚

å¯†ç å­¦å‡½æ•°ï¼š

- `keccak256((bytes memory) returns (bytes32)`
  - è®¡ç®— Keccak-256 å“ˆå¸Œï¼Œä¹‹å‰ keccak256 çš„åˆ«åå‡½æ•° **sha3** åœ¨ **0.5.0** ä¸­å·²ç»ç§»é™¤ã€‚ã€‚
- `sha256(bytes memory) returns (bytes32)`
  - è®¡ç®—å‚æ•°çš„ SHA-256 å“ˆå¸Œã€‚
- `ripemd160(bytes memory) returns (bytes20)`
  - è®¡ç®—å‚æ•°çš„ RIPEMD-160 å“ˆå¸Œã€‚
- `ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)`
  - åˆ©ç”¨æ¤­åœ†æ›²çº¿ç­¾åæ¢å¤ä¸å…¬é’¥ç›¸å…³çš„åœ°å€ï¼Œé”™è¯¯è¿”å›é›¶å€¼ã€‚
  - å‡½æ•°å‚æ•°å¯¹åº”äº ECDSA ç­¾åçš„å€¼:
    - r = ç­¾åçš„å‰ 32 å­—èŠ‚
    - s = ç­¾åçš„ç¬¬ 2 ä¸ª 32 å­—èŠ‚
    - v = ç­¾åçš„æœ€åä¸€ä¸ªå­—èŠ‚
  - ecrecover è¿”å›ä¸€ä¸ª address, è€Œä¸æ˜¯ address payableã€‚
  - `ecrecover` çš„[ä½¿ç”¨æ¡ˆä¾‹](https://ethereum.stackexchange.com/questions/1777/workflow-on-signing-a-string-with-private-key-followed-by-signature-verificatio)

### 2.æ•°å­¦å‡½æ•°

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    function callAddMod() public pure returns (uint256) {
        return addmod(4, 5, 3); // å¯ä»¥ç›´æ¥ä½¿ç”¨ addmod
    }

    function callMulMod() public pure returns (uint256) {
        return mulmod(4, 5, 3); // å¯ä»¥ç›´æ¥ä½¿ç”¨ mulmod
    }
}
```

### 3.å¯†ç å­¦å‡½æ•°

#### HASH çš„ç‰¹æ€§

- å¦‚æœè¾“å…¥å†…å®¹ç›¸åŒï¼Œåˆ™è¾“å‡ºå†…å®¹å¿…å®šç›¸åŒ
- è¾“å…¥å†…å®¹çš„ä»»ä½•å˜åŠ¨ï¼Œéƒ½ä¼šå¯¼è‡´è¾“å‡ºç»“æœå®Œå…¨å¤§å˜æ ·
- æ— è®ºè¾“å…¥å†…å®¹é•¿åº¦å¦‚ä½•ï¼Œè¾“å‡ºå†…å®¹é•¿åº¦å‡ä¸€æ ·
- ä¸å¯é€†
- å¾ˆéš¾è¢«ç ´è§£ï¼Œæ®è¯´ç°åœ¨å­˜åœ¨è¢«ç ´è§£çš„å¯èƒ½ï¼Œæ‰€ä»¥ä¸€èˆ¬åˆçº¦å†…é‡‡ç”¨ä¸¤æ¬¡åŠ å¯†çš„æ‰‹æ®µã€‚

#### HASH çš„åº”ç”¨

- ä¸»è¦ç”¨äºï¼šç”ŸæˆåŠ å¯†åçš„å”¯ä¸€å€¼

### å¯†ç å­¦ keccak256 å’Œ encodePacked/encode

```
keccak256((bytes memory) returns (bytes32)
```

**keccak256**: è¿”å›ç»“æœæ˜¯ bytes32

è¿™äº›ç¼–ç å‡½æ•°å¯ä»¥ç”¨æ¥æ„é€ å‡½æ•°è°ƒç”¨æ•°æ®ï¼Œè€Œä¸ç”¨å®é™…è¿›è¡Œè°ƒç”¨ã€‚æ­¤å¤–ï¼Œ`keccak256(abi.encodePacked(a, b))` æ˜¯ä¸€ç§è®¡ç®—ç»“æ„åŒ–æ•°æ®çš„å“ˆå¸Œå€¼ï¼ˆå°½ç®¡æˆ‘ä»¬ä¹Ÿåº”è¯¥å…³æ³¨åˆ°ï¼šä½¿ç”¨ä¸åŒçš„å‡½æ•°å‚æ•°ç±»å‹ä¹Ÿæœ‰å¯èƒ½ä¼šå¼•èµ·â€œå“ˆå¸Œå†²çªâ€ ï¼‰çš„æ–¹å¼ï¼Œä¸æ¨èä½¿ç”¨çš„ `keccak256(a, b)` ã€‚

- Hash ç®—æ³•åœ¨åˆçº¦å†…ä½¿ç”¨ `keccak256` è¿›è¡Œã€‚
  - `keccak256` è¿”å›å€¼æ˜¯ `bytes32` å®šé•¿æ•°æ®
- å¯ä»¥ä½¿ç”¨ `abi.encode` å’Œ `abi.encodePacked` è¿›è¡Œåˆæ­¥å¤„ç†ï¼Œç„¶åä¼ å…¥ `keccak256`
  - å¦‚æœæ˜¯å¤šä¸ªå‚æ•°ï¼Œæ¨èä½¿ç”¨ `encode`ï¼›`encodePacked` å› ä¸ºå“ˆå¸Œç¢°æ’ï¼Œå®¹æ˜“å¯¼è‡´å‚æ•°ä¸åŒï¼Œç»“æœç›¸åŒ
  - `encode` å’Œ `encodePacked` çš„è¿”å›ç»“æœæ˜¯ ä¸å®šé•¿çš„ `bytes`ç±»å‹

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    function keccak256Test() public pure returns (bytes32 result) {
        // ABC çš„ keccak256 ç»“æœæ˜¯:
        // 0xe1629b9dda060bb30c7908346f6af189c16773fa148d3366701fbaa35d54f3c8
        // keccak256 ä¹Ÿè¢«ç§°ä½œ sha3
        return keccak256("ABC");
    }
}
```

#### ä¾‹å­

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Keccake256 {
    function test1(string calldata _test1, string calldata _test2)
        external
        pure
        returns (bytes32, bytes32)
    {
        return (
            keccak256(encode(_test1, _test2)),
            keccak256(encodePacked(_test1, _test2))
        );
    }

    function encodePacked(string calldata _test1, string calldata _test2)
        public
        pure
        returns (bytes memory)
    {
        return abi.encodePacked(_test1, _test2);
    }

    function encode(string calldata _test1, string calldata _test2)
        public
        pure
        returns (bytes memory)
    {
        return abi.encode(_test1, _test2);
    }
}
```

#### æµ‹è¯•è®°å½•

```
/**
è¾“å…¥å¦‚ä¸‹å‚æ•°å’Œè¿”å›ç»“æœ
1.AA,BB
    0:bytes32: 0x1edf4aae368e845d5d1cd28aec0624c467d538ecc7e5660765ed2afedca37aca
    1:bytes32: 0xe5d11b08737f5dbf924278d835533b2b1e65c2fe1b5b119c5fdd21555547b9c4
2.AAA,BB
    0:bytes32: 0x1db58b9736b1b30323e7dee1a1d1a71e8462dbd5651f55c364c3e9b8a3b28f10
    1:bytes32: 0x741a09d43c38b2b6fc14dbc624b34865a62b9e8e13eb7a2f21263d0a1a11ed92
3.AA,ABB
    0:bytes32: 0x40e845f25226ce557aee890fbb0084f9230ca5da5064f1922a15fd3941d7d423
    1:bytes32: 0x741a09d43c38b2b6fc14dbc624b34865a62b9e8e13eb7a2f21263d0a1a11ed92

[AAA,BB] å’Œ [AA,ABB] é€šè¿‡ encodePacked å¾—åˆ°çš„ç»“æœç›¸åŒ
*/
```

#### ä¸Šé¢åˆçº¦çš„æ”¹å†™

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Keccake256 {
    function test1(string calldata _test1, string calldata _test2)
        external
        pure
        returns (bytes32, bytes32)
    {
        return (
            keccak256(encode(_test1, _test2)),
            keccak256(encodePacked(_test1, 123, _test2))
        );
    }

    function encodePacked(
        string calldata _test1,
        uint256 _x,
        string calldata _test2
    ) public pure returns (bytes memory) {
        return abi.encodePacked(_test1, _x, _test2);
    }

    function encode(string calldata _test1, string calldata _test2)
        public
        pure
        returns (bytes memory)
    {
        return abi.encode(_test1, _test2);
    }
}
```

### å¯†ç å­¦: sha256

```
sha256(bytes memory) returns (bytes32)
```

**sha256**: è¿”å›ç»“æœæ˜¯ bytes32

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    function sha256Test() public pure returns (bytes32 result) {
        // ABC çš„ sha256 ç»“æœæ˜¯:
        // 0xb5d4045c3f466fa91fe2cc6abe79232a1a57cdf104f7a26e716e0a1e2789df78
        return sha256("ABC");
    }
}
```

### å¯†ç å­¦: ripemd160

```
ripemd160(bytes memory) returns (bytes20)
```

**ripemd160**: è¿”å›ç»“æœæ˜¯ bytes20

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    function ripemd160Test() public pure returns (bytes20 result) {
        // ABC çš„ ripemd160 ç»“æœæ˜¯:
        // 0xdf62d400e51d3582d53c2d89cfeb6e10d32a3ca6
        return ripemd160("ABC");
    }
}
```

### å¯†ç å­¦: ecrecover

```
ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)
```

åˆ©ç”¨æ¤­åœ†æ›²çº¿ç­¾åæ¢å¤ä¸å…¬é’¥ç›¸å…³çš„åœ°å€ï¼Œé”™è¯¯è¿”å›é›¶å€¼ã€‚

å‡½æ•°å‚æ•°å¯¹åº”äº ECDSA ç­¾åçš„å€¼:

- r = ç­¾åçš„å‰ 32 å­—èŠ‚
- s = ç­¾åçš„ç¬¬ 2 ä¸ª 32 å­—èŠ‚
- v = ç­¾åçš„æœ€åä¸€ä¸ªå­—èŠ‚

`ecrecover` è¿”å›ä¸€ä¸ª address, è€Œä¸æ˜¯ `address payable` ã€‚ä»–ä»¬ä¹‹å‰çš„è½¬æ¢å‚è€ƒ `address payable` ï¼Œå¦‚æœéœ€è¦è½¬ç§»èµ„é‡‘åˆ°æ¢å¤çš„åœ°å€ã€‚[å‚è€ƒæ¡ˆä¾‹](https://ethereum.stackexchange.com/questions/1777/workflow-on-signing-a-string-with-private-key-followed-by-signature-verificatio)

#### æ³¨æ„

å¦‚æœä½ ä½¿ç”¨ `ecrecover` ï¼Œéœ€è¦äº†è§£ï¼Œåœ¨ä¸éœ€è¦çŸ¥é“ç›¸åº”çš„ç§é’¥ä¸‹ï¼Œç­¾åä¹Ÿå¯ä»¥è½¬æ¢ä¸ºå¦ä¸€ä¸ªæœ‰æ•ˆç­¾åï¼ˆå¯èƒ½æ˜¯å¦å¤–ä¸€ä¸ªæ•°æ®çš„ç­¾åï¼‰ã€‚åœ¨ Homestead ç¡¬åˆ†å‰ï¼Œè¿™ä¸ªé—®é¢˜å¯¹äº _transaction_ ç­¾åå·²ç»è§£å†³äº†(æŸ¥é˜… EIP-2)ã€‚ ä¸è¿‡ `ecrecover` æ²¡æœ‰æ›´æ”¹ã€‚

é™¤ééœ€è¦ç­¾åæ˜¯å”¯ä¸€çš„ï¼Œå¦åˆ™è¿™é€šå¸¸ä¸æ˜¯é—®é¢˜ï¼Œæˆ–è€…æ˜¯ç”¨å®ƒä»¬æ¥è¯†åˆ«ç‰©å“ã€‚ OpenZeppelin æœ‰ä¸€ä¸ª [ECDSA](https://docs.openzeppelin.com/contracts/2.x/api/cryptography#ECDSA) åŠ©æ‰‹åº“ ï¼Œå¯ä»¥å°†å…¶ç”¨ä½œ `ecrecover` çš„â€åŒ…è£…â€œï¼Œè€Œä¸ä¼šå‡ºç°æ­¤é—®é¢˜ã€‚

åœ¨ä¸€ä¸ªç§é“¾ä¸Šï¼Œä½ å¾ˆæœ‰å¯èƒ½ç¢°åˆ°ç”±äº sha256ã€ripemd160 æˆ–è€… ecrecover å¼•èµ·çš„ **Out-of-Gas**ã€‚è¿™ä¸ªåŸå› å°±æ˜¯ä»–ä»¬è¢«å½“åšæ‰€è°“çš„é¢„ç¼–è¯‘åˆçº¦è€Œæ‰§è¡Œï¼Œå¹¶ä¸”åœ¨ç¬¬ä¸€æ¬¡æ”¶åˆ°æ¶ˆæ¯åè¿™äº›åˆçº¦æ‰çœŸæ­£å­˜åœ¨ï¼ˆå°½ç®¡åˆçº¦ä»£ç æ˜¯ç¡¬ä»£ç ï¼‰ã€‚å‘é€åˆ°ä¸å­˜åœ¨çš„åˆçº¦çš„æ¶ˆæ¯éå¸¸æ˜‚è´µï¼Œæ‰€ä»¥å®é™…çš„æ‰§è¡Œä¼šå¯¼è‡´ Out-of-Gas é”™è¯¯ã€‚åœ¨ä½ çš„åˆçº¦ä¸­å®é™…ä½¿ç”¨å®ƒä»¬ä¹‹å‰ï¼Œç»™æ¯ä¸ªåˆçº¦å‘é€ä¸€ç‚¹å„¿ä»¥å¤ªå¸ï¼Œæ¯”å¦‚ 1 Weiã€‚è¿™åœ¨å®˜æ–¹ç½‘ç»œæˆ–æµ‹è¯•ç½‘ç»œä¸Šä¸æ˜¯é—®é¢˜ã€‚

**ecrecover**:

è¿™ä¸ªæ¯”è¾ƒå¤æ‚ï¼Œè¯·åœ¨ä¸‹é¢çš„ **é€šè¿‡æ™ºèƒ½åˆçº¦éªŒè¯ç­¾å** ä¾‹å­è¯¦ç»†æŸ¥çœ‹ï¼›

### æ¡ˆä¾‹ 1:é€šè¿‡æ™ºèƒ½åˆçº¦éªŒè¯ç­¾å

#### æœ¬æ¡ˆä¾‹çš„å…³é”®å­—

- `keccak256`
- `abi.encodePacked`
- `ecrecover()`
- `assembly`
  - `mload`
  - `add`

#### æ¡ˆä¾‹è§£æ

åšä¸€ä¸ª DEMOï¼šé“¾ä¸Šå¯¹ä»»æ„æ¶ˆæ¯è¿›è¡ŒåŠ å¯†ï¼ŒåŠ å¯†æ¶ˆæ¯åœ¨é“¾ä¸‹ä½¿ç”¨ç§é’¥å†æ¬¡åŠ å¯†ï¼Œç„¶åå¯¹å†æ¬¡åŠ å¯†çš„ä¿¡æ¯è¿›è¡Œæ ¡éªŒã€‚

1. è·å–æ¶ˆæ¯çš„ Hash å€¼
   - `hash = msgHash(_message);`
2. åœ¨ã€é“¾ä¸‹ã€‘å°† hash ä½¿ç”¨ MetaMask è¿›è¡Œç§é’¥ç­¾å;
   - `_signature = metaMaskSignHash(hash,addressPrivateKey)`
   - è¿™é‡Œç›¸å½“äºåœ¨ Metamask å¯¹ hash åšç¬¬äºŒæ¬¡çš„ **keccak256 Hash** è½¬æ¢ï¼Œè½¬æ¢æ—¶æ·»åŠ äº†`"\x19Ethereum Signed Message:\n32"`
3. ä½¿ç”¨ `ecrecover` æ–¹æ³•æ¢å¤ç­¾ååœ°å€
   - `ecrecoverAddress = recoverAds(hash,_signature)`
   - è¿™é‡Œå¯ä»¥æ¢å¤ MetaMask ç­¾åæ—¶å€™ä½¿ç”¨çš„åœ°å€
4. æ ¡éªŒç­¾åç»“æœæ˜¯å¦æ­£ç¡®
   ecrecoverAddress == addressPublicKey ? "éªŒè¯æˆåŠŸ" : "éªŒè¯å¤±è´¥";

#### ä»£ç å¦‚ä¸‹

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract VerifySig {
    /**
    åŠŸèƒ½:æ ¡éªŒç­¾åç»“æœæ˜¯å¦æ­£ç¡®
    æ³¨æ„ _signature æ˜¯ bytes ç±»å‹çš„
     */
    function verify(
        address addressPublicKey,
        string calldata _message,
        bytes calldata _signature
    ) external pure returns (bool) {
        bytes32 hash = msgHash(_message);
        // bytes32 _signature = metaMaskSignHash(hash,addressPrivateKey); // è¿™æ˜¯åœ¨é“¾ä¸‹æ“ä½œ
        address ecrecoverAddress = recoverAds(hash, _signature);
        return ecrecoverAddress == addressPublicKey;
    }

    function msgHash(string calldata _message)
        public
        pure
        returns (bytes32 keccakFirst)
    {
        keccakFirst = keccak256(abi.encodePacked(_message));
    }

    function msgHash2(bytes32 _msgHash)
        internal
        pure
        returns (bytes32 keccakSecond)
    {
        // ä¸¤æ¬¡2æ¬¡ç­¾åï¼Œæ®è¯´æ˜¯æ•°å­¦å±‚é¢ä¸Š1æ¬¡ç­¾åæœ‰è¢«ç ´è§£çš„å¯èƒ½ã€‚[æˆ‘æ²¡æœ‰äº²è‡ªéªŒè¯è¿‡]
        keccakSecond = keccak256(
            abi.encodePacked("\x19Ethereum Signed Message:\n32", _msgHash)
        );
    }

    function recoverAds(bytes32 _msgHash, bytes calldata _signature)
        public
        pure
        returns (address)
    {
        // metamsk ç­¾åä¼šåœ¨åŸæœ‰æ¶ˆæ¯ä¸Šæ·»åŠ   "\x19Ethereum Signed Message:\n32"ï¼Œæ‰€ä»¥éœ€è¦å¤„ç†ä¸€ä¸‹
        bytes32 metamaskInputHash = msgHash2(_msgHash);
        // rä¸ºç‚¹çš„xåæ ‡ï¼Œsä¸ºç‚¹çš„yåæ ‡ï¼Œvæ˜¯åæ ‡çš„å¥‡å¶æ£€éªŒæ ‡è¯†ç¬¦
        // væ˜¯ç”¨äºè¯´æ˜é‚£ä¸ªç‚¹æ‰æ˜¯çœŸæ­£ç¬¦åˆç»“æœçš„ç‚¹
        // https://www.cnblogs.com/wanghui-garcia/p/9662140.html
        // https://www.jianshu.com/p/090f605f1842/
        (bytes32 r, bytes32 s, uint8 v) = _split(_signature);

        address ecrecoverAddress = ecrecover(metamaskInputHash, v, r, s);
        return ecrecoverAddress;
    }

    function _split(bytes memory _signature)
        internal
        pure
        returns (
            bytes32 r,
            bytes32 s,
            uint8 v
        )
    {
        // éœ€è¦å†…è”æ±‡ç¼–è¿›è¡Œåˆ†å‰²ï¼Œåˆçº¦æ²¡æœ‰åˆ«çš„æ–¹æ³•
        require(_signature.length == 65, "invalid signature length");
        assembly {
            r := mload(add(_signature, 32))
            s := mload(add(_signature, 64))
            // v := mload(add(_signature, 96))
            // å› ä¸º v ä¸æ˜¯ bytes32ï¼Œæ˜¯ uint8æ•°å­—ï¼Œuint8æ•°å­—åªå 1ä½ï¼Œæ‰€ä»¥ä½¿ç”¨ byte(0)è½¬æ¢
            v := byte(0, mload(add(_signature, 96)))
        }
    }
}
```

#### é“¾ä¸‹ç­¾åå’Œ Remix éªŒè¯

ä½¿ç”¨æµè§ˆå™¨æ§åˆ¶å°è¿›è¡Œç­¾åï¼Œéœ€è¦å®‰è£… MateMask

```
// 1.æ‰“å¼€ ethereum
ethereum.enable()

// 2.èµ‹å€¼åœ°å€ã€‚è¿™é‡Œçš„åœ°å€æ˜¯ MateMask çš„é»˜è®¤åœ°å€
const address = "0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac";

// 3.èµ‹å€¼Hashã€‚ ä½¿ç”¨ msgHash1 æ–¹æ³•ï¼Œè¾“å…¥ "ABC" è·å–åˆ°çš„ç»“æœ
const hash = "0xe1629b9dda060bb30c7908346f6af189c16773fa148d3366701fbaa35d54f3c8"

// 4. å‘¼èµ· MataMask ç­¾å
ethereum.request({method:"personal_sign",params:[address,hash]});

// 5. æ‰“å¼€è¿”å›çš„ PromiseÂ {<pending>}ï¼Œæ‹·è´ PromiseResult å€¼
0x66029be70a055a4abc293072c76550ffaecb2adb9fc3be2366d78bc498e008d06b6ddbfef97392a27a58737c33b059e09bb069261bdc41f9f0d8d1bc6e0b7ae31c

// 6. åœ¨ recoverAds ä¸­éªŒè¯æ¢å¤çš„åœ°å€æ˜¯å¦ä¸ºç­¾ååœ°å€ã€‚
ä¸Šé¢çš„ PromiseResult å€¼æ˜¯ _signature
ä¸Šé¢çš„ hash å€¼æ˜¯ _msgHash

// 7. åœ¨ verify ä¸­å†æ¬¡æ ¡éªŒ

```

æ‰©å±•é˜…è¯»: åœ¨çº¿è¿›è¡Œç­¾åçš„ç½‘ç«™: https://metamask.github.io/test-dapp/

## 1ï¸âƒ£ å…¨å±€ï¼šABI ç¼–ç åŠè§£ç å‡½æ•°

ABI å…¨å Application Binary Interfaceã€‚ABI ç”¨äºåº•å±‚è°ƒç”¨çš„è¾…åŠ©ä½¿ç”¨ï¼›åœ¨åˆçº¦è°ƒç”¨åˆçº¦çš„æ—¶å€™ä½¿ç”¨ï¼Œå¯ä»¥ä¸çŸ¥é“å¯¹æ–¹çš„åˆçº¦æºç ï¼Œåªéœ€è¦çŸ¥é“é“¾ä¸Šé€»è¾‘å³å¯ã€‚

- ABI ç¼–ç 

  - `abi.encode(...) returns (bytes)`ï¼š :ref:`ABI <ABI>` - å¯¹ç»™å®šå‚æ•°è¿›è¡Œç¼–ç 
  - `abi.encodePacked(...) returns (bytes)`ï¼šå¯¹ç»™å®šå‚æ•°æ‰§è¡Œ :ref:`ç´§æ‰“åŒ…ç¼–ç  <abi_packed_mode>` ï¼Œæ³¨æ„ï¼Œå¯ä»¥ä¸æ˜ç¡®æ‰“åŒ…ç¼–ç ã€‚
  - `abi.encodeWithSelector(bytes4 selector, ...) returns (bytes)`ï¼š :ref:`ABI <ABI>` - å¯¹ç»™å®šç¬¬äºŒä¸ªå¼€å§‹çš„å‚æ•°è¿›è¡Œç¼–ç ï¼Œå¹¶ä»¥ç»™å®šçš„å‡½æ•°é€‰æ‹©å™¨ä½œä¸ºèµ·å§‹çš„ 4 å­—èŠ‚æ•°æ®ä¸€èµ·è¿”å›
  - `abi.encodeWithSignature(string signature, ...) returns (bytes)`ï¼šç­‰ä»·äº `abi.encodeWithSelector(bytes4(keccak256(signature), ...)`
  - `abi.encodeCall(function functionPointer, (...)) returns (bytes memory)`: ä½¿ç”¨ tuple ç±»å‹å‚æ•° ABI ç¼–ç è°ƒç”¨ `functionPointer` ã€‚æ‰§è¡Œå®Œæ•´çš„ç±»å‹æ£€æŸ¥, ç¡®ä¿ç±»å‹åŒ¹é…å‡½æ•°ç­¾åã€‚ç»“æœå’Œ `abi.encodeWithSelector(functionPointer.selector, (...))` ä¸€è‡´ã€‚

- ABI è§£ç 

  - `abi.decode(bytes memory encodedData, (...)) returns (...)`: å¯¹ç»™å®šçš„æ•°æ®è¿›è¡Œ ABI è§£ç ï¼Œè€Œæ•°æ®çš„ç±»å‹åœ¨æ‹¬å·ä¸­ç¬¬äºŒä¸ªå‚æ•°ç»™å‡º ã€‚ ä¾‹å¦‚: `(uint a, uint[2] memory b, bytes memory c) = abi.decode(data, (uint, uint[2], bytes))`

### encode

- `encode` ä¼šè¡¥é›¶

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract AbiDecode {
    function encode(string memory a, string memory b)
        external
        pure
        returns (bytes memory)
    {
        return abi.encode(a, b);
    }
}
```

```
/**
/**
è¾“å…¥å¦‚ä¸‹å‚æ•°å’Œè¿”å›ç»“æœ
1.AA,BB
    0x
    0000000000000000000000000000000000000000000000000000000000000040
    0000000000000000000000000000000000000000000000000000000000000080
    0000000000000000000000000000000000000000000000000000000000000002
    4141000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000002
    4242000000000000000000000000000000000000000000000000000000000000
2.AAA,BB
    0x
    0000000000000000000000000000000000000000000000000000000000000040
    0000000000000000000000000000000000000000000000000000000000000080
    0000000000000000000000000000000000000000000000000000000000000003
    4141410000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000002
    4242000000000000000000000000000000000000000000000000000000000000
3.AA,ABB
    0x
    0000000000000000000000000000000000000000000000000000000000000040
    0000000000000000000000000000000000000000000000000000000000000080
    0000000000000000000000000000000000000000000000000000000000000002
    4141000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000003
    4142420000000000000000000000000000000000000000000000000000000000
*/
*/
```

### encodePacked

- `encodePacked` ä¸ä¼šè¡¥é›¶
  - ä¸è¡¥é›¶ï¼Œå®¹æ˜“å¯¼è‡´ç¢°æ’é”™è¯¯ã€‚ï¼ˆä¸¤ä¸ªå‚æ•°æ‹¼åœ¨ä¸€èµ·ï¼Œå¯¼è‡´å‚æ•°ä¸åŒï¼Œç»“æœç›¸åŒï¼‰

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract AbiDecode {
    function encodePacked(string memory a, string memory b)
        external
        pure
        returns (bytes memory)
    {
        return abi.encodePacked(a, b);
    }
}
```

```
/**
è¾“å…¥å¦‚ä¸‹å‚æ•°å’Œè¿”å›ç»“æœ
1.AA,BB
    0x41414242
2.AAA,BB
    0x4141414242
3.AA,ABB
    0x4141414242
[AAA,BB] å’Œ [AA,ABB] å¾—åˆ°çš„ç»“æœç›¸åŒ
*/
```

#### è§£å†³ `encodePacked` çš„å“ˆå¸Œç¢°æ’é—®é¢˜

å¯ä»¥åœ¨è¦ç¼–ç çš„æ•°æ®ä¸­é—´åŠ ä¸€ä¸ªå›ºå®šçš„å€¼ï¼Œå¦‚æœ

**ä»£ç å¦‚ä¸‹:**

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract AbiDecode {
    function encodePacked(string calldata _test1, string calldata _test2)
        public
        pure
        returns (bytes memory)
    {
        uint256 x = 123;
        return abi.encodePacked(_test1, x, _test2);
    }
}
```

**ç»“æœå¦‚ä¸‹:**

```
/**
è¾“å…¥å¦‚ä¸‹å‚æ•°å’Œè¿”å›ç»“æœ
1.AA,BB
    0x4141000000000000000000000000000000000000000000000000000000000000007b4242
2.AAA,BB
    0x414141000000000000000000000000000000000000000000000000000000000000007b4242
3.AA,ABB
    0x4141000000000000000000000000000000000000000000000000000000000000007b414242
[AAA,BB] å’Œ [AA,ABB] å› ä¸ºé—´éš”äº†æ•°æ®ï¼Œæ‰€ä»¥å¾—åˆ°çš„ç»“æœä¸ç›¸åŒ
*/
```

#### æ³¨æ„

è¿™äº›ç¼–ç å‡½æ•°å¯ä»¥ç”¨æ¥æ„é€ å‡½æ•°è°ƒç”¨æ•°æ®ï¼Œè€Œä¸ç”¨å®é™…è¿›è¡Œè°ƒç”¨ã€‚æ­¤å¤–ï¼Œ`keccak256(abi.encodePacked(a, b))` æ˜¯ä¸€ç§è®¡ç®—ç»“æ„åŒ–æ•°æ®çš„å“ˆå¸Œå€¼ï¼ˆå°½ç®¡æˆ‘ä»¬ä¹Ÿåº”è¯¥å…³æ³¨åˆ°ï¼šä½¿ç”¨ä¸åŒçš„å‡½æ•°å‚æ•°ç±»å‹ä¹Ÿæœ‰å¯èƒ½ä¼šå¼•èµ·â€œå“ˆå¸Œå†²çªâ€ ï¼‰çš„æ–¹å¼ï¼Œä¸æ¨èä½¿ç”¨çš„ `keccak256(a, b)` ã€‚

### decode

#### ä¾‹å­ 1

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract AbiDecode {
    struct MyStruct {
        string name;
        uint256[2] nums;
    }

    function encode(
        uint256 x,
        address addr,
        uint256[] calldata arr,
        MyStruct calldata myStruct
    ) external pure returns (bytes memory) {
        return abi.encode(x, addr, arr, myStruct);
    }

    function decode(bytes calldata data)
        external
        pure
        returns (
            uint256 x,
            address addr,
            uint256[] memory arr,
            MyStruct memory myStruct
        )
    {
        (x, addr, arr, myStruct) = abi.decode(
            data,
            (uint256, address, uint256[], MyStruct)
        );
    }
}
```

**åˆçº¦æµ‹è¯•**

- éƒ¨ç½²
- `encode`
  - å‚æ•°å¦‚ä¸‹:
  - `1`
  - `0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac`
  - `[1,2,3]`
  - `["Anbang",[2,3]]`
- å¾—åˆ°çš„ç»“æœï¼Œè¿›è¡Œ `decode`

### abi.encodeWithSelector

è¿™æ˜¯è·å–å‡½æ•°ç­¾åä½¿ç”¨çš„ï¼Œç¬¬ä¸€ä¸ªå‚æ•°ä¸ºå‡½æ•°é€‰æ‹©ï¼Œå¦‚ä¸‹æ˜¯ç¬¬äºŒç« åœ¨ä»‹ç»åœ°å€ç±»å‹çš„æ—¶å€™ï¼Œstaticcall é™æ€è°ƒç”¨ ç”¨æ³•çš„å‚æ•°ï¼Œéœ€è¦ç”± `abi.encodeWithSelector` è®¡ç®—å‡ºæ¥ã€‚å‡½æ•°çš„å‚æ•°æŒ‰ç…§é¡ºåºå†™åœ¨å‡½æ•°åä¹‹åå³å¯ã€‚

```

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

// è¢«è°ƒç”¨çš„åˆçº¦
contract Hello {
    function echo() external pure returns (string memory) {
        return "Hello World!";
    }
}

// è°ƒç”¨è€…åˆçº¦
contract SoldityTest {
    function callHello(address _ads) external view returns (string memory) {
        // ç¼–ç è¢«è°ƒç”¨è€…çš„æ–¹æ³•ç­¾å
        bytes4 methodId = bytes4(keccak256("echo()"));

        // è°ƒç”¨åˆçº¦
        (bool success, bytes memory data) = _ads.staticcall(
            abi.encodeWithSelector(methodId)
        );
        if (success) {
            return abi.decode(data, (string));
        } else {
            return "error";
        }
    }
}
```

### abi.encodeWithSignature

è¿™æ˜¯è·å–å‡½æ•°ç­¾åä½¿ç”¨çš„ï¼Œç¬¬ä¸€ä¸ªå‚æ•°ä¸ºå‡½æ•°çš„åå­—å’Œå‚æ•°ç±»å‹ï¼Œå¦‚ä¸‹æ˜¯ç¬¬äºŒç« åœ¨ä»‹ç» [åœ°å€ç±»å‹çš„æ—¶å€™ï¼Œcall ç”¨æ³•çš„å‚æ•°](/source/02.type-of-data.html#call)ï¼Œéœ€è¦ç”± `abi.encodeWithSignature` è®¡ç®—å‡ºæ¥ã€‚å‡½æ•°çš„å‚æ•°æŒ‰ç…§é¡ºåºå†™åœ¨å‡½æ•°åä¹‹åå³å¯ã€‚

```
function call_Test1_setNameAndAge(
    address _ads,
    string memory _name,
    uint256 _age
) external payable {
    bytes memory data = abi.encodeWithSignature(
        "setNameAndAge(string,uint256)",
        _name,
        _age
    );
    (bool success, bytes memory _bys) = _ads.call{value: msg.value}(data);
    require(success, "Call Failed");
    bys = _bys;
}
```

### abi.encodeCall

## 2ï¸âƒ£ è¡¥å……:å‡½æ•°èµ‹å€¼ç»™å˜é‡ & å‡½æ•°ä½œä¸ºå‚æ•° & å‡½æ•°ä¸­è¿”å›å‡½æ•°

å¯ä»¥å°†ä¸€ä¸ªå‡½æ•°èµ‹å€¼ç»™å¦ä¸€ä¸ªå‡½æ•°ç±»å‹çš„å˜é‡ï¼Œä¹Ÿå¯ä»¥å°†ä¸€ä¸ªå‡½æ•°ä½œä¸ºå‚æ•°è¿›è¡Œä¼ é€’ï¼Œè¿˜èƒ½åœ¨å‡½æ•°è°ƒç”¨ä¸­è¿”å›å‡½æ•°ç±»å‹å˜é‡ã€‚

- å¯ä»¥å°†ä¸€ä¸ªå‡½æ•°èµ‹å€¼ç»™ä¸€ä¸ªå˜é‡ï¼Œä¸€ä¸ªå‡½æ•°ç±»å‹çš„å˜é‡ã€‚
- è¿˜å¯ä»¥å°†ä¸€ä¸ªå‡½æ•°ä½œä¸ºå‚æ•°è¿›è¡Œä¼ é€’ã€‚
- ä¹Ÿå¯ä»¥åœ¨å‡½æ•°è°ƒç”¨ä¸­è¿”å›ä¸€ä¸ªå‡½æ•°ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract FnTest1 {
    function internalFunc() internal pure returns (uint256) {
        return 1;
    }

    function externalFunc() external pure returns (uint256) {
        return 2;
    }

    function callFunc() public view returns (uint256, uint256) {
        //ç›´æ¥ä½¿ç”¨å†…éƒ¨çš„æ–¹å¼è°ƒç”¨
        uint256 a = internalFunc();

        //ä¸èƒ½åœ¨å†…éƒ¨è°ƒç”¨ä¸€ä¸ªå¤–éƒ¨å‡½æ•°ï¼Œä¼šæŠ¥ç¼–è¯‘é”™è¯¯ã€‚
        // externalFunc();
        //ä½¿ç”¨`this`ä»¥`external`çš„æ–¹å¼è°ƒç”¨ä¸€ä¸ªå¤–éƒ¨å‡½æ•°
        uint256 b = this.externalFunc();

        //ä¸èƒ½é€šè¿‡`external`çš„æ–¹å¼è°ƒç”¨ä¸€ä¸ª`internal`
        //this.internalFunc();

        return (a, b);
    }
}

contract FnTest2 {
    function externalCall(FnTest1 ft) public pure returns (uint256) {
        //è°ƒç”¨å¦ä¸€ä¸ªåˆçº¦çš„å¤–éƒ¨å‡½æ•°
        uint256 a = ft.externalFunc();

        //ä¸èƒ½è°ƒç”¨å¦ä¸€ä¸ªåˆçº¦çš„å†…éƒ¨å‡½æ•°
        //ft.internalFunc();

        return a;
    }
}
```

### å…·åè°ƒç”¨å’ŒåŒ¿åå‡½æ•°å‚æ•°

å‡½æ•°è°ƒç”¨å‚æ•°ä¹Ÿå¯ä»¥æŒ‰ç…§ä»»æ„é¡ºåºç”±åç§°ç»™å‡ºï¼Œå¦‚æœå®ƒä»¬è¢«åŒ…å«åœ¨ `{ }` ä¸­ï¼Œ å¦‚ä»¥ä¸‹ç¤ºä¾‹ä¸­æ‰€ç¤ºã€‚å‚æ•°åˆ—è¡¨å¿…é¡»æŒ‰åç§°ä¸å‡½æ•°å£°æ˜ä¸­çš„å‚æ•°åˆ—è¡¨ç›¸ç¬¦ï¼Œä½†å¯ä»¥æŒ‰ä»»æ„é¡ºåºæ’åˆ—ã€‚

```
pragma solidity >=0.4.0 <0.9.0;

contract C {
    mapping(uint => uint) data;

    function f() public {
        set({value: 2, key: 3});
    }

    function set(uint key, uint value) public {
        data[key] = value;
    }

}
```

### çœç•¥å‡½æ•°å‚æ•°åç§°

æœªä½¿ç”¨å‚æ•°çš„åç§°ï¼ˆç‰¹åˆ«æ˜¯è¿”å›å‚æ•°ï¼‰å¯ä»¥çœç•¥ã€‚è¿™äº›å‚æ•°ä»ç„¶å­˜åœ¨äºå †æ ˆä¸­ï¼Œä½†å®ƒä»¬æ— æ³•è®¿é—®ã€‚

```
pragma solidity >=0.4.22 <0.9.0;

contract C {
    // çœç•¥å‚æ•°åç§°
    function func(uint k, uint) public pure returns(uint) {
        return k;
    }
}
```

### è°ƒç”¨å¼‚å¸¸

å¦‚æœå½“å‡½æ•°ç±»å‹çš„**å˜é‡**è¿˜æ²¡æœ‰åˆå§‹åŒ–æ—¶å°±è°ƒç”¨å®ƒçš„è¯ä¼šå¼•å‘ä¸€ä¸ª `Panic` å¼‚å¸¸ã€‚ å¦‚æœåœ¨ä¸€ä¸ªå‡½æ•°è¢« `delete` ä¹‹åè°ƒç”¨å®ƒä¹Ÿä¼šå‘ç”Ÿç›¸åŒçš„æƒ…å†µã€‚

### å¤–éƒ¨å‡½æ•°ç±»å‹åœ¨ Solidity çš„ä¸Šä¸‹æ–‡ç¯å¢ƒä»¥å¤–çš„åœ°æ–¹ä½¿ç”¨

å¦‚æœå¤–éƒ¨å‡½æ•°ç±»å‹åœ¨ Solidity çš„ä¸Šä¸‹æ–‡ç¯å¢ƒä»¥å¤–çš„åœ°æ–¹ä½¿ç”¨ï¼Œå®ƒä»¬ä¼šè¢«è§†ä¸º `function` ç±»å‹ã€‚ è¯¥ç±»å‹å°†å‡½æ•°åœ°å€ç´§è·Ÿå…¶å‡½æ•°æ ‡è¯†ä¸€èµ·ç¼–ç ä¸ºä¸€ä¸ª bytes24 ç±»å‹ã€‚ã€‚

## ğŸ†— å®æˆ˜åº”ç”¨

### æƒé™æ§åˆ¶åˆçº¦

æƒé™æ§åˆ¶çš„æ ¸å¿ƒæ˜¯: `mapping`

- é»˜è®¤ç»™éƒ¨ç½²è€…èµ‹ `ADMIN` æƒé™
- ADMIN å’Œ USER ä½¿ç”¨ bytes32ï¼Œå¹¶ä¸” private
- åªæœ‰ ADMIN æƒé™æ‰å¯ä»¥æ·»åŠ å’Œæ’¤é”€æƒé™

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract AccessControl {
    // çŠ¶æ€å˜é‡
    mapping(bytes32 => mapping(address => bool)) public roles;
    // ADMIN å’Œ private æ˜¯ç§æœ‰å˜é‡ï¼Œå¯ä»¥å…ˆæ”¹ä¸º public;è·å–åˆ°å€¼åï¼Œå†æ”¹ä¸º private
    // 0xdf8b4c520ffe197c5343c6f5aec59570151ef9a492f2c624fd45ddde6135ec42
    bytes32 private constant ADMIN = keccak256(abi.encodePacked("ADMIN"));
    // 0x2db9fd3d099848027c2383d0a083396f6c41510d7acfd92adc99b6cffcf31e96
    bytes32 private constant USER = keccak256(abi.encodePacked("USER"));

    // äº‹ä»¶
    event GrantRole(address indexed ads, bytes32 indexed role);
    event RevokeRole(address indexed ads, bytes32 indexed role);

    // å‡½æ•°ä¿®æ”¹å™¨
    modifier onlyRole(bytes32 _role) {
        require(roles[_role][msg.sender], "Not Authorized");
        _;
    }

    // æ„é€ å‡½æ•°
    constructor() {
        _grantRole(msg.sender, ADMIN);
    }

    // å‡½æ•°
    function _grantRole(address _ads, bytes32 _role) internal {
        roles[_role][_ads] = true;
        emit GrantRole(_ads, _role);
    }

    function grantRole(address _ads, bytes32 _role) external onlyRole(ADMIN) {
        _grantRole(_ads, _role);
    }

    function revokeRole(address _ads, bytes32 _role) external onlyRole(ADMIN) {
        roles[_role][_ads] = false;
        emit RevokeRole(_ads, _role);
    }
}
```

## #ï¸âƒ£ é—®ç­”é¢˜

- å¦‚ä¸‹åˆçº¦ä¸­ï¼Œtest è¿”å›ä»€ä¹ˆ?

  ```
  // SPDX-License-Identifier: MIT
  pragma solidity ^0.8.17;

  contract Demo {
      //å½“ç»™è¿”å›å€¼èµ‹å€¼åï¼Œå¹¶ä¸”æœ‰ä¸ªreturnï¼Œä»¥æœ€åçš„returnä¸ºä¸»
      function test() public pure returns (uint256 mul) {
          uint256 a = 10;
          mul = 100;
          return a;
      }
  }
  ```

- å‡½æ•°å‚æ•°ä½¿ç”¨æ—¶å€™æœ‰å“ªäº›éœ€è¦æ³¨æ„çš„ï¼Ÿ
  - å¼•ç”¨ç±»å‹éœ€è¦`memory`/`calldata`
  - å‡½æ•°å‚æ•°å¯ä»¥å½“ä½œä¸ºæœ¬åœ°å˜é‡ï¼Œä¹Ÿå¯ç”¨åœ¨ç­‰å·å·¦è¾¹è¢«èµ‹å€¼ã€‚
  - å¤–éƒ¨å‡½æ•°ä¸æ”¯æŒå¤šç»´æ•°ç»„ï¼Œå¦‚æœåŸæ–‡ä»¶åŠ å…¥ p`ragma abicoder v2;` å¯ä»¥å¯ç”¨ ABI v2 ç‰ˆç¼–ç åŠŸèƒ½ï¼Œè¿™æ­¤åŠŸèƒ½å¯ç”¨ã€‚
- åˆ›å»ºä¸€ä¸ª `Utils` åˆçº¦ï¼Œå…¶ä¸­æœ‰ `sum` æ–¹æ³•ï¼Œä¼ å…¥ä»»æ„æ•°é‡çš„æ•°ç»„ï¼Œéƒ½å¯ä»¥è®¡ç®—å‡ºæ±‚å’Œç»“æœã€‚
- å‡½æ•°æ—¢å¯ä»¥å®šä¹‰åœ¨åˆçº¦å†…éƒ¨ï¼Œä¹Ÿå¯ä»¥å®šä¹‰åœ¨åˆçº¦å¤–éƒ¨ï¼Œä¸¤ç§æ–¹å¼çš„åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿ
  - åˆçº¦ä¹‹å¤–çš„å‡½æ•°ï¼ˆä¹Ÿç§°ä¸ºâ€œè‡ªç”±å‡½æ•°â€ï¼‰å§‹ç»ˆå…·æœ‰éšå¼çš„ `internal` å¯è§æ€§ã€‚ å®ƒä»¬çš„ä»£ç åŒ…å«åœ¨æ‰€æœ‰è°ƒç”¨å®ƒä»¬åˆçº¦ä¸­ï¼Œç±»ä¼¼äºå†…éƒ¨åº“å‡½æ•°ã€‚
  - åœ¨åˆçº¦ä¹‹å¤–å®šä¹‰çš„å‡½æ•°ä»ç„¶åœ¨åˆçº¦çš„ä¸Šä¸‹æ–‡å†…æ‰§è¡Œã€‚ä»–ä»¬ä»ç„¶å¯ä»¥è®¿é—®å˜é‡ `this` ï¼Œä¹Ÿå¯ä»¥è°ƒç”¨å…¶ä»–åˆçº¦ï¼Œå°†å…¶å‘é€ä»¥å¤ªå¸æˆ–é”€æ¯è°ƒç”¨å®ƒä»¬åˆçº¦ç­‰å…¶ä»–äº‹æƒ…ã€‚ä¸åœ¨åˆçº¦ä¸­å®šä¹‰çš„å‡½æ•°çš„ä¸»è¦åŒºåˆ«ä¸ºï¼šè‡ªç”±å‡½æ•°ä¸èƒ½ç›´æ¥è®¿é—®å­˜å‚¨å˜é‡å’Œä¸åœ¨ä»–ä»¬çš„ä½œç”¨åŸŸèŒƒå›´å†…å‡½æ•°ã€‚
- å‡½æ•°çš„æ„é€ å‡½æ•°æœ‰ä»€ä¹ˆç‰¹ç‚¹ï¼Ÿ
  - å®ƒä»…èƒ½åœ¨æ™ºèƒ½åˆçº¦éƒ¨ç½²çš„æ—¶å€™è°ƒç”¨ä¸€æ¬¡ï¼Œåˆ›å»ºä¹‹åå°±ä¸èƒ½å†æ¬¡è¢«è°ƒç”¨ã€‚
  - æ„é€ å‡½æ•°æ˜¯å¯é€‰çš„ï¼Œåªå…è®¸æœ‰ä¸€ä¸ªæ„é€ å‡½æ•°ï¼Œè¿™æ„å‘³ç€ä¸æ”¯æŒé‡è½½ã€‚ï¼ˆæ™®é€šå‡½æ•°æ”¯æŒé‡è½½ï¼‰
  - ï¼šåœ¨åˆçº¦åˆ›å»ºçš„è¿‡ç¨‹ä¸­ï¼Œå®ƒçš„ä»£ç è¿˜æ˜¯ç©ºçš„ï¼Œæ‰€ä»¥ç›´åˆ°æ„é€ å‡½æ•°æ‰§è¡Œç»“æŸï¼Œæˆ‘ä»¬éƒ½ä¸åº”è¯¥åœ¨å…¶ä¸­è°ƒç”¨åˆçº¦è‡ªå·±çš„å‡½æ•°ã€‚(å¯ä»¥ç›´æ¥å†™å‡½æ•°åè°ƒç”¨ï¼Œä½†æ˜¯ä¸æ¨èè°ƒç”¨ï¼Œä¸å¯ä»¥é€šè¿‡ this æ¥è°ƒç”¨å‡½æ•°ï¼Œå› ä¸ºæ­¤æ—¶çœŸå®çš„åˆçº¦å®ä¾‹è¿˜æ²¡æœ‰è¢«åˆ›å»ºã€‚)
- æ„é€ å‡½æ•°æœ‰å“ªäº›ç”¨é€”ï¼Ÿ
  - ç”¨æ¥è®¾ç½®ç®¡ç†è´¦å·ï¼ŒToken ä¿¡æ¯ç­‰å¯ä»¥è‡ªå®šä¹‰ï¼Œå¹¶ä¸”ä»¥åæ°¸è¿œä¸éœ€è¦ä¿®æ”¹çš„æ•°æ®ã€‚
  - å¯ä»¥ç”¨æ¥åšåˆè¯†çš„æƒé™è®¾ç½®ï¼Œé¿å…åç»­æ²¡åŠæ³• owner/admin åœ°å€ã€‚
- åˆçº¦å†…è°ƒç”¨å¤–éƒ¨æœ‰å“ªäº›ï¼Ÿ
  - ä¹Ÿå¯ä»¥ä½¿ç”¨è¡¨è¾¾å¼ `this.g(8)`; å’Œ `c.g(2)`; è¿›è¡Œè°ƒç”¨ï¼Œå…¶ä¸­ c æ˜¯åˆçº¦å®ä¾‹ï¼Œ g åˆçº¦å†…å®ç°çš„å‡½æ•°ï¼Œè¿™ä¸¤ç§æ–¹å¼è°ƒç”¨å‡½æ•°ï¼Œç§°ä¸ºâ€œå¤–éƒ¨è°ƒç”¨â€ï¼Œå®ƒæ˜¯é€šè¿‡æ¶ˆæ¯è°ƒç”¨æ¥è¿›è¡Œï¼Œè€Œä¸æ˜¯ç›´æ¥çš„ä»£ç è·³è½¬ã€‚è¯·æ³¨æ„ï¼Œä¸å¯ä»¥åœ¨æ„é€ å‡½æ•°ä¸­é€šè¿‡ `this` æ¥è°ƒç”¨å‡½æ•°ï¼Œå› ä¸ºæ­¤æ—¶çœŸå®çš„åˆçº¦å®ä¾‹è¿˜æ²¡æœ‰è¢«åˆ›å»ºã€‚
- ä»ä¸€ä¸ªåˆçº¦åˆ°å¦ä¸€ä¸ªåˆçº¦çš„å‡½æ•°è°ƒç”¨ä¼šåˆ›å»ºäº¤æ˜“ä¹ˆï¼Ÿ
  - ä»ä¸€ä¸ªåˆçº¦åˆ°å¦ä¸€ä¸ªåˆçº¦çš„å‡½æ•°è°ƒç”¨ä¸ä¼šåˆ›å»ºè‡ªå·±çš„äº¤æ˜“, å®ƒæ˜¯ä½œä¸ºæ•´ä¸ªäº¤æ˜“çš„ä¸€éƒ¨åˆ†çš„æ¶ˆæ¯è°ƒç”¨ã€‚
- è°ƒç”¨å‡½æ•°å¹¶è½¬å¸å¦‚ä½•å®ç°
  - `feed.info{value: 10, gas: 800}(2);`
  - æ³¨æ„ `feed.info{value: 10, gas: 800}` ä»…ï¼ˆå±€éƒ¨åœ°ï¼‰è®¾ç½®äº†ä¸å‡½æ•°è°ƒç”¨ä¸€èµ·å‘é€çš„ Wei å€¼å’Œ gas çš„æ•°é‡ï¼Œåªæœ‰æœ€åçš„å°æ‹¬å·æ‰æ‰§è¡Œäº†çœŸæ­£çš„è°ƒç”¨ã€‚ å› æ­¤ï¼Œ `feed.info{value: 10, gas: 800}` æ˜¯æ²¡æœ‰è°ƒç”¨å‡½æ•°çš„ï¼Œ `value` å’Œ `gas` è®¾ç½®æ˜¯æ— æ•ˆçš„ã€‚
- extcodesize æ“ä½œç ä¼šæ£€æŸ¥è¦è°ƒç”¨çš„åˆçº¦æ˜¯å¦ç¡®å®å­˜åœ¨ï¼Œæœ‰å“ªäº›ç‰¹æ®Šæƒ…å†µï¼Ÿ
  - ä½çº§ call è°ƒç”¨ï¼Œä¼šç»•è¿‡æ£€æŸ¥
  - é¢„ç¼–è¯‘åˆçº¦çš„æ—¶å€™ï¼Œä¹Ÿä¼šç»•è¿‡æ£€æŸ¥ã€‚
- ä¸å…¶ä»–å’Œæœˆäº¤äº’æ—¶å€™æœ‰ä»€ä¹ˆéœ€è¦æ³¨æ„çš„ï¼Ÿ
  - ä»»ä½•ä¸å…¶ä»–åˆçº¦çš„äº¤äº’éƒ½ä¼šäº§ç”Ÿæ½œåœ¨å±é™©ï¼Œå°¤å…¶æ˜¯åœ¨ä¸èƒ½é¢„å…ˆçŸ¥é“åˆçº¦ä»£ç çš„æƒ…å†µä¸‹ã€‚
  - å°å¿ƒè¿™ä¸ªäº¤äº’è°ƒç”¨åœ¨è¿”å›ä¹‹å‰å†å›è°ƒæˆ‘ä»¬çš„åˆçº¦ï¼Œè¿™æ„å‘³ç€è¢«è°ƒç”¨åˆçº¦å¯ä»¥é€šè¿‡å®ƒè‡ªå·±çš„å‡½æ•°æ”¹å˜è°ƒç”¨åˆçº¦çš„çŠ¶æ€å˜é‡ã€‚ ä¸€ä¸ªå»ºè®®çš„å‡½æ•°å†™æ³•æ˜¯ï¼Œä¾‹å¦‚ï¼Œ**åœ¨åˆçº¦ä¸­çŠ¶æ€å˜é‡è¿›è¡Œå„ç§å˜åŒ–åå†è°ƒç”¨å¤–éƒ¨å‡½æ•°**ï¼Œè¿™æ ·ï¼Œä½ çš„åˆçº¦å°±ä¸ä¼šè½»æ˜“è¢«æ»¥ç”¨çš„é‡å…¥æ”»å‡» (reentrancy) æ‰€å½±å“
- public æ—¢å¯ä»¥è¢«å½“ä½œå†…éƒ¨å‡½æ•°ä¹Ÿå¯ä»¥è¢«å½“ä½œå¤–éƒ¨å‡½æ•°ã€‚ä½¿ç”¨æ—¶å€™æœ‰ä»€ä¹ˆæ³¨æ„çš„ï¼Ÿ
  - å¦‚æœæƒ³å°†ä¸€ä¸ªå‡½æ•°å½“ä½œå†…éƒ¨å‡½æ•°ä½¿ç”¨ï¼Œå°±ç”¨ `f` è°ƒç”¨ï¼Œå¦‚æœæƒ³å°†å…¶å½“ä½œå¤–éƒ¨å‡½æ•°ï¼Œä½¿ç”¨ `this.f` ã€‚
- pure å‡½æ•°ä¸­ï¼Œå“ªäº›è¡Œä¸ºè¢«è§†ä¸ºè¯»å–çŠ¶æ€ã€‚

  - è¯»å–çŠ¶æ€å˜é‡ã€‚
    - è¿™ä¹Ÿæ„å‘³ç€è¯»å– `immutable` å˜é‡ä¹Ÿä¸æ˜¯ä¸€ä¸ª `pure` æ“ä½œã€‚
  - è®¿é—® `address(this).balance` æˆ– `<address>.balance`
  - è®¿é—® `block`ï¼Œ`tx`ï¼Œ `msg` ä¸­ä»»æ„æˆå‘˜ ï¼ˆé™¤ `msg.sig` å’Œ `msg.data` ä¹‹å¤–ï¼‰ã€‚
  - è°ƒç”¨ä»»ä½•æœªæ ‡è®°ä¸º `pure` çš„å‡½æ•°ã€‚
  - **ä½¿ç”¨åŒ…å«ç‰¹å®šæ“ä½œç çš„å†…è”æ±‡ç¼–ã€‚**
    - `TODO:` è¿™ä¸ªä¸äº†è§£ï¼Œéœ€è¦ç”¨ä¾‹å­åŠ æ·±å°è±¡ã€‚
  - ä½¿ç”¨æ“ä½œç  `STATICCALL` , è¿™å¹¶ä¸ä¿è¯çŠ¶æ€æœªè¢«è¯»å–, ä½†è‡³å°‘ä¸è¢«ä¿®æ”¹ã€‚

- pure å‡½æ•°å‘ç”Ÿé”™è¯¯æ—¶å€™ï¼Œæœ‰ä»€ä¹ˆéœ€è¦æ³¨æ„çš„ï¼Ÿ
  - å¦‚æœå‘ç”Ÿé”™è¯¯ï¼Œ`pure` å‡½æ•°å¯ä»¥ä½¿ç”¨ `revert()`å’Œ `require()` å‡½æ•°æ¥è¿˜åŸæ½œåœ¨çš„çŠ¶æ€æ›´æ”¹ã€‚è¿˜åŸçŠ¶æ€æ›´æ”¹ä¸è¢«è§†ä¸º **çŠ¶æ€ä¿®æ”¹**, å› ä¸ºå®ƒåªè¿˜åŸä»¥å‰åœ¨æ²¡æœ‰`view` æˆ– `pure` é™åˆ¶çš„ä»£ç ä¸­æ‰€åšçš„çŠ¶æ€æ›´æ”¹, å¹¶ä¸”ä»£ç å¯ä»¥é€‰æ‹©æ•è· revert å¹¶ä¸ä¼ é€’è¿˜åŸã€‚è¿™ç§è¡Œä¸ºä¹Ÿç¬¦åˆ STATICCALL æ“ä½œç ã€‚
- view å‡½æ•°ä¸­ï¼Œå“ªäº›è¡Œä¸ºè§†ä¸ºä¿®æ”¹çŠ¶æ€ã€‚
  - ä¿®æ”¹çŠ¶æ€å˜é‡ã€‚
  - è§¦å‘äº‹ä»¶ã€‚
  - åˆ›å»ºå…¶å®ƒåˆçº¦ã€‚
  - ä½¿ç”¨ `selfdestruct`ã€‚
  - é€šè¿‡è°ƒç”¨å‘é€ä»¥å¤ªå¸ã€‚
  - è°ƒç”¨ä»»ä½•æ²¡æœ‰æ ‡è®°ä¸º view æˆ–è€… pure çš„å‡½æ•°ã€‚
  - ä½¿ç”¨åº•å±‚è°ƒç”¨
    - (TODO:è¿™é‡Œæ˜¯ call æ“ä½œä¹ˆï¼Ÿ)
  - ä½¿ç”¨åŒ…å«æŸäº›æ“ä½œç çš„å†…è”ç¨‹åºé›†ã€‚
- pure/view/payable/è¿™äº›çŠ¶æ€å¯å˜æ€§çš„ç±»å‹è½¬æ¢æ˜¯æ€ä¹ˆæ ·çš„ï¼Ÿ
  - pure å‡½æ•°å¯ä»¥è½¬æ¢ä¸º view å’Œ non-payable å‡½æ•°
  - view å‡½æ•°å¯ä»¥è½¬æ¢ä¸º non-payable å‡½æ•°
  - payable å‡½æ•°å¯ä»¥è½¬æ¢ä¸º non-payable å‡½æ•°
  - å…¶ä»–çš„è½¬æ¢åˆ™ä¸å¯ä»¥ã€‚
- ä½¿ç”¨ return æ—¶ï¼Œæœ‰å“ªäº›éœ€è¦æ³¨æ„çš„ï¼Ÿ
  - å‡½æ•°è¿”å›ç±»å‹ä¸èƒ½ä¸ºç©º â€”â€” å¦‚æœå‡½æ•°ç±»å‹ä¸éœ€è¦è¿”å›ï¼Œåˆ™éœ€è¦åˆ é™¤æ•´ä¸ª `returns (<return types>)` éƒ¨åˆ†ã€‚
  - å‡½æ•°å¯èƒ½è¿”å›ä»»æ„æ•°é‡çš„å‚æ•°ä½œä¸ºè¾“å‡ºã€‚å‡½æ•°çš„è¿”å›å€¼æœ‰ä¸¤ä¸ªå…³é”®å­—ï¼Œä¸€ä¸ªæ˜¯`returns`,ä¸€ä¸ªæ˜¯ `return`;
    - `returns` æ˜¯åœ¨å‡½æ•°ååé¢çš„ï¼Œç”¨æ¥æ ‡ç¤ºè¿”å›å€¼çš„æ•°é‡ï¼Œç±»å‹ï¼Œåå­—ä¿¡æ¯ã€‚
    - `return` æ˜¯åœ¨å‡½æ•°ä¸»ä½“å†…ï¼Œç”¨äºè¿”å› `returns` æŒ‡å®šçš„æ•°æ®ä¿¡æ¯
  - å¦‚æœä½¿ç”¨ return æå‰é€€å‡ºæœ‰è¿”å›å€¼çš„å‡½æ•°ï¼Œ å¿…é¡»åœ¨ç”¨ return æ—¶æä¾›è¿”å›å€¼ã€‚
  - éå†…éƒ¨å‡½æ•°æœ‰äº›ç±»å‹æ²¡æ³•è¿”å›ï¼Œæ¯”å¦‚é™åˆ¶çš„ç±»å‹æœ‰ï¼šå¤šç»´åŠ¨æ€æ•°ç»„ã€ç»“æ„ä½“ç­‰ã€‚
  - è§£æ„èµ‹å€¼ä¸€ä¸ªå‡½æ•°è¿”å›å¤šå€¼æ—¶å€™ï¼Œå…ƒç´ æ•°é‡å¿…é¡»ä¸€æ ·ã€‚
- å‡½æ•°çš„ç­¾åçš„é€»è¾‘æ˜¯ä»€ä¹ˆï¼Ÿä¸ºä»€ä¹ˆå‡½æ•°å¯ä»¥é‡è½½ï¼Ÿ
  - æ ¸å¿ƒ: `bytes4(keccak256(bytes("transfer(address,uint256)")))`
  - å‡½æ•°ç­¾åè¢«å®šä¹‰ä¸ºåŸºç¡€åŸå‹çš„è§„èŒƒè¡¨è¾¾ï¼Œè€ŒåŸºç¡€åŸå‹æ˜¯**å‡½æ•°åç§°åŠ ä¸Šç”±æ‹¬å·æ‹¬èµ·æ¥çš„å‚æ•°ç±»å‹åˆ—è¡¨ï¼Œå‚æ•°ç±»å‹é—´ç”±ä¸€ä¸ªé€—å·åˆ†éš”å¼€ï¼Œä¸”æ²¡æœ‰ç©ºæ ¼ã€‚**
- å‡½æ•°é‡è½½éœ€è¦æ€ä¹ˆæ ·å®ç°ï¼Ÿ
  - **è¿™äº›ç›¸åŒå‡½æ•°åçš„å‡½æ•°ï¼Œå‚æ•°(å‚æ•°ç±»å‹æˆ–å‚æ•°æ•°é‡)å¿…é¡»ä¸ä¸€æ ·ã€‚**ï¼Œå› ä¸ºåªæœ‰è¿™æ ·æ‰èƒ½ç­¾å‡ºæ¥ä¸åŒçš„å‡½æ•°é€‰æ‹©å™¨ã€‚
  - å¦‚æœä¸¤ä¸ªå¤–éƒ¨å¯è§å‡½æ•°ä»…åŒºåˆ«äº Solidity å†…çš„ç±»å‹ï¼Œè€Œä¸æ˜¯å®ƒä»¬çš„å¤–éƒ¨ç±»å‹åˆ™ä¼šå¯¼è‡´é”™è¯¯ã€‚å¾ˆéš¾ç†è§£ï¼Œéœ€è¦çœ‹ä¾‹å­ã€‚
- å‡½æ•°é‡è½½çš„å‚æ•°åŒ¹é…åŸç†
  - é€šè¿‡å°†å½“å‰èŒƒå›´å†…çš„å‡½æ•°å£°æ˜ä¸å‡½æ•°è°ƒç”¨ä¸­æä¾›çš„å‚æ•°ç›¸åŒ¹é…ï¼Œè¿™æ ·å°±å¯ä»¥é€‰æ‹©é‡è½½å‡½æ•°ã€‚
  - å¦‚æœæ‰€æœ‰å‚æ•°éƒ½å¯ä»¥éšå¼åœ°è½¬æ¢ä¸ºé¢„æœŸç±»å‹ï¼Œåˆ™è¯¥å‡½æ•°ä½œä¸ºé‡è½½å€™é€‰é¡¹ã€‚å¦‚æœä¸€ä¸ªåŒ¹é…çš„éƒ½æ²¡æœ‰ï¼Œè§£æå¤±è´¥ã€‚
  - è¿”å›å‚æ•°ä¸ä½œä¸ºé‡è½½è§£æçš„ä¾æ®ã€‚
- ` function f(uint8 val) public pure returns (uint8 out)` å’Œ `function f(uint256 val) public pure returns (uint256 out)` æ˜¯åˆæ³•çš„å‡½æ•°é‡è½½ä¹ˆï¼Ÿ
  - ä¸æ˜¯çš„ã€‚
  - åœ¨ Remix é‡Œ,éƒ¨ç½² A åˆçº¦ï¼Œä¼šå°†ä¸¤ä¸ªæ–¹æ³•éƒ½æ¸²æŸ“å‡ºæ¥ï¼Œè°ƒç”¨ `f(50)`/`f(256)` éƒ½å¯ä»¥ã€‚
  - ä½†æ˜¯å®é™…è°ƒç”¨é‡Œï¼Œåœ¨å…¶ä»–åˆçº¦å†…è°ƒç”¨ `f(50)` ä¼šå¯¼è‡´ç±»å‹é”™è¯¯ï¼Œå› ä¸º `50` æ—¢å¯ä»¥è¢«éšå¼è½¬æ¢ä¸º `uint8`ä¹Ÿå¯ä»¥è¢«éšå¼è½¬æ¢ä¸º `uint256`ã€‚ å¦ä¸€æ–¹é¢ï¼Œè°ƒç”¨ `f(256)` åˆ™ä¼šè§£æä¸º`f(uint256)` é‡è½½ï¼Œå› ä¸º `256` ä¸èƒ½éšå¼è½¬æ¢ä¸º `uint8`ã€‚
- å‡½æ•°ä¿®æ”¹å™¨çš„æ„ä¹‰æ˜¯ä»€ä¹ˆï¼Ÿæœ‰ä»€ä¹ˆä½œç”¨ï¼Ÿ
  - **æ„ä¹‰**:æˆ‘ä»¬å¯ä»¥å°†ä¸€äº›é€šç”¨çš„æ“ä½œæå–å‡ºæ¥ï¼ŒåŒ…è£…ä¸ºå‡½æ•°ä¿®æ”¹å™¨ï¼Œæ¥æé«˜ä»£ç çš„å¤ç”¨æ€§ï¼Œæ”¹å–„ç¼–ç æ•ˆç‡ã€‚æ˜¯å‡½æ•°é«˜å†…èšï¼Œä½è€¦åˆçš„å»¶ä¼¸ã€‚
  - **ä½œç”¨**: `modifier` å¸¸ç”¨äºåœ¨å‡½æ•°æ‰§è¡Œå‰æ£€æŸ¥æŸç§å‰ç½®æ¡ä»¶ã€‚
  - æ¯”å¦‚åœ°å€å¯¹ä¸å¯¹ï¼Œä½™é¢æ˜¯å¦å……è¶³ï¼Œå‚æ•°å€¼æ˜¯å¦å…è®¸ç­‰
  - ä¿®æ”¹å™¨å†…å¯ä»¥å†™é€»è¾‘
  - **ç‰¹ç‚¹**: `modifier` æ˜¯ä¸€ç§åˆçº¦å±æ€§ï¼Œå¯è¢«ç»§æ‰¿ï¼ŒåŒæ—¶è¿˜å¯è¢«æ´¾ç”Ÿçš„åˆçº¦é‡å†™(override)ã€‚ï¼ˆä¿®æ”¹å™¨ modifier æ˜¯åˆçº¦çš„å¯ç»§æ‰¿å±æ€§ï¼Œå¹¶å¯èƒ½è¢«æ´¾ç”Ÿåˆçº¦è¦†ç›– , ä½†å‰ææ˜¯å®ƒä»¬è¢«æ ‡è®°ä¸º virtualï¼‰ã€‚
  - `_` ç¬¦å·å¯ä»¥åœ¨ä¿®æ”¹å™¨ä¸­å‡ºç°å¤šæ¬¡ï¼Œæ¯å¤„éƒ½ä¼šæ›¿æ¢ä¸ºå‡½æ•°ä½“ã€‚
- Solidity æœ‰å“ªäº›å…¨å±€çš„æ•°å­¦å’Œå¯†ç å­¦å‡½æ•°ï¼Ÿ
  - æ•°å­¦å‡½æ•°ï¼š
  - `addmod(uint x, uint y, uint k) returns (uint)`
    - è®¡ç®— `(x + y) % k`ï¼ŒåŠ æ³•ä¼šåœ¨ä»»æ„ç²¾åº¦ä¸‹æ‰§è¡Œï¼Œå¹¶ä¸”åŠ æ³•çš„ç»“æœå³ä½¿è¶…è¿‡ `2**256` ä¹Ÿä¸ä¼šè¢«æˆªå–ã€‚ä» 0.5.0 ç‰ˆæœ¬çš„ç¼–è¯‘å™¨å¼€å§‹ä¼šåŠ å…¥å¯¹ `k != 0` çš„æ ¡éªŒï¼ˆassertï¼‰ã€‚
  - `mulmod(uint x, uint y, uint k) returns (uint)`
    - è®¡ç®— `(x * y) % k`ï¼Œä¹˜æ³•ä¼šåœ¨ä»»æ„ç²¾åº¦ä¸‹æ‰§è¡Œï¼Œå¹¶ä¸”ä¹˜æ³•çš„ç»“æœå³ä½¿è¶…è¿‡ `2**256` ä¹Ÿä¸ä¼šè¢«æˆªå–ã€‚ä» 0.5.0 ç‰ˆæœ¬çš„ç¼–è¯‘å™¨å¼€å§‹ä¼šåŠ å…¥å¯¹ `k != 0` çš„æ ¡éªŒï¼ˆassertï¼‰ã€‚
  - å¯†ç å­¦å‡½æ•°ï¼š
  - `keccak256((bytes memory) returns (bytes32)`
    - è®¡ç®— Keccak-256 å“ˆå¸Œï¼Œä¹‹å‰ keccak256 çš„åˆ«åå‡½æ•° **sha3** åœ¨ **0.5.0** ä¸­å·²ç»ç§»é™¤ã€‚ã€‚
  - `sha256(bytes memory) returns (bytes32)`
    - è®¡ç®—å‚æ•°çš„ SHA-256 å“ˆå¸Œã€‚
  - `ripemd160(bytes memory) returns (bytes20)`
    - è®¡ç®—å‚æ•°çš„ RIPEMD-160 å“ˆå¸Œã€‚
  - `ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)`
    - åˆ©ç”¨æ¤­åœ†æ›²çº¿ç­¾åæ¢å¤ä¸å…¬é’¥ç›¸å…³çš„åœ°å€ï¼Œé”™è¯¯è¿”å›é›¶å€¼ã€‚
    - å‡½æ•°å‚æ•°å¯¹åº”äº ECDSA ç­¾åçš„å€¼:
      - r = ç­¾åçš„å‰ 32 å­—èŠ‚
      - s = ç­¾åçš„ç¬¬ 2 ä¸ª 32 å­—èŠ‚
      - v = ç­¾åçš„æœ€åä¸€ä¸ªå­—èŠ‚
    - ecrecover è¿”å›ä¸€ä¸ª address, è€Œä¸æ˜¯ address payableã€‚
