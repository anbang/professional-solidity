# æ•°æ®

æ•°æ®æ˜¯ä»»ä½•ç¼–ç¨‹è¯­è¨€çš„ç”Ÿäº§ç”Ÿæ´»èµ„æ–™ï¼Œç¦»å¼€äº†æ•°æ®ï¼Œç¼–ç¨‹è¯­è¨€å°†ä¼šå˜å¾—æ¯«æ— æ„ä¹‰ã€‚ä½†æ˜¯æˆ‘ä»¬å¹¶ä¸èƒ½æŠŠæ‰€æœ‰çš„æ•°æ®éƒ½ç§°ä¸ºä¸€ä¸ªæ•°æ®ï¼Œå°±å¥½åƒæˆ‘ä»¬ç°å®ç”Ÿæ´»ä¸­ä¼šåˆ†ä¸ºäººç±»ï¼ŒåŠ¨ç‰©ç±»ï¼Œæ¤ç‰©ç±»ç­‰ã€‚Solidity æ™ºèƒ½åˆçº¦çš„å«ä¹‰å°±æ˜¯ä¸€äº›åŠŸèƒ½å’Œæ•°æ®çš„é›†åˆï¼Œå®ƒä»¬æ˜¯ä½äºä»¥å¤ªåŠåŒºå—é“¾çš„ç‰¹å®šåœ°å€ä¸Šã€‚

Solidity æä¾›äº†å‡ ç§åŸºæœ¬ç±»å‹ï¼Œå¹¶ä¸”åŸºæœ¬ç±»å‹å¯ä»¥ç”¨æ¥ç»„åˆå‡ºå¤æ‚ç±»å‹ã€‚

æœ¬ç« ç›®å½•

- æ•°æ®ä¸å˜é‡
- ä¸¤ç§ç±»å‹çš„æ•°æ®
- å€¼ç±»å‹
- å€¼ç±»å‹:åœ°å€ç±»å‹
- å€¼ç±»å‹:åˆçº¦ç±»å‹
- å¼•ç”¨ç±»å‹çš„é¢å¤–æ³¨è§£:æ•°æ®ä½ç½®
- å¼•ç”¨ç±»å‹
- 8ï¸âƒ£ ç±»å‹è½¬æ¢
- 9ï¸âƒ£ å­—é¢å¸¸é‡ä¸åŸºæœ¬ç±»å‹çš„è½¬æ¢
- å®æˆ˜ 1: åŒå¿—ä»¬å¥½å¢åŠ æç¤º
- å®æˆ˜ 2: ETH é’±åŒ…
- å®æˆ˜ 3: å¤šç­¾é’±åŒ…
- é—®ç­”é¢˜

## æ•°æ®ä¸å˜é‡

æåˆ°æ•°æ®ï¼Œå°±ä¸å¯é¿å…çš„éœ€è¦ç‰µæ‰¯åˆ°å˜é‡ã€‚å˜é‡åæ˜¯æ•°æ®çš„åœ¨è®¡ç®—ä¸­çš„å¼•ç”¨ã€‚

```
uint256 u = 123;
```

å¦‚ä¸Šæ˜¯å°†`123`è¿™ä¸ª `uint8`ç±»å‹æ•°æ®ï¼Œèµ‹å€¼ç»™ `u` è¿™ä¸ªåªèƒ½èµ‹å€¼`uint256`ç±»å‹æ•°æ®çš„å˜é‡åï¼ˆ`uint8` å¯ä»¥éšå¼è½¬ä¸º`uint256`ï¼‰ã€‚åç»­æˆ‘ä»¬éœ€è¦ä½¿ç”¨`123`è¿™ä¸ªæ•°æ®æ—¶ï¼Œå†™ `u` å°±å¯ä»¥ä»£è¡¨ã€‚

`uint256 u` ä¸­çš„ `uint256`å…³é”®å­—ï¼Œé™åˆ¶äº† `u` è¿™ä¸ªå˜é‡ååªèƒ½èµ‹å€¼`uint256`ç±»å‹æ•°æ®ï¼›åœ¨å…¶ä»–å¼±ç±»å‹è¯­è¨€ä¸­å¯èƒ½å­˜åœ¨å˜é‡ç±»å‹å–å†³äºæ•°æ®çš„æƒ…å†µã€‚ä½†æ˜¯ `Solidity` ä¸­ä¸å­˜åœ¨è¿™ç§æƒ…å†µï¼Œåœ¨å˜é‡å£°æ˜æ—¶å¿…é¡»æŒ‡å®šå˜é‡ç±»å‹ã€‚**Solidity æ˜¯ä¸€ç§é™æ€å¼ºç±»å‹çš„è¯­è¨€ï¼Œå¯¹äºå¸¸è§é”™è¯¯ï¼Œå¼€å‘è€…å¯ä»¥é€šè¿‡ç¼–è¯‘è¿…é€Ÿæ•æ‰åˆ°**ï¼Œä»»ä½•çš„ Solidity åˆçº¦éƒ½éœ€è¦**ç¼–è¯‘**å’Œ**éƒ¨ç½²**çš„é˜¶æ®µã€‚

### éšå¼è½¬æ¢

å¦‚æœä¸Šé¢ `uint256 u = 123;` æ”¹ä¸º `uint256 u = "Hello";`ï¼Œå°†ä¼šæ”¶åˆ°é”™è¯¯ `Type literal_string "Hello" is not implicitly convertible to expected type uint256.`ï¼Œå› ä¸ºè¿™ä¸¤ç§ç±»å‹ä¸èƒ½éšå¼è½¬æ¢çš„ï¼›

å¦‚æœä¸Šé¢ `uint256 u = 123;` æ”¹ä¸º `uint256 u = uint8(123);`ï¼Œå°±ä¸ä¼šæœ‰é—®é¢˜ï¼Œå› ä¸º`uint8`ç±»å‹å¯ä»¥éšå¼è½¬æ¢ä¸º`uint256`ç±»å‹ã€‚åé¢ä»‹ç»ç±»å‹è½¬æ¢çš„æ—¶å€™ä¼šè¯¦ç»†çš„ä»‹ç»ã€‚

- **æ€»ç»“:**
  1. Solidity æ˜¯ä¸€ç§é™æ€å¼ºç±»å‹çš„è¯­è¨€ã€‚
  2. å˜é‡ç±»å‹å’Œéœ€è¦èµ‹å€¼çš„æ•°æ®ç±»å‹å¿…é¡»å¿…é…ï¼Œæˆ–è€…æ‰€èµ‹å€¼çš„æ•°æ®å¯ä»¥éšå¼è½¬æ¢ä¸ºå˜é‡ç±»å‹ã€‚

## ä¸¤ç§ç±»å‹çš„æ•°æ®

### å†…å®¹

Solidity æŒ‰ç…§æ•°æ®ç±»å‹å¯ä»¥åˆ†ä¸º**å€¼ç±»å‹**å’Œ**å¼•ç”¨ç±»å‹**ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    uint256 public u = 123; // æ— å˜åŒ–
    string public welcome1 = "Hello";
    string public welcome2 = "Hello";

    function test() external returns(uint256,string memory,string memory){
        // ä¿®æ”¹å€¼ç±»å‹
        uint256 x = u; // èµ‹å€¼
        x = 1; // ä¿®æ”¹

        // ä¿®æ”¹å¼•ç”¨ç±»å‹
        string storage hi1 =  welcome1; // èµ‹å€¼
        bytes(hi1)[0] = bytes1("2");

        string memory hi2 =  welcome2; // èµ‹å€¼
        bytes(hi2)[0] = bytes1("2");

        // è¿”å›å€¼
        return(x,hi1,hi2);
    }
}
```

- å€¼ç±»å‹: å€¼ç±»å‹ä¼ å€¼æ—¶ä¼šå°†å€¼æ‹·è´ä¸€ä»½ï¼Œä¼ é€’çš„æ˜¯å€¼æœ¬èº«ï¼Œå¯¹å…¶ä¿®æ”¹æ—¶å¹¶ä¸ä¼šå¯¹åŸæ¥å€¼æœ‰å½±å“ã€‚
  - å§‹ç»ˆæŒ‰å€¼æ¥ä¼ é€’ï¼Œå½“è¢«ç”¨ä½œå‡½æ•°å‚æ•°æˆ–è€…ç”¨åœ¨èµ‹å€¼è¯­å¥ä¸­æ—¶ï¼Œæ€»ä¼šè¿›è¡Œå€¼æ‹·è´ã€‚
  - å€¼ç±»å‹é‡Œæœ‰ä¸¤ä¸ªæ¯”è¾ƒç‰¹æ®Šçš„ç±»å‹æ˜¯å‡½æ•°å’Œåœ°å€ï¼ˆåŒ…æ‹¬åˆçº¦ï¼‰ï¼Œä¼šåˆ†ä¸ºå•ç‹¬çš„éƒ¨åˆ†ä»‹ç»ã€‚
- å¼•ç”¨ç±»å‹: å¼•ç”¨ç±»å‹è¿›è¡Œä¼ é€’æ—¶ï¼Œä¼ é€’çš„æ˜¯å…¶æŒ‡é’ˆï¼Œè€Œå¼•ç”¨ç±»å‹è¿›è¡Œä¼ é€’æ—¶**å¯ä»¥ä¸ºå€¼ä¼ é€’**ï¼Œ**ä¹Ÿå¯ä»¥ä¸ºå¼•ç”¨ä¼ é€’**ã€‚

## å€¼ç±»å‹

1. Boolean
2. Integer
   1. uint
   2. int
3. å®šé•¿å­—èŠ‚æ•°ç»„ï¼ˆå›ºå®šå¤§å°å­—èŠ‚æ•°ç»„ï¼‰
   1. `bytes1` - `bytes32`
4. Enum:æšä¸¾
5. åœ°å€ï¼ˆAddressï¼‰
6. åˆçº¦ç±»å‹
7. å‡½æ•°ï¼ˆFunction Typesï¼‰
   1. æ¯”è¾ƒç‰¹æ®Šï¼Œå•ç‹¬å¼€äº†ä¸€ç« è¯´æ˜

<!-- 8. ğŸ¤”ï¸: æµ®ç‚¹å‹ï¼ˆfixed/unfixedï¼‰ -->
<!-- 9. ğŸ¤”ï¸: æœ‰ç†æ•°å’Œæ•´å‹ï¼ˆRational and Integer Literals,String literalsï¼‰ -->

### Boolean å¸ƒå°”ç±»å‹

å¸ƒå°”å‹ä½¿ç”¨ `bool`è¡¨ç¤ºï¼Œè¯¥ç±»å‹åªæœ‰ä¸¤ä¸ªå€¼ï¼Œåˆ†åˆ«æ˜¯ `true`/`false`ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo1 {
    bool public t = true;
    bool public f = false;
}
```

å¸ƒå°”å€¼é™¤äº†èµ‹å€¼å¾—åˆ°å¤–ï¼Œè¿˜å¯ä»¥é€šè¿‡**è¿ç®—ç¬¦**çš„è®¡ç®—ç»“æœå¾—åˆ°ã€‚

####  æ”¯æŒçš„è¿ç®—ç¬¦

- åŒ…æ‹¬ï¼š`!`é€»è¾‘éï¼Œ
- `==`ç­‰äºï¼Œ`!=` ä¸ç­‰äº;
- `&&`é€»è¾‘ä¸ï¼Œ`||`é€»è¾‘æˆ–ï¼Œ
  - `&&`ï¼Œ`||` ä¸ºçŸ­è·¯è¿ç®—ç¬¦ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo2 {
    bool public a = false;
    bool public b = !a; // ä»…ç”¨äºå¸ƒå°”å€¼
    bool public c = a == b;
    bool public d = a != b;
    bool public e = a && b;
    bool public f = a || b;
}
```

è¿ç®—ç¬¦ `||` å’Œ `&&` éƒ½éµå¾ªåŒæ ·çš„çŸ­è·¯ï¼ˆ short-circuiting ï¼‰è§„åˆ™ã€‚å°±æ˜¯è¯´åœ¨è¡¨è¾¾å¼ `f(x) || g(y)` ä¸­ï¼Œ å¦‚æœ `f(x)` çš„å€¼ä¸º true ï¼Œé‚£ä¹ˆ `g(y)` å°±ä¸ä¼šè¢«æ‰§è¡Œï¼Œ

####  ä½¿ç”¨çŸ­è·¯è§„åˆ™èŠ‚çœ gas

å€ŸåŠ©çŸ­è·¯è§„åˆ™ï¼Œå¯ä»¥è®©åˆçº¦å°‘æ‰§è¡Œä¸€äº›é€»è¾‘ã€‚

- `||` å¦‚æœç¬¬ä¸€ä¸ªè¡¨è¾¾å¼æ˜¯`true`ï¼Œåˆ™ç¬¬äºŒä¸ªè¡¨è¾¾å¼ä¸å†æ‰§è¡Œã€‚ï¼ˆå› ä¸ºä¸¤ä¸ªè¡¨è¾¾å¼æœ‰ä¸€ä¸ªä¸º trueï¼Œç»“æœå°±ä¸º trueï¼Œä¸éœ€è¦è®¡ç®—ç¬¬äºŒä¸ªè¡¨è¾¾å¼å°±çŸ¥é“ç»“æœäº†ï¼‰
- `&&` å¦‚æœç¬¬ä¸€ä¸ªè¡¨è¾¾å¼æ˜¯`false`ï¼Œåˆ™ç¬¬äºŒä¸ªè¡¨è¾¾å¼ä¸å†æ‰§è¡Œã€‚ï¼ˆä¸¤ä¸ªè¡¨è¾¾å¼å¿…é¡»éƒ½ä¸º trueï¼Œç»“æœæ‰èƒ½ trueï¼Œå¦‚æœç¬¬ä¸€ä¸ªä¸º falseï¼Œä¸éœ€è¦è®¡ç®—ç¬¬äºŒä¸ªè¡¨è¾¾å¼å°±çŸ¥é“ç»“æœäº†ï¼‰

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.16;

contract Demo3 {
    // 21488 gas
    function testA1() external pure returns (bool) {
        uint256 a = 100 - 99;
        uint256 b = 100 - 1;
        if (a > 50 || b < 50) {
            return true;
        }
        return false;
    }

    // 21440 gas
    function testA2() external pure returns (bool) {
        if ((100 - 99) > 50 || (100 - 10) < 50) {
            return true;
        }
        return false;
    }
}
```

<span style="color: red;">æœ¬ç« ä¸»è¦ä»‹ç»æ•°æ®ç±»å‹ï¼Œåç»­ä»‹ç»æ•°æ®ç±»å‹çš„æ—¶ä¸å†ä»‹ç»æ“ä½œç¬¦ï¼Œä¼šä¸“é—¨æœ‰ä¸€ç« æ¥æ€»ç»“æ“ä½œç¬¦ã€‚</span>

### Integer æ•´æ•°ç±»å‹

æ•´æ•°ç±»å‹åˆ†ä¸ºæœ‰ç¬¦å·æ•´å‹ï¼Œç”¨ int æ ‡ç¤ºï¼›å’Œæ— ç¬¦å·æ•´å‹ï¼Œç”¨ uint æ ‡ç¤ºï¼›

**int å’Œ uint**:

<table border="1" class="docutils">
<thead>
<tr>
<th>ç±»å‹</th>
<th>ç¬¦å·å</th>
<th>å–å€¼</th>
</tr>
</thead>
<tbody>
<tr>
<td rowspan="4">æ•´å‹</td>
 <td>int8 to int256</td>
<td>8 ä½åˆ° 256 ä½çš„å¸¦ç¬¦å·æ•´å‹æ•°ã€‚</td>
</tr>
<tr>
<td>uint8 to uint256</td>
<td>8 ä½åˆ° 256 ä½çš„æ— ç¬¦å·æ•´å‹ã€‚</td>
</tr>
<tr>
<td>int</td>
<td>æœ‰ç¬¦å·æ•´æ•°ï¼Œint ä¸  int256 ç›¸åŒã€‚</td>
</tr>
<tr>
 <td>uint</td>
<td>æ— ç¬¦å·æ•´æ•°ï¼Œuint å’Œ uint256 æ˜¯ä¸€æ ·çš„ã€‚</td>
</tr>
<tr>
<td rowspan="4">å®šé•¿æµ®ç‚¹å‹</td>
<td>fixed</td>
<td>æœ‰ç¬¦å·çš„å®šé•¿æµ®ç‚¹å‹</td>
</tr>
<tr>
 <td>unfixed</td>
<td>æ— ç¬¦å·çš„å®šé•¿æµ®ç‚¹å‹</td>
</tr>
<tr>
 <!-- <td>fixedMxN</td>
<td>å¸¦ç¬¦å·çš„å®šé•¿æµ®ç‚¹å‹ï¼Œå…¶ä¸­ M è¡¨ç¤ºæŒ‰ç±»å‹å–çš„ä½æ•°ï¼ŒN è¡¨ç¤ºå°æ•°ç‚¹ã€‚<br>M åº”è¯¥èƒ½è¢« 8 æ•´é™¤ï¼Œä» 8 åˆ° 256ã€‚N å¯ä»¥æ˜¯ 0 åˆ° 80ã€‚<br>fixed ä¸ fixed128x18 ç›¸åŒã€‚</td>
</tr>
<tr>
 <td>ufixedMxN</td>
<td>æ— ç¬¦å·çš„å®šé•¿æµ®ç‚¹å‹ï¼Œå…¶ä¸­ M è¡¨ç¤ºæŒ‰ç±»å‹å–çš„ä½æ•°ï¼ŒN è¡¨ç¤ºå°æ•°ç‚¹ã€‚<br>M åº”è¯¥èƒ½è¢« 8 æ•´é™¤ï¼Œä» 8 åˆ° 256ã€‚N å¯ä»¥æ˜¯ 0 åˆ° 80ã€‚<br>ufixed ä¸ unfixed128x18 ç›¸åŒã€‚</td>
</tr> -->
</tbody>
</table>

- int æ˜¯æœ‰ç¬¦å·æ•´å‹ï¼Œæ”¯æŒ int8 åˆ° int256ã€‚
- uint æ˜¯æ— ç¬¦å·æ•´å‹ï¼Œæ”¯æŒä» uint8 åˆ° uint256ã€‚
- `uint` å’Œ `int` åˆ†åˆ«æ˜¯ `uint256` å’Œ `int256` çš„åˆ«åã€‚

####  å±æ€§

å¯¹äºæ•´å‹ T æœ‰ä¸‹é¢çš„å…¨å±€å±æ€§å¯è®¿é—®ï¼š

- `type(T).min`
  - è·å–æ•´å‹ T çš„æœ€å°å€¼ã€‚
- `type(T).max`
  - è·å–æ•´å‹ T çš„æœ€å¤§å€¼ã€‚

####  uint ç±»å‹

uint æ— ç¬¦å·æ•´æ•°ï¼Œåªèƒ½è¡¨ç¤ºéè´Ÿæ•°ï¼›`åŒ…æ‹¬æ•°å­—0`ï¼›å…¶ä¸­ uint256 ä¸ uint ç›¸åŒï¼Œæ¨èä½¿ç”¨ uint256ï¼›æ”¯æŒ int8 åˆ° int256ï¼Œåé¢çš„æ•°å­—æ˜¯ 8 çš„å€æ•°ã€‚

- `uint8`: æœ€å°å€¼æ˜¯ 0ï¼Œæœ€å¤§å€¼æ˜¯ `2**8-1`
- `uint256`:æœ€å°å€¼æ˜¯ 0ï¼Œæœ€å¤§å€¼æ˜¯ `2**256-1`
- å¯ä»¥ä½¿ç”¨ `type(uint8).max` è·å–è¯¥ç±»å‹çš„æœ€å¤§å€¼
- å¯ä»¥ä½¿ç”¨ `type(uint8).min` è·å–è¯¥ç±»å‹çš„æœ€å°å€¼

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Data {
    // uint
    uint256 public u1 = 123;
    uint8 public u8Max = type(uint8).max; // 255 => (2**8-1)
    uint8 public u8Min = type(uint8).min; // 0

    // 115792089237316195423570985008687907853269984665640564039457584007913129639935
    uint256 public u256Max = type(uint256).max;
    uint256 public u256Min = type(uint256).min; // 0
}
```

**é€šè¿‡ä»£ç è·å–æ‰€æœ‰ `uint` ç±»å‹å’Œå–å€¼èŒƒå›´**

é€šè¿‡åˆçº¦è·å–å…·ä½“çš„æœ€å¤§å€¼èŒƒå›´ï¼Œæœ€å°å€¼ç±»ä¼¼ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Data {
    // uint
    uint8 public u008Max = type(uint8).max;
    uint16 public u016Max = type(uint16).max;
    uint24 public u024Max = type(uint24).max;
    uint32 public u032Max = type(uint32).max;
    uint40 public u040Max = type(uint40).max;
    uint48 public u048Max = type(uint48).max;
    uint56 public u056Max = type(uint56).max;
    uint64 public u064Max = type(uint64).max;
    uint72 public u072Max = type(uint72).max;
    uint80 public u080Max = type(uint80).max;
    uint88 public u088Max = type(uint88).max;
    uint96 public u096Max = type(uint96).max;
    uint104 public u104Max = type(uint104).max;
    uint112 public u112Max = type(uint112).max;
    uint120 public u120Max = type(uint120).max;
    uint128 public u128Max = type(uint128).max;
    uint136 public u136Max = type(uint136).max;
    uint144 public u144Max = type(uint144).max;
    uint152 public u152Max = type(uint152).max;
    uint160 public u160Max = type(uint160).max;
    uint168 public u168Max = type(uint168).max;
    uint176 public u176Max = type(uint176).max;
    uint184 public u184Max = type(uint184).max;
    uint192 public u192Max = type(uint192).max;
    uint200 public u200Max = type(uint200).max;
    uint208 public u208Max = type(uint208).max;
    uint216 public u216Max = type(uint216).max;
    uint224 public u224Max = type(uint224).max;
    uint232 public u232Max = type(uint232).max;
    uint240 public u240Max = type(uint240).max;
    uint248 public u248Max = type(uint248).max;
    uint256 public u256Max = type(uint256).max;
}
```

æ‰€æœ‰ uint ç»“æœå¦‚ä¸‹ï¼š

| uintN   | å°  | æœ€å¤§å€¼                                                                         |
| ------- | --- | ------------------------------------------------------------------------------ |
| uint8   | 0   | 255                                                                            |
| uint16  | 0   | 65535                                                                          |
| uint24  | 0   | 16777215                                                                       |
| uint32  | 0   | 4294967295                                                                     |
| uint40  | 0   | 1099511627775                                                                  |
| uint48  | 0   | 281474976710655                                                                |
| uint56  | 0   | 72057594037927935                                                              |
| uint64  | 0   | 18446744073709551615                                                           |
| uint72  | 0   | 4722366482869645213695                                                         |
| uint80  | 0   | 1208925819614629174706175                                                      |
| uint88  | 0   | 309485009821345068724781055                                                    |
| uint96  | 0   | 79228162514264337593543950335                                                  |
| uint104 | 0   | 20282409603651670423947251286015                                               |
| uint112 | 0   | 5192296858534827628530496329220095                                             |
| uint120 | 0   | 1329227995784915872903807060280344575                                          |
| uint128 | 0   | 340282366920938463463374607431768211455                                        |
| uint136 | 0   | 87112285931760246646623899502532662132735                                      |
| uint144 | 0   | 22300745198530623141535718272648361505980415                                   |
| uint152 | 0   | 5708990770823839524233143877797980545530986495                                 |
| uint160 | 0   | 1461501637330902918203684832716283019655932542975                              |
| uint168 | 0   | 374144419156711147060143317175368453031918731001855                            |
| uint176 | 0   | 95780971304118053647396689196894323976171195136475135                          |
| uint184 | 0   | 24519928653854221733733552434404946937899825954937634815                       |
| uint192 | 0   | 6277101735386680763835789423207666416102355444464034512895                     |
| uint200 | 0   | 1606938044258990275541962092341162602522202993782792835301375                  |
| uint208 | 0   | 411376139330301510538742295639337626245683966408394965837152255                |
| uint216 | 0   | 105312291668557186697918027683670432318895095400549111254310977535             |
| uint224 | 0   | 26959946667150639794667015087019630673637144422540572481103610249215           |
| uint232 | 0   | 6901746346790563787434755862277025452451108972170386555162524223799295         |
| uint240 | 0   | 1766847064778384329583297500742918515827483896875618958121606201292619775      |
| uint248 | 0   | 452312848583266388373324160190187140051835877600158453279131187530910662655    |
| uint256 | 0   | 115792089237316195423570985008687907853269984665640564039457584007913129639935 |

####  int ç±»å‹

int æ˜¯æœ‰ç¬¦å·æ•´æ•°ï¼Œå…¶ä¸­ int256 ä¸ int ç›¸åŒï¼Œæ¨èä½¿ç”¨ int256ï¼› 8 ä½åˆ° 256 ä½çš„å¸¦ç¬¦å·æ•´å‹æ•°ã€‚8 çš„å€æ•°ã€‚

- `int8`: æœ€å°å€¼æ˜¯ `-(2**8/2)`ï¼Œæœ€å¤§å€¼æ˜¯ `(2**8/2)-1`
  - `int8`: æœ€å°å€¼æ˜¯ `-128`ï¼Œæœ€å¤§å€¼æ˜¯ `127`
- `int256`: æœ€å°å€¼æ˜¯ `-(2**256/2)`ï¼Œæœ€å¤§å€¼æ˜¯ `(2**256/2)-1`
- å¯ä»¥ä½¿ç”¨ `type(int8).max` è·å–è¯¥ç±»å‹çš„æœ€å¤§å€¼
- å¯ä»¥ä½¿ç”¨ `type(int8).min` è·å–è¯¥ç±»å‹çš„æœ€å°å€¼

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Data {
    // int
    int256 public i1 = 123;
    int256 public i2 = -123;
    int8 public i8Max = type(int8).max; // 127 => (2**8/2)-1
    int8 public i8Min = type(int8).min; // -128  => - 2**8/2
    //  57896044618658097711785492504343953926634992332820282019728792003956564819967
    int256 public i256Max = type(int256).max;
    // -57896044618658097711785492504343953926634992332820282019728792003956564819968
    int256 public i256Min = type(int256).min;
}
```

**è®¡ç®— int çš„æœ€å¤§å€¼å’Œæœ€å°å€¼**

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Data {
    int8 public i008Max = type(int8).max;
    int16 public i016Max = type(int16).max;
    int24 public i024Max = type(int24).max;
    int32 public i032Max = type(int32).max;
    int40 public i040Max = type(int40).max;
    int48 public i048Max = type(int48).max;
    int56 public i056Max = type(int56).max;
    int64 public i064Max = type(int64).max;
    int72 public i072Max = type(int72).max;
    int80 public i080Max = type(int80).max;
    int88 public i088Max = type(int88).max;
    int96 public i096Max = type(int96).max;
    int104 public i104Max = type(int104).max;
    int112 public i112Max = type(int112).max;
    int120 public i120Max = type(int120).max;
    int128 public i128Max = type(int128).max;
    int136 public i136Max = type(int136).max;
    int144 public i144Max = type(int144).max;
    int152 public i152Max = type(int152).max;
    int160 public i160Max = type(int160).max;
    int168 public i168Max = type(int168).max;
    int176 public i176Max = type(int176).max;
    int184 public i184Max = type(int184).max;
    int192 public i192Max = type(int192).max;
    int200 public i200Max = type(int200).max;
    int208 public i208Max = type(int208).max;
    int216 public i216Max = type(int216).max;
    int224 public i224Max = type(int224).max;
    int232 public i232Max = type(int232).max;
    int240 public i240Max = type(int240).max;
    int248 public i248Max = type(int248).max;
    int256 public i256Max = type(int256).max;
}
```

æ‰€æœ‰ int ç»“æœå¦‚ä¸‹ï¼š

| intN   | æœ€å°å€¼                                                                         | æœ€å¤§å€¼                                                                        |
| ------ | ------------------------------------------------------------------------------ | ----------------------------------------------------------------------------- |
| int8   | -128                                                                           | 127                                                                           |
| int16  | -32768                                                                         | 32767                                                                         |
| int24  | -8388608                                                                       | 8388607                                                                       |
| int32  | -2147483648                                                                    | 2147483647                                                                    |
| int40  | -549755813888                                                                  | 549755813887                                                                  |
| int48  | -140737488355328                                                               | 140737488355327                                                               |
| int56  | -36028797018963968                                                             | 36028797018963967                                                             |
| int64  | -9223372036854775808                                                           | 9223372036854775807                                                           |
| int72  | -2361183241434822606848                                                        | 2361183241434822606847                                                        |
| int80  | -604462909807314587353088                                                      | 604462909807314587353087                                                      |
| int88  | -154742504910672534362390528                                                   | 154742504910672534362390527                                                   |
| int96  | -39614081257132168796771975168                                                 | 39614081257132168796771975167                                                 |
| int104 | -10141204801825835211973625643008                                              | 10141204801825835211973625643007                                              |
| int112 | -2596148429267413814265248164610048                                            | 2596148429267413814265248164610047                                            |
| int120 | -664613997892457936451903530140172288                                          | 664613997892457936451903530140172287                                          |
| int128 | -170141183460469231731687303715884105728                                       | 170141183460469231731687303715884105727                                       |
| int136 | -43556142965880123323311949751266331066368                                     | 43556142965880123323311949751266331066367                                     |
| int144 | -11150372599265311570767859136324180752990208                                  | 11150372599265311570767859136324180752990207                                  |
| int152 | -2854495385411919762116571938898990272765493248                                | 2854495385411919762116571938898990272765493247                                |
| int160 | -730750818665451459101842416358141509827966271488                              | 730750818665451459101842416358141509827966271487                              |
| int168 | -187072209578355573530071658587684226515959365500928                           | 187072209578355573530071658587684226515959365500927                           |
| int176 | -47890485652059026823698344598447161988085597568237568                         | 47890485652059026823698344598447161988085597568237567                         |
| int184 | -12259964326927110866866776217202473468949912977468817408                      | 12259964326927110866866776217202473468949912977468817407                      |
| int192 | -3138550867693340381917894711603833208051177722232017256448                    | 3138550867693340381917894711603833208051177722232017256447                    |
| int200 | -803469022129495137770981046170581301261101496891396417650688                  | 803469022129495137770981046170581301261101496891396417650687                  |
| int208 | -205688069665150755269371147819668813122841983204197482918576128               | 205688069665150755269371147819668813122841983204197482918576127               |
| int216 | -52656145834278593348959013841835216159447547700274555627155488768             | 52656145834278593348959013841835216159447547700274555627155488767             |
| int224 | -13479973333575319897333507543509815336818572211270286240551805124608          | 13479973333575319897333507543509815336818572211270286240551805124607          |
| int232 | -3450873173395281893717377931138512726225554486085193277581262111899648        | 3450873173395281893717377931138512726225554486085193277581262111899647        |
| int240 | -883423532389192164791648750371459257913741948437809479060803100646309888      | 883423532389192164791648750371459257913741948437809479060803100646309887      |
| int248 | -226156424291633194186662080095093570025917938800079226639565593765455331328   | 226156424291633194186662080095093570025917938800079226639565593765455331327   |
| int256 | -57896044618658097711785492504343953926634992332820282019728792003956564819968 | 57896044618658097711785492504343953926634992332820282019728792003956564819967 |

**é—®é¢˜**: ä¸ºä»€ä¹ˆ `uint8/int8`è‡³ `uint256/uint256` éƒ½æ˜¯ä»¥ 8 çš„å€æ•°é€’å¢ï¼Œä¸”æœ€å¤§å€¼æ˜¯ 256ã€‚
1 å­—èŠ‚æ˜¯ 8 ä½ï¼Œæ‰€ä»¥åé¢ 8,16,éƒ½éœ€è¦æ˜¯ 8 çš„æ•´æ•°å€ï¼Œint8 æ˜¯ 8 ä½ã€‚EVM ä¸ºåœ°å€è®¾ç½®çš„æœ€å¤§é•¿åº¦æ˜¯ 256 ä½ï¼Œæ‰€ä»¥æœ€å¤§å€¼æ˜¯`uint256/uint256`ã€‚

è®¡ç®—ä¸­æœ€å°ä¸€çº§çš„ä¿¡æ¯å•ä½æ˜¯ byte å’Œ bit: **å…¶ä¸­å­—èŠ‚(Byte)ä¸ºæœ€å°å­˜å‚¨å®¹é‡å•ä½**ï¼Œ**ä½(bit)æ˜¯æœ€å°å‚¨å­˜ä¿¡æ¯çš„å•ä½,ä¹Ÿè¢«ç§°ä¸ºæœ€å°çš„æ•°æ®ä¼ è¾“å•ä½**ï¼›ä¸€ä¸ªä½å°±ä»£è¡¨ä¸€ä¸ª 0 æˆ– 1ï¼ˆå³äºŒè¿›åˆ¶ï¼‰ï¼›æ¯ 8 ä¸ª bit(ç®€å†™ä¸º bï¼‰ç»„æˆä¸€ä¸ªå­—èŠ‚ Byteï¼ˆç®€å†™ä¸º Bï¼‰ï¼›æ‰€ä»¥ `uint256` å’Œ `bytes32` å¯ä»¥è½¬æ¢

- `bytes1 å¯¹åº” uint8`
- `bytes2 å¯¹åº” uint16`
- ...
- `bytes32 å¯¹åº” uint256`

**é—®é¢˜**: ä¸ºä»€ä¹ˆ int8 çš„å–å€¼èŒƒå›´æ˜¯-128~127 å‘¢ï¼Ÿä¸ºä»€ä¹ˆ `uint256` çš„æœ€å¤§å€¼æ˜¯ `2**256 -1`ï¼Œè€Œä¸æ˜¯ `2**256` å‘¢ï¼Ÿ

1 å­—èŠ‚æ˜¯ 8 ä½ï¼Œint8 æ˜¯ 8 ä½ï¼ŒäºŒè¿›åˆ¶è¡¨ç¤ºä¸º`0000 0000`è‡³`1000 0000`ï¼Œç¬¬ä¸€ä½æ˜¯ç¬¦å·ä½;ç¬¬ä¸€ä½ä¸º 0 æ˜¯æ­£å€¼ï¼Œç¬¬ä¸€ä½ä¸º 1 æ˜¯è´Ÿå€¼ï¼›å› ä¸º int8 æ€»å…±èƒ½å¤Ÿè¡¨ç¤º 2 çš„ 8 æ¬¡æ–¹ï¼Œæ‰€ä»¥å¸¦ç¬¦å·çš„æ­£å€¼ä¸º 128 ä¸ªæ•°ï¼Œè´Ÿå€¼ä¸º 128 ä¸ªæ•°ï¼›

è®¡ç®—æœºé‡Œæ˜¯å°† 0 ç®—åœ¨æ­£å€¼å†…ï¼Œè´Ÿå€¼çš„èŒƒå›´è¿˜æ˜¯-128ï¼›ä½†æ˜¯ **0 ä¸æ˜¯æ­£æ•°ä¹Ÿä¸æ˜¯è´Ÿæ•°**ï¼Œæ‰€ä»¥æ­£å€¼èŒƒå›´å°‘äº†ä¸€ä¸ªä½ç½®ï¼Œå°±å‰© 127 ä¸ªä½ç½®äº†ã€‚

**é—®é¢˜**: å­—èŠ‚ & bit & åå…­è¿›åˆ¶æ•°å­—å…³ç³»

- bytes1 æ˜¯æŒ‡ 1 ä¸ªå­—èŠ‚ï¼Œ1 ä¸ªå­—èŠ‚å¯ä»¥è¡¨ç¤ºæˆ 2 ä¸ªè¿ç»­çš„ 16 è¿›åˆ¶æ•°å­—ã€‚æœ€å¤§å€¼æ˜¯ `0xff`
- bytes1 æ˜¯æŒ‡ 1 ä¸ªå­—èŠ‚ï¼Œ1 ä¸ªå­—èŠ‚å¯ä»¥è¡¨ç¤ºæˆ 8 ä¸ªè¿ç»­çš„ bit æ•°å­—ã€‚æœ€å¤§å€¼æ˜¯ `11111111`
  - `bytes1` ç­‰äºä¸¤ä½è¿ç»­çš„åå…­è¿›åˆ¶æ•°å­— `0xXX`
- 8 ä¸ª bit æœ€å¤§å€¼æ˜¯ `11111111`,8 ä¸ª bit å¯¹åº” 2 ä¸ªè¿ç»­çš„åå…­è¿›åˆ¶æ•°å­—ï¼Œæœ€å¤§æ˜¯ `0xff`;
  - `uint8` ç­‰äºä¸¤ä½è¿ç»­çš„åå…­è¿›åˆ¶æ•°å­— `0xXX`

####  checked æ¨¡å¼

âš ï¸: åœ¨ Solidity ä¹‹å‰çš„ç‰ˆæœ¬ä¸­ï¼Œå½“å¯¹æ— é™åˆ¶æ•´æ•°æ‰§è¡Œç®—æœ¯è¿ç®—ï¼Œå…¶ç»“æœè¶…å‡ºç»“æœç±»å‹çš„èŒƒå›´ï¼Œè¿™æ˜¯å°±å‘ç”Ÿäº†ä¸Šæº¢å‡ºæˆ–ä¸‹æº¢å‡ºã€‚åœ¨ Solidity 0.8.0 ä¹‹å‰ï¼Œç®—æœ¯è¿ç®—æ€»æ˜¯ä¼šåœ¨å‘ç”Ÿæº¢å‡ºçš„æƒ…å†µä¸‹è¿›è¡Œâ€œæˆªæ–­â€ï¼Œè€Œä¸æ˜¯æŠ›å‡ºå¼‚å¸¸ã€‚è¿™å°±ä¼šå¯¼è‡´ä¸€äº›éº»çƒ¦çš„äº‹æƒ…ï¼Œå¯èƒ½å¯¼è‡´æœªçŸ¥çš„é”™è¯¯ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸å¾—ä¸é å¼•å…¥é¢å¤–æ£€æŸ¥åº“æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼ˆæœ€å¸¸è§çš„å¦‚ OpenZepplin çš„ SafeMathï¼‰

è€Œä» `Solidity 0.8.0` å¼€å§‹ï¼Œæ‰€æœ‰çš„ç®—æœ¯è¿ç®—é»˜è®¤å°±ä¼šè¿›è¡Œæº¢å‡ºæ£€æŸ¥ï¼Œé¢å¤–å¼•å…¥åº“å°†ä¸å†å¿…è¦ã€‚0.8.0 å¼€å§‹ï¼Œç®—æœ¯è¿ç®—æœ‰ä¸¤ç§è®¡ç®—æ¨¡å¼ï¼šä¸€ç§æ˜¯`checked`ï¼ˆæ£€æŸ¥ï¼‰æ¨¡å¼ï¼Œå¦ä¸€ç§æ˜¯ `unchecked`ï¼ˆä¸æ£€æŸ¥ï¼‰æ¨¡å¼ã€‚

é»˜è®¤æƒ…å†µä¸‹ï¼Œç®—æœ¯è¿ç®—åœ¨ `checked` æ¨¡å¼ä¸‹ï¼Œå³éƒ½ä¼šè¿›è¡Œæº¢å‡ºæ£€æŸ¥ï¼Œå¦‚æœç»“æœè½åœ¨å–å€¼èŒƒå›´ä¹‹å¤–ï¼Œè°ƒç”¨ä¼šé€šè¿‡ å¤±è´¥å¼‚å¸¸ å›é€€ã€‚

ä½ ä¹Ÿå¯ä»¥é€šè¿‡ `unchecked{ ... }` åˆ‡æ¢åˆ° â€œuncheckedâ€æ¨¡å¼ï¼Œæ›´å¤šå¯å‚è€ƒ `unchecked` .

####  unchecked éæ£€æŸ¥æ¨¡å¼

å¦‚æœä¾ç„¶æƒ³è¦ä¹‹å‰â€œæˆªæ–­â€çš„æ•ˆæœï¼Œè€Œä¸æ˜¯æŠ›å‡ºå¼‚å¸¸é”™è¯¯ï¼Œé‚£ä¹ˆå¯ä»¥ä½¿ç”¨ `unchecked{}` ä»£ç å—ï¼š

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract C {
    uint256 public a = type(uint256).max;
    uint8 public b = 1;

    function f1() public view returns (uint256) {
        // å‡æ³•æº¢å‡ºä¼šè¿”å›â€œæˆªæ–­â€çš„ç»“æœ
        unchecked {
            return a + b;
        }
    }

    function f2() public view returns (uint256) {
        unchecked {
            return a + 2;
        }
    }

    function g() public view returns (uint256) {
        // æº¢å‡ºä¼šæŠ›å‡ºå¼‚å¸¸
        return a + b;
    }
}
```

è°ƒç”¨ `g()` ä¼šè§¦å‘å¤±è´¥å¼‚å¸¸ï¼Œ è°ƒç”¨ `f1()/f2()` åˆ†åˆ«æ˜¯æˆªæ–­æ•ˆæœ,

âš ï¸: `unchecked` ä»£ç å—å¯ä»¥åœ¨ä»£ç å—ä¸­çš„ä»»ä½•ä½ç½®ä½¿ç”¨ï¼Œä½†ä¸å¯ä»¥æ›¿ä»£æ•´ä¸ªå‡½æ•°ä»£ç å—ï¼ŒåŒæ ·ä¸å¯ä»¥åµŒå¥—ã€‚åˆ‡æ­¤è®¾ç½®ä»…å½±å“è¯­æ³•ä¸Šä½äº `unchecked` å—å†…çš„è¯­å¥ã€‚ åœ¨å—ä¸­è°ƒç”¨çš„å‡½æ•°ä¸ä¼šæ­¤å½±å“ã€‚

âš ï¸: ä¸ºé¿å…æ­§ä¹‰ï¼Œä¸èƒ½åœ¨ unchecked å—ä¸­ä½¿ç”¨ `_;`, è¯¥è¡¨ç¤ºæ–¹æ³•ä»…ç”¨äºå‡½æ•°ä¿®æ”¹å™¨ã€‚

##### è§¦å‘æº¢å‡ºæ£€æŸ¥çš„è¿ç®—ç¬¦

ä¸‹é¢çš„è¿™ä¸ªè¿ç®—æ“ä½œç¬¦ä¼šè¿›è¡Œæº¢å‡ºæ£€æŸ¥ï¼Œå¦‚æœä¸Šæº¢å‡ºæˆ–ä¸‹æº¢ä¼šè§¦å‘å¤±è´¥å¼‚å¸¸ã€‚ å¦‚æœåœ¨éæ£€æŸ¥æ¨¡å¼ä»£ç å—ä¸­ä½¿ç”¨ï¼Œå°†ä¸ä¼šå‡ºç°é”™è¯¯:

`++`, `--`, `+`, `å‡ -`, `è´Ÿ -`, `*`, `/`, `%`, `**`

`+=`,`-=`, `*=`, `/=`, `%=`

##### é™¤ `0`ï¼ˆæˆ–`é™¤ 0å–æ¨¡`ï¼‰

**âš ï¸ è­¦å‘Š**: é™¤ `0`ï¼ˆæˆ–`é™¤ 0å–æ¨¡`ï¼‰çš„å¼‚å¸¸æ˜¯ä¸èƒ½è¢« `unchecked` å¿½ç•¥çš„ã€‚ä¼šå‘ç”Ÿ `Panic` é”™è¯¯ã€‚

```
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.17;

contract C {
    uint256 public a = type(uint256).max;

    function f1() public view returns (uint256) {
        unchecked {
            return a / 0;
        }
    }

    function f2() public view returns (uint256) {
        unchecked {
            return a % 0;
        }
    }
}
```

##### ä½è¿ç®—ä¸ä¼šæ‰§è¡Œä¸Šæº¢æˆ–ä¸‹æº¢æ£€æŸ¥

**âš ï¸ æ³¨è§£**: ä½è¿ç®—ä¸ä¼šæ‰§è¡Œä¸Šæº¢æˆ–ä¸‹æº¢æ£€æŸ¥ã€‚ è¿™åœ¨ä½¿ç”¨ä½ç§»ä½(`<<`, `>>`, `<<=`, `>>=`)æ¥ä»£æ›¿æ•´æ•°é™¤æ³•å’Œ 2 æŒ‡æ•°æ—¶å°¤å…¶æ˜æ˜¾ã€‚ ä¾‹å¦‚ `type(uint256).max << 3` ä¸ä¼šå›é€€ï¼Œè€Œ `type(uint256).max + 1` ä¼šå¤±è´¥å›é€€ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract C {
    uint256 public a = type(uint256).max;
    uint8 public b = 1;

    function g1() public view returns (uint256) {
        return a + b;
    }

    function g2() public view returns (uint256) {
        return a << 3;
    }
}
```

##### -int å€¼éœ€è¦æ³¨æ„

**æ³¨è§£** `int x = type(int).min; -x;` ä¸­çš„ç¬¬ 2 å¥ä¼šæº¢å‡ºï¼Œå› ä¸ºè´Ÿæ•°çš„èŒƒå›´æ¯”æ­£æ•´æ•°çš„èŒƒå›´å¤§ 1ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract C {
    int256 x = type(int256).min;
    int256 y = -1;

    function fn1() public view returns (int256) {
        unchecked {
            return -x;
        }
    }

    // æº¢å‡º
    function fn2() public view returns (int256) {
        return -x;
    }

    function fn3() public view returns (int256) {
        return -y;
    }
}
```

æ˜¾å¼ç±»å‹è½¬æ¢å°†å§‹ç»ˆæˆªæ–­å¹¶ä¸”ä¸ä¼šå¯¼è‡´å¤±è´¥çš„æ–­è¨€ï¼Œä½†æ˜¯ä»æ•´æ•°åˆ°æšä¸¾ç±»å‹çš„è½¬æ¢ä¾‹å¤–ã€‚

##### æ˜¾å¼ç±»å‹è½¬æ¢

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract C {
    uint256 public a = type(uint256).max;
    uint8 public b = uint8(a);
}
```

### Integer æ•´æ•°å­—é¢å¸¸é‡

####  æ•´æ•°å­—é¢å¸¸é‡ä¸­ç”¨`_`å¢åŠ å¯è¯»æ€§

ä¸ºäº†æé«˜å¯è¯»æ€§å¯ä»¥åœ¨æ•°å­—ä¹‹é—´åŠ ä¸Šä¸‹åˆ’çº¿ã€‚ ä¾‹å¦‚ï¼Œåè¿›åˆ¶ `123_000`ï¼Œåå…­è¿›åˆ¶ `0x2eff_abde`ï¼Œç§‘å­¦åè¿›åˆ¶è¡¨ç¤º `1_2e12` éƒ½æ˜¯æœ‰æ•ˆçš„ã€‚

éœ€è¦æ³¨æ„ä»¥ä¸‹å‡ ç‚¹ï¼š

- ä¸‹åˆ’çº¿ä»…å…è®¸åœ¨ä¸¤ä½æ•°ä¹‹é—´ï¼Œå¹¶ä¸”ä¸å…è®¸ä¸‹åˆ’çº¿è¿ç»­å‡ºç°ã€‚
- æ·»åŠ åˆ°æ•°å­—æ–‡å­—ä¸­ä¸‹åˆ’çº¿æ²¡æœ‰é¢å¤–çš„è¯­ä¹‰ï¼Œä»…ä»…åªæ˜¯ä¸ºäº†å¯è¯»æ€§.
- ä¸‹åˆ’çº¿ä¼šè¢«ç¼–è¯‘å™¨å¿½ç•¥ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo{
    uint public count1 = 123_456_789; // 23503 gas
    uint public count2 = 123_456_789; // 23493 gas
    uint public count3 = 123456789; // 23537 gas
    int public count4 = -123456789; // 23559 gas
    int public count5 = -123_456_789; // 23471 gas
}
```

é€šè¿‡æµ‹è¯•å‘ç°ï¼Œå¸¦æœ‰`_`æ•°å­—çš„å˜é‡ï¼Œè¯»å–æ—¶å€™èŠ±è´¹ gas æ›´å°‘

####  å­—é¢å¸¸é‡æ”¯æŒä»»æ„ç²¾åº¦

æ•°å€¼å­—é¢å¸¸é‡è¡¨è¾¾å¼æœ¬èº«æ”¯æŒä»»æ„ç²¾åº¦ï¼Œç›´åˆ°è¢«è½¬æ¢æˆäº†éå¸¸é‡ç±»å‹ï¼ˆä¾‹å¦‚ï¼Œåœ¨å¸¸é‡å˜é‡è¡¨è¾¾å¼ä¹‹å¤–æœ‰è¿ç®—ï¼Œæˆ–å‘ç”Ÿäº†æ˜¾ç¤ºè½¬æ¢ï¼‰ã€‚ è¿™æ„å‘³ç€åœ¨æ•°å€¼å¸¸é‡è¡¨è¾¾å¼ä¸­, è®¡ç®—ä¸ä¼šæº¢å‡ºè€Œé™¤æ³•ä¹Ÿä¸ä¼šæˆªæ–­ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    uint8 public a = (2**800 + 1) - 2**800;
    uint8 public b = 0.5 * 8;
}
```

`(2**800 + 1) - 2**800` çš„ç»“æœæ˜¯å­—é¢å¸¸é‡ 1 ï¼ˆå±äº uint8 ç±»å‹ï¼‰ï¼Œå°½ç®¡è®¡ç®—çš„ä¸­é—´ç»“æœå·²ç»è¶…è¿‡äº† ä»¥å¤ªåŠè™šæ‹Ÿæœºçš„æœºå™¨å­—é•¿åº¦ã€‚ æ­¤å¤–ï¼Œ `.5 * 8` çš„ç»“æœæ˜¯æ•´å‹ `4` ï¼ˆå°½ç®¡æœ‰éæ•´å‹å‚ä¸äº†è®¡ç®—ï¼‰ã€‚

âš ï¸: æ•° å€¼å­—é¢å¸¸é‡è¡¨è¾¾å¼åªè¦åœ¨éå­—é¢å¸¸é‡è¡¨è¾¾å¼ä¸­ä½¿ç”¨å°±ä¼šè½¬æ¢æˆéå­—é¢å¸¸é‡ç±»å‹ã€‚ åœ¨ä¸‹é¢çš„ä¾‹å­ä¸­ï¼Œå°½ç®¡æˆ‘ä»¬çŸ¥é“ b çš„å€¼æ˜¯ä¸€ä¸ªæ•´æ•°ï¼Œä½† `2.5 + a` è¿™éƒ¨åˆ†è¡¨è¾¾å¼å¹¶ä¸è¿›è¡Œç±»å‹æ£€æŸ¥ï¼Œå› æ­¤ç¼–è¯‘ä¸èƒ½é€šè¿‡ã€‚

```
uint128 a = 1;
uint128 b = 2.5 + a + 0.5;
```

####  é™¤æ³•æˆªæ–­

æ³¨æ„é™¤æ³•æˆªæ–­: åœ¨æ™ºèƒ½åˆçº¦ä¸­ï¼Œåœ¨ å­—é¢å¸¸é‡ ä¼šä¿ç•™ç²¾åº¦ï¼ˆä¿ç•™å°æ•°ä½ï¼‰ã€‚

æ•´æ•°çš„é™¤æ³•ä¼šè¢«æˆªæ–­ï¼ˆä¾‹å¦‚ï¼š`1/4` ç»“æœä¸º 0ï¼‰,ä½†æ˜¯ä½¿ç”¨å­—é¢é‡çš„æ–¹å¼ä¸ä¼šè¢«æˆªæ–­

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract IntegerTest {
    function test1() public pure returns (uint256, uint256) {
        uint256 a = 1;
        uint256 b = 4;
        uint256 c1 = (1 / 4) * 4; // 1 => æœªæˆªæ–­
        uint256 c2 = (a / b) * b; // 0 => æˆªæ–­
        return (c1, c2);
    }

    function test2() public pure returns (int256, int256) {
        int256 a = -1;
        int256 b = -4;
        int256 c1 = (-1 / -4) * (-4); // -1 => æœªæˆªæ–­
        int256 c2 = (a / b) * b; // 0 => æˆªæ–­
        return (c1, c2);
    }
}
```

æ³¨é‡Š: è¡¨è¾¾å¼ `type(int).min / (-1)` æ˜¯ä»…æœ‰çš„æ•´é™¤ä¼šå‘ç”Ÿå‘ä¸Šæº¢å‡ºçš„æƒ…å†µã€‚ åœ¨ç®—æœ¯æ£€æŸ¥æ¨¡å¼ä¸‹ï¼Œè¿™ä¼šè§¦å‘ä¸€ä¸ªå¤±è´¥å¼‚å¸¸ï¼Œåœ¨æˆªæ–­æ¨¡å¼ä¸‹ï¼Œè¡¨è¾¾å¼çš„å€¼å°†æ˜¯ `type(int).min` ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    function test1() public pure returns (int256 a) {
        a = type(int256).min / (-2);
    }

    // VM error: revert.
    function test2() public pure returns (int256 a) {
        a = type(int256).min / (-1);
    }

    function test3() public pure returns (int256 a) {
        unchecked {
            a = type(int256).min / (-1);
        }
    }
}
```

####  ä¼˜å…ˆä½¿ç”¨è¾ƒå°ç±»å‹è®¡ç®—

è™½ç„¶å¤§å¤šæ•°è¿ç®—ç¬¦åœ¨å­—é¢å¸¸é‡è¿ç®—æ—¶éƒ½ä¼šäº§ç”Ÿä¸€ä¸ªå­—é¢å¸¸é‡è¡¨è¾¾å¼ï¼Œä½†æœ‰ä¸€äº›è¿ç®—ç¬¦å¹¶ä¸éµå¾ªè¿™ç§æ¨¡å¼ï¼š

- ä¸‰å…ƒè¿ç®—ç¬¦ `(... ? ... : ...)`,
- æ•°ç»„ä¸‹æ ‡è®¿é—® (`<array>[<index>]`).

ä½ å¯èƒ½è®¤ä¸ºåƒ`255 + (true ? 1 : 0)` æˆ– `255 + [1, 2, 3][0]` è¿™æ ·çš„è¡¨è¾¾å¼ç­‰åŒäºç›´æ¥ä½¿ç”¨ 256 å­—é¢å¸¸é‡ã€‚ ä½†äº‹å®ä¸Šï¼Œå®ƒä»¬æ˜¯åœ¨ `uint8` ç±»å‹ä¸­è®¡ç®—çš„ï¼Œä¼šæº¢å‡ºã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    // VM error: revert.
    function testA1() public pure returns (uint256 a) {
        a = 255 + (true ? 1 : 0);
    }

    function testA2() public pure returns (uint256 a) {
        a = (true ? 1 : 0) + 255;
    }

    // VM error: revert.
    function testB1() public pure returns (uint256 a) {
        a = 255 + [1, 2, 3][0];
    }

    function testB2() public pure returns (uint256 a) {
        a = [1, 2, 3][0] + 255;
    }

    function testA3() public pure returns (uint256 a) {
        a = 255 + uint256(true ? 1 : 0);
    }

    function testB3() public pure returns (uint256 a) {
        a = 255 + uint256([1, 2, 3][0]);
    }
}
```

### Fixed å®šé•¿æµ®ç‚¹å‹

Solidity è¿˜æ²¡æœ‰å®Œå…¨æ”¯æŒå®šé•¿æµ®ç‚¹å‹ã€‚

å¯ä»¥å£°æ˜å®šé•¿æµ®ç‚¹å‹çš„å˜é‡ï¼Œä½†ä¸èƒ½ç»™å®ƒä»¬èµ‹å€¼æˆ–æŠŠå®ƒä»¬èµ‹å€¼ç»™å…¶ä»–å˜é‡ã€‚ã€‚

å¯ä»¥é€šè¿‡ç”¨æˆ·å®šä¹‰çš„å€¼ç±»å‹çš„ wrap / unwrap æ¥æ¨¡æ‹Ÿå‡ºæ¥ï¼Œåé¢ä»‹ç»ç”¨æˆ·è‡ªå®šä¹‰ç±»å‹æ—¶å€™ä¼šä»‹ç»ã€‚

`fixed / ufixed`ï¼šè¡¨ç¤ºå„ç§å¤§å°çš„æœ‰ç¬¦å·å’Œæ— ç¬¦å·çš„å®šé•¿æµ®ç‚¹å‹ã€‚ åœ¨å…³é”®å­— `ufixedMxN` å’Œ `fixedMxN` ä¸­ï¼Œ`M` è¡¨ç¤ºè¯¥ç±»å‹å ç”¨çš„ä½æ•°ï¼Œ`N` è¡¨ç¤ºå¯ç”¨çš„å°æ•°ä½æ•°ã€‚ `M` å¿…é¡»èƒ½æ•´é™¤ 8ï¼Œå³ 8 åˆ° 256 ä½ã€‚ `N` åˆ™å¯ä»¥æ˜¯ä» 0 åˆ° 80 ä¹‹é—´çš„ä»»æ„æ•°ã€‚

### BytesN å®šé•¿å­—èŠ‚æ•°ç»„

å®šä¹‰æ–¹å¼ `bytesN`ï¼Œå…¶ä¸­ N å¯å– `1~32` ä¸­çš„ä»»æ„æ•´æ•°;

bytes1 ä»£è¡¨åªèƒ½å­˜å‚¨ä¸€ä¸ªå­—èŠ‚ã€‚

- âš ï¸ æ³¨æ„ï¼šä¸€æ—¦å£°æ˜ï¼Œå…¶å†…éƒ¨çš„å­—èŠ‚é•¿åº¦ä¸å¯ä¿®æ”¹ï¼Œå†…éƒ¨å­—èŠ‚ä¸å¯ä¿®æ”¹ã€‚
- âš ï¸ æ³¨æ„ï¼š`bytes32` å’Œ `bytes` æ˜¯ä¸åŒçš„ã€‚
  - `bytesN`: æ˜¯å®šé•¿çš„å­—èŠ‚æ•°ç»„ï¼Œæ˜¯å€¼ç±»å‹
  - `bytes`: æ˜¯å˜é•¿å­—èŠ‚æ•°ç»„ï¼Œæ˜¯å¼•ç”¨ç±»å‹ã€‚

####  æ™®é€šèµ‹å€¼

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    // å›ºå®šé•¿åº¦çš„å­—èŠ‚æ•°ç»„
    bytes1 public a1 = 0x61;
    bytes2 public a2 = 0x6100;
    bytes4 public a3 = 0x61000000;
    bytes6 public a4 = 0x416e62616e67;
    bytes7 public a5 = 0x416e62616e6700;
    bytes8 public a6 = 0x416e62616e670000;
    bytes16 public a7 = 0x416e62616e6700000000000000000000;
    bytes32 public a8 =
        0x416e62616e670000000000000000000000000000000000000000000000000000;
}
```

æ³¨æ„è¿™é‡Œ `bytes32` å’Œ `bytes` æ˜¯ä¸åŒçš„ã€‚`bytes` æ˜¯å˜é•¿å­—èŠ‚æ•°ç»„ï¼Œæ˜¯å¼•ç”¨ç±»å‹ã€‚

####  ä½¿ç”¨å­—ç¬¦ä¸²èµ‹å€¼

è­¦å‘Š:å­—ç¬¦ä¸²å­—é¢å¸¸é‡åœ¨èµ‹å€¼ç»™ bytesN æ—¶è¢«è§£é‡Šä¸ºåŸå§‹çš„å­—èŠ‚å½¢å¼ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    bytes1 public b1 = "a";
    bytes2 public b2 = "a";
    bytes4 public b3 = "a";
    bytes6 public b4 = "Anbang";
    bytes7 public b5 = "Anbang";
    bytes8 public b6 = "Anbang";
    bytes16 public b7 = "Anbang";
    bytes32 public b8 = "Anbang";
}
```

####  å±æ€§

- `length` ï¼ˆåªè¯»ï¼‰
  - è¿”å›å­—èŠ‚ä¸ªæ•°ï¼Œå¯ä»¥é€šè¿‡ç´¢å¼•è¯»å–å¯¹åº”ç´¢å¼•çš„å­—èŠ‚ã€‚
- ç´¢å¼•è®¿é—®: `bytesN[index]`
  - index å–å€¼èŒƒå›´`[0, N]`ï¼Œå…¶ä¸­ N è¡¨ç¤ºé•¿åº¦ã€‚
  - å¦‚æœ `x` æ˜¯ `bytesI` ç±»å‹ï¼Œé‚£ä¹ˆ `x[k]` ï¼ˆå…¶ä¸­ 0 <= k < Iï¼‰è¿”å›ç¬¬ k ä¸ªå­—èŠ‚ï¼ˆåªè¯»ï¼‰ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    // å›ºå®šé•¿åº¦çš„å­—èŠ‚æ•°ç»„
    bytes1 public a1 = 0x61;
    bytes2 public a2 = 0x6100;

    // length
    uint256 public n1 = a1.length;
    uint256 public n2 = a2.length;

    // ç´¢å¼•
    function getIndex(uint8 index_) public view returns(bytes1){
        return a2[index_];
    }

    // ä¸ä¿®å¯ä»¥ä¿®æ”¹
    // function setIndex(uint8 index_,bytes1 value_) public view{
    //     a2[index_] = value_;
    // }
}
```

### å­—ç¬¦ä¸²å­—é¢å¸¸é‡åŠç±»å‹

å­—ç¬¦ä¸²å­—é¢å¸¸é‡åªèƒ½åŒ…å«å¯æ‰“å°çš„ ASCII å­—ç¬¦ï¼Œè¿™æ„å‘³ç€ä»–æ˜¯ä»‹äº 0x20 å’Œ 0x7E ä¹‹é—´çš„å­—ç¬¦ã€‚

å­—ç¬¦ä¸²å­—é¢å¸¸é‡æ˜¯æŒ‡ç”±åŒå¼•å·æˆ–å•å¼•å·å¼•èµ·æ¥çš„å­—ç¬¦ä¸²ï¼ˆ `"foo"` æˆ–è€… `'bar'`ï¼‰;

####  å­—ç¬¦ä¸²å­—é¢é‡æ˜¯å€¼ç±»å‹

è½¬æ¢: å’Œæ•´æ•°å­—é¢å¸¸é‡ä¸€æ ·ï¼Œå­—ç¬¦ä¸²å­—é¢å¸¸é‡çš„ç±»å‹ä¹Ÿå¯ä»¥å‘ç”Ÿæ”¹å˜ï¼Œå®ƒä»¬å¯ä»¥éšå¼åœ°è½¬æ¢æˆ`bytes1`ï¼Œâ€¦â€¦ï¼Œ `bytes32`ï¼Œå¦‚æœåˆé€‚çš„è¯ï¼Œè¿˜å¯ä»¥è½¬æ¢æˆ `bytes` ä»¥åŠ `string`ã€‚

æ¯”å¦‚ `bytes1 public a8 = "a";` å’Œ `bytes2 public b2 = "a";`ã€‚å­—ç¬¦ä¸²å­—é¢å¸¸é‡åœ¨èµ‹å€¼ç»™ `bytesN` æ—¶è¢«è§£é‡Šä¸º**åŸå§‹çš„å­—èŠ‚å½¢å¼**ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    bytes1 public b1 = "a";
    string public b2 = "a";
}
```

####  è½¬ä¹‰å­—ç¬¦

ä½†æ˜¯æˆ‘ä»¬å†™ç‰¹æ®Šå­—ç¬¦ä¸²æ—¶å€™é‡åˆ°ä¸€ä¸ªé—®é¢˜ï¼Œæ¯”å¦‚æˆ‘æƒ³è¾“å‡ºä¸€ä¸ª `fo"o`å’Œ`fo'o` çš„å­—ç¬¦ä¸²å°±å¾ˆéš¾å¼„ï¼Œå› ä¸ºè«è®¤ä¸º`"`å’Œ`'` æ˜¯å­—ç¬¦ä¸²çš„ç»“å°¾ã€‚å¦‚æœæƒ³è¦è¾“å‡ºè¿™ç§ç‰¹æ®Šçš„å­—ç¬¦ä¸²ï¼Œå°±éœ€è¦è½¬ä¹‰å­—ç¬¦äº†ã€‚

æ­¤å¤–ï¼Œå­—ç¬¦ä¸²å­—é¢å¸¸é‡æ”¯æŒä¸‹é¢çš„è½¬ä¹‰å­—ç¬¦ï¼š

- `\'` (å•å¼•å·)
- `\"` (åŒå¼•å·)
- `\\` (åæ–œæ )
- `\<newline>` (è½¬ä¹‰å®é™…æ¢è¡Œ)
- `\b` (é€€æ ¼)
- `\f` (æ¢é¡µ)
- `\n` (æ¢è¡Œç¬¦)
- `\r` (å›è½¦)
- `\t` (æ ‡ç­¾ tab)
- `\v` (å‚ç›´æ ‡ç­¾)
- `\xNN` (åå…­è¿›åˆ¶è½¬ä¹‰ï¼Œè§ä¸‹æ–‡)
- `\uNNNN` (unicode è½¬ä¹‰ï¼Œè§ä¸‹æ–‡)

`\xNN` è¡¨ç¤ºä¸€ä¸ª 16 è¿›åˆ¶å€¼ï¼Œæœ€ç»ˆè½¬æ¢æˆåˆé€‚çš„å­—èŠ‚ï¼Œè€Œ `\uNNNN` è¡¨ç¤º Unicode ç¼–ç å€¼ï¼Œæœ€ç»ˆä¼šè½¬æ¢ä¸º UTF-8 çš„åºåˆ—ã€‚

é—®ç­”é¢˜:ä¸‹é¢å­—ç¬¦ä¸²é•¿åº¦ä¸ºå¤šå°‘å­—èŠ‚ï¼Ÿ

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    string public a1 = "\n\"'\\abc\
def";
    bytes32 public a2 = "\n\"'\\abc\
def";
}
```

å­—ç¬¦ä¸²é•¿åº¦ä¸ºåä¸ªå­—èŠ‚ï¼Œå®ƒä»¥æ¢è¡Œç¬¦å¼€å¤´ï¼Œåè·ŸåŒå¼•å·ï¼Œå•å¼•å·ï¼Œåæ–œæ å­—ç¬¦ï¼Œä»¥åŠï¼ˆæ²¡æœ‰åˆ†éš”ç¬¦ï¼‰å­—ç¬¦åºåˆ— `"'\abcdef` ã€‚

####  ç”¨ç©ºæ ¼åˆ†å¼€çš„å­—ç¬¦ä¸²

ç”¨ç©ºæ ¼åˆ†å¼€çš„ `"foo" "bar"` ç­‰æ•ˆäº `"foobar"`,

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    string public a = "a" "b";
}
```

### Unicode å­—é¢å¸¸é‡

å¸¸è§„å­—ç¬¦ä¸²æ–‡å­—åªèƒ½åŒ…å« ASCIIï¼Œè€Œ Unicode æ–‡å­—ï¼ˆä»¥å…³é”®å­— unicode ä¸ºå‰ç¼€ï¼‰å¯ä»¥åŒ…å«ä»»ä½•æœ‰æ•ˆçš„ UTF-8 åºåˆ—ã€‚ å®ƒä»¬è¿˜æ”¯æŒä¸è½¬ä¹‰åºåˆ—å®Œå…¨ç›¸åŒçš„å­—ç¬¦ä½œä¸ºå¸¸è§„å­—ç¬¦ä¸²æ–‡å­—ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    string  public a = unicode"åŒå¿—ä»¬å¥½";
}
```

### åå…­è¿›åˆ¶å­—é¢å¸¸é‡

åå…­è¿›åˆ¶å­—é¢å¸¸é‡ä»¥å…³é”®å­— `hex` æ‰“å¤´ï¼Œåé¢ç´§è·Ÿç€ç”¨å•å¼•å·æˆ–åŒå¼•å·å¼•èµ·æ¥çš„å­—ç¬¦ä¸²ï¼ˆä¾‹å¦‚ï¼Œ`hex"001122FF"` ï¼‰ã€‚ å­—ç¬¦ä¸²çš„å†…å®¹å¿…é¡»æ˜¯ä¸€ä¸ªåå…­è¿›åˆ¶çš„å­—ç¬¦ä¸²ï¼Œå®ƒä»¬çš„å€¼å°†ä½¿ç”¨äºŒè¿›åˆ¶è¡¨ç¤ºã€‚

####  åŸºæœ¬ç”¨æ³•

å®ƒä»¬çš„å†…å®¹å¿…é¡»æ˜¯åå…­è¿›åˆ¶æ•°å­—ï¼Œå¯ä»¥é€‰æ‹©ä½¿ç”¨å•ä¸ªä¸‹åˆ’çº¿ä½œä¸ºå­—èŠ‚è¾¹ç•Œåˆ†éš”ç¬¦ã€‚ **å­—é¢å¸¸é‡çš„å€¼å°†æ˜¯åå…­è¿›åˆ¶åºåˆ—çš„äºŒè¿›åˆ¶è¡¨ç¤ºå½¢å¼**ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    string public a1 = "a";
    bytes1 public a2 = "a";
    bytes1 public a3 = 0x61;
    bytes1 public a4 = hex"61";
}
```

####  ç”¨ç©ºæ ¼åˆ†å¼€çš„åå…­è¿›åˆ¶å­—é¢å¸¸é‡

ç”¨ç©ºæ ¼åˆ†éš”çš„å¤šä¸ªåå…­è¿›åˆ¶å­—é¢å¸¸é‡è¢«åˆå¹¶ä¸ºä¸€ä¸ªå­—é¢å¸¸é‡ï¼š `hex"61" hex"61"` ç­‰åŒäº `hex"6161"`

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    bytes2 public a = hex"61" hex"61";
}
```

åå…­è¿›åˆ¶å­—é¢å¸¸é‡è·Ÿ å­—ç¬¦ä¸²å­—é¢å¸¸é‡ å¾ˆç±»ä¼¼ï¼Œå…·æœ‰ç›¸åŒçš„è½¬æ¢è§„åˆ™

### Enum:æšä¸¾

`enum` æ˜¯ä¸€ç§ç”¨æˆ·è‡ªå®šä¹‰ç±»å‹ï¼Œç”¨äºè¡¨ç¤ºå¤šç§çŠ¶æ€ï¼Œæšä¸¾å¯ç”¨æ¥åˆ›å»ºç”±ä¸€å®šæ•°é‡çš„â€œå¸¸é‡å€¼â€æ„æˆçš„è‡ªå®šä¹‰ç±»å‹ã€‚ä¸»è¦ä½œç”¨æ˜¯ç”¨äºé™åˆ¶æŸä¸ªäº‹åŠ¡çš„æœ‰é™é€‰æ‹©ã€‚æ¯”å¦‚å°†å’–å•¡çš„å®¹é‡å¤§å°é™åˆ¶ä¸ºï¼šå¤§ã€ä¸­ã€å°ï¼Œè¿™å°†ç¡®ä¿ä»»ä½•äººä¸èƒ½è´­ä¹°å…¶ä»–å®¹é‡çš„å’–å•¡ï¼Œåªèƒ½åœ¨è¿™é‡Œé€‰æ‹©ã€‚

æšä¸¾é»˜è®¤å€¼æ˜¯ç¬¬ä¸€ä¸ªæˆå‘˜ï¼Œæ‰€ä»¥æšä¸¾ç±»å‹è‡³å°‘éœ€è¦ä¸€ä¸ªæˆå‘˜ï¼Œæšä¸¾ä¸èƒ½å¤šäº 256 ä¸ªæˆå‘˜ã€‚æšä¸¾é»˜è®¤çš„ç±»å‹ä¸º `uint8`ï¼Œå½“æšä¸¾æ•°è¶³å¤Ÿå¤šæ—¶ï¼Œå®ƒä¼šè‡ªåŠ¨å˜æˆ `uint16`..ç­‰å˜å¤§ã€‚å¯ä»¥é€šè¿‡ remix éƒ¨ç½²åï¼Œå‡½æ•°çš„è¾“å…¥å€¼å†…æŸ¥çœ‹ç±»å‹ `uint8` / `uint16`

- æšä¸¾ç±»å‹ï¼Œè¿”å›å€¼æ˜¯ç´¢å¼•ï¼Œé»˜è®¤å€¼æ˜¯ 0;
- æšä¸¾ç±»å‹çš„é»˜è®¤å€¼æ˜¯ç¬¬ä¸€ä¸ªå€¼ã€‚
  - æšä¸¾ç±»å‹ enum è‡³å°‘åº”è¯¥æœ‰ä¸€åæˆå‘˜ã€‚
- è®¾ç½®çš„æ—¶å€™ï¼Œå¯ä»¥è®¾ç½®ä¸ºç´¢å¼•ï¼Œä¹Ÿå¯ä»¥å¯¹åº”çš„æšä¸¾åç§°;
- æšä¸¾ç±»å‹ enum å¯ä»¥ä¸æ•´æ•°è¿›è¡Œæ˜¾å¼è½¬æ¢ï¼Œä½†ä¸èƒ½è¿›è¡Œéšå¼è½¬æ¢ã€‚
  - æ˜¾ç¤ºè½¬æ¢ä¼šåœ¨è¿è¡Œæ—¶æ£€æŸ¥æ•°å€¼èŒƒå›´ï¼Œå¦‚æœä¸åŒ¹é…ï¼Œå°†ä¼šå¼•èµ·å¼‚å¸¸ã€‚

**ä¾‹å­**:è€ƒè™‘ä¸€ä¸ªé™åˆ¶ï¼Œå°†äº¤æ˜“çš„çŠ¶æ€é™åˆ¶ä¸ºï¼š`None`/`Pending`/`Shiped`/`Completed`/`Rejected`/`Canceled` è¿™å‡ ç§ã€‚è¿™å°†ç¡®ä¿äº¤æ˜“çŠ¶æ€ä»…åœ¨åˆ—å‡ºçš„çŠ¶æ€å†…ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Enum {
    // æšä¸¾ç±»å‹çš„é»˜è®¤å€¼æ˜¯ç¬¬ä¸€ä¸ªå€¼ã€‚
    // ç»“æ„
    enum Status {
        None, // 0
        Pending, // 1
        Shiped,// 2
        Completed,
        Rejected,
        Canceled
    }
    // å˜é‡
    Status public status;

    // è®¾ç½®ç´¢å¼•å€¼
    function set(Status _status) external {
        status = _status;
    }

    // ç”±äºæšä¸¾ç±»å‹ä¸å±äº |ABI| çš„ä¸€éƒ¨åˆ†ï¼Œå› æ­¤å¯¹äºæ‰€æœ‰æ¥è‡ª Solidity å¤–éƒ¨çš„è°ƒç”¨ï¼Œ
    // "getStatus" çš„ç­¾åä¼šè‡ªåŠ¨è¢«æ”¹æˆ "getStatus() returns (uint8)"ã€‚
    function getStatus() public view returns (Status) {
        return status;
    }

    function getDefaultStatus() public view returns (uint256) {
        return uint256(status);
    }

    // è®¾ç½®
    function ship() external {
        status = Status.Shiped;
    }

    // æ¢å¤ä¸º0
    function reset() external {
        delete status;
    }
}
```

å¾ˆå¤šäººæ„Ÿè§‰ enum å¾ˆå°‘ç”¨ï¼Œä¸€æ˜¯å› ä¸ºåº”ç”¨åœºæ™¯ç¡®å®æ¯”è¾ƒçª„ï¼ŒäºŒæ˜¯å› ä¸ºå¯ä»¥è¢«å…¶ä»–æ•°æ®ç±»å‹æ‰€ä»£æ›¿ï¼›ä½†æŒ‰ç…§ç¼–ç è§„èŒƒï¼Œé™åˆ¶é€‰æ‹©èŒƒå›´åœºæ™¯ï¼Œé™¤äº† bool ä»¥å¤–çš„ï¼Œæ¨èä½¿ç”¨ enum ç±»å‹æ¥å®šä¹‰ã€‚

æšä¸¾æ˜¯æ˜¾ç¤ºæ‰€æœ‰æ•´å‹ç›¸äº’è½¬æ¢ï¼Œä½†ä¸å…è®¸éšå¼è½¬æ¢ã€‚ä»æ•´å‹æ˜¾å¼è½¬æ¢æšä¸¾ï¼Œä¼šåœ¨è¿è¡Œæ—¶æ£€æŸ¥æ•´æ•°æ—¶å€™åœ¨æšä¸¾èŒƒå›´å†…ï¼Œå¦åˆ™ä¼šå¯¼è‡´å¼‚å¸¸ï¼ˆ Panic å¼‚å¸¸ ï¼‰ã€‚

æšä¸¾è¿˜å¯ä»¥åœ¨åˆçº¦æˆ–åº“å®šä¹‰ä¹‹å¤–çš„æ–‡ä»¶çº§åˆ«ä¸Šå£°æ˜ã€‚

####  å±æ€§

æ•°æ®è¡¨ç¤ºä¸ï¼šé€‰é¡¹ä»`0`å¼€å§‹çš„æ— ç¬¦å·æ•´æ•°å€¼è¡¨ç¤ºã€‚

####  æ–¹æ³•

- delete
- `type(NameOfEnum).min`
- `type(NameOfEnum).max`

ä½¿ç”¨ `type(NameOfEnum).min` å’Œ `type(NameOfEnum).max` ä½ å¯ä»¥å¾—åˆ°ç»™å®šæšä¸¾çš„æœ€å°å€¼å’Œæœ€å¤§å€¼ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Enum {
    // æšä¸¾ç±»å‹çš„é»˜è®¤å€¼æ˜¯ç¬¬ä¸€ä¸ªå€¼ã€‚
    enum Status {
        None,//0
        Pending,//1
        Shiped,//2
        Completed,//3
        Rejected,//4
        Canceled// 5
    }

    function getLargestValue() public pure returns (Status) {
        return type(Status).max;
    }

    function getSmallestValue() public pure returns (Status) {
        return type(Status).min;
    }
}
```

### ç”¨æˆ·å®šä¹‰çš„å€¼ç±»å‹

Solidity å…è®¸åœ¨ä¸€ä¸ªåŸºæœ¬çš„å€¼ç±»å‹ä¸Šåˆ›å»ºä¸€ä¸ªé›¶æˆæœ¬çš„æŠ½è±¡ã€‚è¿™ç±»ä¼¼äºä¸€ä¸ªåˆ«åï¼Œä½†æœ‰æ›´ä¸¥æ ¼çš„ç±»å‹è¦æ±‚ã€‚

ç”¨æˆ·å®šä¹‰å€¼ç±»å‹ä½¿ç”¨ `type UserType is DefaultType` æ¥å®šä¹‰ã€‚

å…¶ä¸­ `UserType` æ˜¯æ–°å¼•å…¥çš„ç±»å‹çš„åç§°ï¼Œ `DefaultType` å¿…é¡»æ˜¯å†…ç½®çš„å€¼ç±»å‹ï¼ˆâ€åº•å±‚ç±»å‹â€ï¼‰ã€‚è‡ªå®šä¹‰ç±»å‹çš„å€¼çš„æ•°æ®è¡¨ç¤ºåˆ™ç»§æ‰¿è‡ªåº•å±‚ç±»å‹ï¼Œå¹¶ä¸” ABI ä¸­ä¹Ÿä½¿ç”¨åº•å±‚ç±»å‹ã€‚

âš ï¸: ç”¨æˆ·å®šä¹‰çš„ç±»å‹ `UserType` æ²¡æœ‰ä»»ä½•è¿ç®—ç¬¦æˆ–ç»‘å®šæˆå‘˜å‡½æ•°ã€‚å³ä½¿æ˜¯æ“ä½œç¬¦ `==` ä¹Ÿæ²¡æœ‰å®šä¹‰ã€‚ä¹Ÿä¸å…è®¸ä¸å…¶ä»–ç±»å‹è¿›è¡Œæ˜¾å¼å’Œéšå¼è½¬æ¢ã€‚

####  æ–¹æ³•

- `UserType.wrap()`: ç”¨æ¥ä»åº•å±‚ç±»å‹è½¬æ¢åˆ°è‡ªå®šä¹‰ç±»å‹
- `UserType.unwrap()`: ä»è‡ªå®šä¹‰ç±»å‹è½¬æ¢åˆ°åº•å±‚ç±»å‹ã€‚

####  ä¾‹å­

æ¡ˆä¾‹ï¼šä¸€ä¸ª 18 ä½å°æ•°ã€256 bit çš„æµ®ç‚¹ç±»å‹

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

// ä½¿ç”¨ç”¨æˆ·å®šä¹‰çš„å€¼ç±»å‹è¡¨ç¤º 18 ä½å°æ•°ã€256 bitçš„æµ®ç‚¹ç±»å‹ã€‚
type UFixed256x18 is uint256;

/// åœ¨ UFixed256x18 ä¸Šè¿›è¡Œæµ®ç‚¹æ“ä½œçš„ç²¾ç®€åº“ã€‚
library FixedMath {
    uint constant multiplier = 10**18;

    /// ä¸¤ä¸ª UFixed256x18 æ•°ç›¸åŠ ï¼Œ
    /// æº¢å‡ºæ—¶æ¢å¤ï¼Œä¾èµ–äº uint256 ä¸Šçš„æ£€æŸ¥ç®—æœ¯
     function add(UFixed256x18 a, UFixed256x18 b) internal pure returns (UFixed256x18) {
        return UFixed256x18.wrap(UFixed256x18.unwrap(a) + UFixed256x18.unwrap(b));
    }
    /// å°† UFixed256x18 å’Œ uint256 ç›¸ä¹˜.
    /// æº¢å‡ºæ—¶æ¢å¤ï¼Œä¾èµ–äº uint256 ä¸Šçš„æ£€æŸ¥ç®—æœ¯
     function mul(UFixed256x18 a, uint256 b) internal pure returns (UFixed256x18) {
        return UFixed256x18.wrap(UFixed256x18.unwrap(a) * b);
    }
    ///  UFixed256x18 å‘ä¸‹å–æ•´.
    /// @return ä¸è¶…è¿‡ `a` çš„æœ€å¤§æ•´æ•°ã€‚
    function floor(UFixed256x18 a) internal pure returns (uint256) {
        return UFixed256x18.unwrap(a) / multiplier;
    }
    /// å°† uint256 è½¬æ¢ä¸ºç›¸åŒå€¼çš„ UFixed256x18ã€‚
    /// å¦‚æœæ•´æ•°å¤ªå¤§ï¼Œåˆ™è¿˜åŸã€‚
    function toUFixed256x18(uint256 a) internal pure returns (UFixed256x18) {
        return UFixed256x18.wrap(a * multiplier);
    }
}
contract Test {
    uint256 a = 1;
    uint256 b = 2;

    function testAdd() external view returns (UFixed256x18) {
        return FixedMath.add(FixedMath.toUFixed256x18(a), FixedMath.toUFixed256x18(b));
    }
    function testMul() external view returns (UFixed256x18) {
        return FixedMath.mul(FixedMath.toUFixed256x18(a),b);
    }
}
```

æ³¨æ„ `UFixed256x18.wrap` å’Œ `FixedMath.toUFixed256x18` çš„ç­¾åç›¸åŒï¼Œä½†æ‰§è¡Œçš„æ˜¯ä¸¤ä¸ªå®Œå…¨ä¸åŒçš„æ“ä½œï¼š

- `UFixed256x18.wrap` å‡½æ•°è¿”å›ä¸€ä¸ªä¸è¾“å…¥çš„æ•°æ®è¡¨ç¤ºç›¸åŒçš„è‡ªå®šä¹‰å€¼ç±»å‹ï¼ˆ`UFixed256x18`ï¼‰ã€‚
- `FixedMath.toUFixed256x18`åˆ™è¿”å›ä¸€ä¸ªå…·æœ‰ç›¸åŒæ•°å€¼çš„ `UFixed256x18` ã€‚

## å€¼ç±»å‹:åœ°å€ç±»å‹

åœ°å€åˆ†ä¸ºå¤–éƒ¨åœ°å€å’Œåˆçº¦åœ°å€ï¼Œæ¯ä¸ªåœ°å€éƒ½æœ‰**ä¸€å—æŒä¹…åŒ–å†…å­˜åŒº**ç§°ä¸ºå­˜å‚¨ã€‚

åœ°å€ç±»å‹ä¹Ÿæ˜¯å€¼ç±»å‹ï¼Œå› ä¸ºæ¯”è¾ƒç‰¹æ®Šï¼Œæ‰€ä»¥å•ç‹¬æ‹¿å‡ºæ¥è®²ã€‚åœ°å€ç±»å‹æ˜¯ Solidity è¯­è¨€ç‹¬æœ‰çš„æ•°æ®ç±»å‹ï¼Œè¡¨ç¤ºä»¥å¤ªåŠçš„åœ°å€ç±»å‹ã€‚ç”¨ address è¡¨ç¤ºåœ°å€ï¼Œé•¿åº¦æ˜¯ 20 ä¸ªå­—èŠ‚ï¼›æˆ‘ä»¬æ—¥å¸¸ä½¿ç”¨çš„æ˜¯åå…­è¿›åˆ¶çš„åœ°å€æ ¼å¼ï¼Œæ¯”å¦‚: `0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac`ï¼›è¿™ç§ç±»å‹é€‚åˆå­˜å‚¨åˆçº¦åœ°å€æˆ–å¤–éƒ¨åœ°å€ã€‚

### åœ°å€å­—é¢å¸¸é‡

é€šå¸¸çš„åœ°å€ç±»å‹æ˜¯ `0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac` è¿™æ ·çš„ [checksum address](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md)ï¼Œã€‚ è€Œæ²¡æœ‰é€šè¿‡æ ¡éªŒæµ‹è¯•, é•¿åº¦åœ¨ 39 åˆ° 41 ä¸ªæ•°å­—ä¹‹é—´çš„åå…­è¿›åˆ¶å­—é¢å¸¸é‡ï¼Œä¼šäº§ç”Ÿä¸€ä¸ªé”™è¯¯, æ¯”å¦‚ `0XFFD0D80C48F6C3C5387B7CFA7AA03970BDB926AC` å°±æ˜¯ä¸€ä¸ªé”™è¯¯ address ç±»å‹ã€‚ä¼šæç¤ºæ­£ç¡®çš„åœ°å€ï¼Œä¹Ÿå¯ä»¥å°†åœ°å€è¾“å…¥åˆ° [etherscan](https://cn.etherscan.com/address/0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926AC) è·å–ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    // This looks like an address but has an invalid checksum.
    // Correct checksummed address: "0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac".
    // If this is not used as an address, please prepend '00'.
    // For more information please see
    // https://docs.soliditylang.org/en/develop/types.html#address-literals
    // address public a1 = 0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926AC;

    // ç›´æ¥åœ¨æç¤ºç§è·å–åˆ°æ­£ç¡®çš„ checksummed addressï¼Œ
    // ä¹Ÿå¯ä»¥åœ¨ etherscan ç§å¾—åˆ° checksum åœ°å€ã€‚
    address public a2 = 0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac;
}
```

å¦‚æœä¸æ€•éº»çƒ¦ï¼Œè¿˜å¯ä»¥é€šè¿‡ SDK æ¥è‡ªå·±è½¬æ¢ [web3.utils.toChecksumAddress(address)](https://web3js.readthedocs.io/en/v1.8.0/web3-utils.html#tochecksumaddress)

### address/uint/bytes32 ä¹‹é—´çš„è½¬æ¢

- 1 å­—èŠ‚ 8 ä½ï¼Œä¸€ä¸ª address æ˜¯ 20 ä¸ªå­—èŠ‚ï¼Œæ˜¯ 160 ä½ï¼Œæ‰€ä»¥ **address å¯ä»¥ç”¨ uint160 è¡¨ç¤º**ã€‚
- 1 å­—èŠ‚å¯ä»¥è¡¨ç¤ºä¸ºä¸¤ä¸ªè¿ç»­çš„åå…­è¿›åˆ¶æ•°å­—ï¼Œæ‰€ä»¥ **address å¯ä»¥ç”¨è¿ç»­çš„ 40 ä¸ªåå…­è¿›åˆ¶æ•°å­—è¡¨ç¤º**ã€‚
- address ä¸å…è®¸ä»»ä½•ç®—æ•°æ“ä½œ
- `address` å…è®¸å’Œ `uint160`ã€ `æ•´å‹å­—é¢å¸¸é‡`ã€`bytes20` åŠ`åˆçº¦ç±»å‹`ç›¸äº’è½¬æ¢ã€‚
  - å¦‚æœå°†ä½¿ç”¨è¾ƒå¤§å­—èŠ‚æ•°ç»„ç±»å‹è½¬æ¢ä¸º `address` ï¼Œä¾‹å¦‚ `bytes32` ï¼Œé‚£ä¹ˆ `address` å°†è¢«æˆªæ–­ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    bytes32 public a =
        0x111122223333444455556666777788889999AAAABBBBCCCCDDDDEEEEFFFFCCCC;

    // 0x111122223333444455556666777788889999aAaa
    address public b = address(uint160(bytes20(a)));

    // 0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc
    address public c = address(uint160(uint256(a)));
}
```

âš ï¸ï¼šä¸ºäº†å‡å°‘è½¬æ¢æ­§ä¹‰ï¼Œæˆ‘ä»¬åœ¨è½¬æ¢ä¸­æ˜¾å¼æˆªæ–­å¤„ç†ã€‚ ä»¥ 32bytes å€¼ `0x111122223333444455556666777788889999AAAABBBBCCCCDDDDEEEEFFFFCCCC` ä¸ºä¾‹ï¼Œ å¦‚æœä½¿ç”¨ `address(uint160(bytes20(b)))` ç»“æœæ˜¯ `0x111122223333444455556666777788889999aAaa`ï¼Œ è€Œä½¿ç”¨ `address(uint160(uint256(b)))` ç»“æœæ˜¯ `0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc` ã€‚

æ³¨æ„ï¼Œç½‘ä¸Šå¾ˆå¤šåœ¨çº¿è½¬æ¢å·¥å…·å¾—åˆ°çš„ç»“æœå¹¶ä¸æ­£ç¡®ï¼Œæ¯”å¦‚: <https://tool.oschina.net/hexconvert/>

å¦‚ä¸‹ä¾‹å­è¿›è¡ŒçœŸå®è½¬æ¢ï¼š`_owner` åœ¨ä¸€äº›åœ¨çº¿çš„è½¯ä»¶å†…è½¬æ¢çš„ä¸æ­£ç¡®ï¼Œä¸Šé¢çš„ç½‘å€æœ‰ä¸ªå° BUGï¼Œè¾“å…¥åå…­è¿›åˆ¶æ•°æ®çš„æ—¶å€™ï¼Œä¸èƒ½å¸¦ `0x` å‰ç¼€ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract test {
    address _owner; // åå…­è¿›åˆ¶
    uint160 _ownerUint; // åè¿›åˆ¶

    constructor() {
        _owner = 0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac;
        _ownerUint = 1460450021995508802976443037013257463744970696364;
    }

    function toUint160() public view returns (uint160) {
        //è½¬æ¢10è¿›åˆ¶
        return uint160(_owner);
    }

    function toAddress() public view returns (address) {
        return address(_ownerUint);
    }
}
```

æ³¨æ„: è¿™é‡Œè¯´çš„åœ°å€æ˜¯ `0x123...` è¿™ç§åå…­è¿›åˆ¶çš„åœ°å€å…¬é’¥ï¼Œè€Œä¸æ˜¯åº”ç”¨å±‚çš„ `anbang.eth` è¿™ç§ ENS åœ°å€ã€‚è™½ç„¶åœ¨å¾ˆå¤šé’±åŒ…å¯ä»¥é€šè¿‡`anbang.eth`æ¥å‘`0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac`è½¬è´¦ï¼Œä½†ä»…ä»…æ˜¯åº”ç”¨å±‚çš„ä¸­è½¬æœåŠ¡ã€‚å…·ä½“å¯ä»¥åœ¨ [ä»¥å¤ªåŠæµè§ˆå™¨](https://etherscan.io/enslookup-search?search=anbang.eth),æˆ–è€…é’±åŒ…å†…è¾“å…¥ ENS åŸŸåæŸ¥çœ‹ä¸­è½¬é€»è¾‘.ï¼ˆENS æ˜¯ä¸€ç§åˆ«åï¼Œé™¤äº†åœ¨ä»¥å¤ªåŠç½‘ç»œå¯ä»¥ä½¿ç”¨ï¼Œåœ¨ imToken ç­‰é’±åŒ…å†…ï¼Œåœ¨ BTC ç½‘ç»œä¹Ÿå¯ä»¥ä½¿ç”¨ï¼Œå®ƒå¹¶ä¸æ˜¯åŒºå—é“¾çš„åº•å±‚ï¼Œè€Œæ˜¯åº”ç”¨å±‚ï¼‰

### ä¸¤ç§å½¢å¼çš„åœ°å€

åœ¨ç¬¬ä¸€ç« æ¥æ”¶ ETH é‚£ä¸€èŠ‚çš„ä¸‰ä¸ªå…³é”®å­—é‡Œï¼Œä¹Ÿä»‹ç»äº† payableï¼Œè¿™é‡Œå†æ¬¡è®²ä¸€ä¸‹åŠ æ·±å°è±¡ã€‚

- `address`ï¼šä¿å­˜ä¸€ä¸ª 20 å­—èŠ‚çš„å€¼ï¼ˆä»¥å¤ªåŠåœ°å€çš„å¤§å°ï¼‰ã€‚
- `address payable` ï¼šå¯æ”¯ä»˜åœ°å€ï¼Œä¸ `address` ç›¸åŒï¼Œä¸è¿‡æœ‰æˆå‘˜å‡½æ•° `transfer` å’Œ `send` ã€‚

å¦‚æœä½ éœ€è¦ `address` ç±»å‹çš„å˜é‡ï¼Œå¹¶è®¡åˆ’å‘é€ä»¥å¤ªå¸ç»™è¿™ä¸ªåœ°å€ï¼Œé‚£ä¹ˆå£°æ˜ç±»å‹ä¸º `address payable` å¯ä»¥æ˜ç¡®è¡¨è¾¾å‡ºä½ çš„éœ€æ±‚ã€‚ åŒæ ·ï¼Œå°½é‡æ›´æ—©å¯¹ä»–ä»¬è¿›è¡ŒåŒºåˆ†æˆ–è½¬æ¢ã€‚

è¿™ç§åŒºåˆ«èƒŒåçš„æ€æƒ³æ˜¯ `address payable` å¯ä»¥å‘å…¶å‘é€ä»¥å¤ªå¸ï¼Œè€Œä¸èƒ½å‘ä¸€ä¸ªæ™®é€šçš„ `address` å‘é€ä»¥å¤ªå¸ã€‚æ¯”å¦‚ï¼Œå®ƒå¯èƒ½æ˜¯ä¸€ä¸ªæ™ºèƒ½åˆçº¦åœ°å€ï¼Œå¹¶ä¸”ä¸æ”¯æŒæ¥æ”¶ä»¥å¤ªå¸ã€‚

####  ä¸¤ç§å½¢å¼çš„åœ°å€è½¬æ¢

å…è®¸ä» `address payable` åˆ° `address` çš„éšå¼è½¬æ¢ï¼Œè€Œä» `address` åˆ° `address payable` å¿…é¡»æ˜¾ç¤ºçš„ é€šè¿‡ `payable(<address>)` è¿›è¡Œè½¬æ¢ã€‚ä¹Ÿåªèƒ½é€šè¿‡ `payable(...)` è¡¨è¾¾å¼æŠŠ `address` ç±»å‹å’Œåˆçº¦ç±»å‹è½¬æ¢ä¸º `address payable`ã€‚

åœ¨ä»‹ç»åœ°å€ payable æ–¹æ³•æ—¶å€™ä¼šå…·ä½“ä»‹ç»ï¼Œè½¬æ¢çš„æ—¶å€™æ³¨æ„ä¸‹é¢ä¸¤ä¸ªç‚¹ï¼š

1. åªæœ‰èƒ½æ¥æ”¶ä»¥å¤ªå¸çš„åˆçº¦ç±»å‹ï¼Œæ‰èƒ½å¤Ÿè¿›è¡Œæ­¤è½¬æ¢ã€‚
   1. ä¾‹å¦‚åˆçº¦è¦ä¹ˆæœ‰ receive æˆ–å¯æ”¯ä»˜çš„å›é€€å‡½æ•°ã€‚
2. `payable(0)` æ˜¯æœ‰æ•ˆçš„ï¼Œè¿™æ˜¯æ­¤è§„åˆ™çš„ä¾‹å¤–ã€‚

### åœ°å€å±æ€§

address æ‹¥æœ‰å¦‚ä¸‹å±æ€§ï¼›

1. .balance : ä»¥ Wei ä¸ºå•ä½çš„ä½™é¢ã€‚

   ```
   <address>.balance    returns(uint256)
   ```

2. .code : åœ°å€ä¸Šçš„ä»£ç (å¯ä»¥ä¸ºç©º)

   ```
   <address>.code        returns(bytes memory)
   ```

3. .codehash : åœ°å€çš„ codehash

   ```
   <address>.codehash    returns(bytes32)
   ```

####  balance å±æ€§

è·å–åœ°å€çš„ä½™é¢ï¼Œwei å•ä½ã€‚å¦‚ä¸‹ä¾‹å­æ˜¯è·å–æŒ‡å®šåœ°å€çš„ ETH ä½™é¢ï¼Œå’Œå½“å‰è°ƒç”¨è€…çš„ä½™é¢ã€‚ï¼ˆåŸºäºå½“å‰ä½¿ç”¨çš„ç½‘ç»œï¼‰

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    function getBalance1(address addr) public view returns (uint256) {
        return addr.balance;
    }
    function getBalance2() external view returns (uint256) {
        return address(msg.sender).balance;
    }
}
```

å‡½æ•°å†…ä¸€èˆ¬ä¸åƒä¸Šé¢é‚£ä¹ˆç”¨ï¼Œæ›´å¤šçš„æ˜¯è·å–åˆçº¦æœ¬èº«çš„ ETH ä½™é¢;

**å¦‚ä½•è·å–åˆçº¦åœ°å€?**:åˆçº¦éƒ¨ç½²åï¼Œä¼šæœ‰ä¸€ä¸ªåˆçº¦åœ°å€; **æ‰€æœ‰åˆçº¦éƒ½å¯ä»¥è½¬æ¢ä¸º address ç±»å‹**ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    function returnContractAddress() external view returns (address) {
        return address(this);
    }
}
```

å› æ­¤å¯ä»¥ä½¿ç”¨ `address(this).balance` æŸ¥è¯¢å½“å‰åˆçº¦çš„ä½™é¢ï¼Œè·å–åˆçº¦æœ¬èº«çš„ ETH ä½™é¢å¦‚ä¸‹

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
    receive() external payable {}
}
```

âš ï¸: åœ¨ç‰ˆæœ¬ 0.5.0 ä¹‹å‰ï¼ŒSolidity å…è®¸é€šè¿‡åˆçº¦å®ä¾‹æ¥è®¿é—®åœ°å€çš„æˆå‘˜ï¼Œä¾‹å¦‚ `this.balance` ï¼Œä¸è¿‡ç°åœ¨ç¦æ­¢è¿™æ ·åšï¼Œå¿…é¡»æ˜¾å¼è½¬æ¢ä¸ºåœ°å€åè®¿é—®ï¼Œå¦‚ï¼š `address(this).balance` ã€‚

####  code å±æ€§

å¯ä»¥æŸ¥è¯¢ä»»ä½•æ™ºèƒ½åˆçº¦çš„éƒ¨ç½²ä»£ç ã€‚ä½¿ç”¨ `.code` æ¥è·å– EVM çš„å­—èŠ‚ç ï¼Œå…¶è¿”å› `bytes memory` ï¼Œå€¼å¯èƒ½æ˜¯ç©ºã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    function getCode() public view returns (bytes memory) {
        return address(this).code;
    }

    // å¤–éƒ¨åœ°å€ code å†…å®¹æ˜¯ç©ºï¼Œ
    // å¯ä»¥é€šè¿‡è¿™ä¸ªæ¥åˆ¤æ–­åœ°å€æ˜¯å¦ä¸ºåˆçº¦
    function getAdsCode(address a_) public view returns (bytes memory) {
        return address(a_).code;
    }
}
```

æ³¨æ„:åˆçº¦æ²¡æœ‰å®Œå…¨åˆ›å»ºï¼Œä¹Ÿå°±æ˜¯ constructor æ²¡æœ‰å®Œå…¨æ‰§è¡Œå®Œçš„æ—¶å€™ï¼Œcode ä¹Ÿæ˜¯ç©ºã€‚

ä¸‹é¢æ˜¯å‘ç³–æœçš„åˆçº¦ï¼Œåªå…è®¸ç”¨æˆ·çš„åœ°å€é¢†å–ï¼Œç¦æ­¢åˆçº¦åœ°å€ã€‚ç»“æœè¢«åˆçº¦åœ°å€è–…ç¾Šæ¯›äº†ã€‚

```
// å‘ç³–æœçš„åˆçº¦
contract A {
    uint256 giftValue = 666;
    mapping(address=>uint256) public gifts;

    function gift() public returns(uint256){
        bytes memory senderCode = getCode(msg.sender);
        require(senderCode.length==0,unicode"åªèƒ½ç”¨æˆ·é¢†å–ï¼Œè–…ç¾Šæ¯›çš„åˆçº¦æ»šï¼ï¼ï¼");
        gifts[msg.sender] = giftValue;
        return giftValue;
    }

    function getCode(address ads_) public view returns(bytes memory){
        return address(ads_).code;
    }
}

// è–…ç¾Šæ¯›çš„åˆçº¦
contract Test {
    A a;
    uint256 public target; // ä¿å­˜è–…ç¾Šæ¯›å¾—åˆ°çš„ç³–æœ
    constructor(address ads_){
        target = A(ads_).gift();
    }
}
```

####  codehash å±æ€§

ä½¿ç”¨ `.codehash` è·å¾—åˆçº¦ä»£ç çš„ `Keccak-256 å“ˆå¸Œå€¼` (ä¸º bytes32 )ã€‚

æ³¨æ„ï¼Œ `addr.codehash` æ¯”ä½¿ç”¨ `keccak256(addr.code)` æ›´ä¾¿å®œã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    function getCode() public view returns (bytes memory) {
        return address(this).code;
    }

    function getCodeByKeccak256() public view returns (bytes32) {
        return keccak256(address(this).code);
    }

    function getCodehash() public view returns (bytes32) {
        return address(this).codehash;
    }
}
```

### åœ°å€æ–¹æ³•

address æ‹¥æœ‰å¦‚ä¸‹æ–¹æ³•ï¼›

1. `address()`: å¯ä»¥å°†åœ°å€è½¬æ¢åˆ°åœ°å€ç±»å‹ã€‚
2. `payable()`: å°†æ™®é€šåœ°å€è½¬ä¸ºå¯æ”¯ä»˜åœ°å€ã€‚
3. `.transfer(uint256 amount)`: å°†ä½™é¢è½¬åˆ°å½“å‰åœ°å€ï¼ˆåˆçº¦åœ°å€è½¬è´¦ï¼‰
4. `.send(uint256 amount)`: å°†ä½™é¢è½¬åˆ°å½“å‰åœ°å€ï¼Œå¹¶**è¿”å›äº¤æ˜“æˆåŠŸçŠ¶æ€**ï¼ˆåˆçº¦åœ°å€è½¬è´¦ï¼‰
5. `.call(bytes memory)`: ç”¨ç»™å®šçš„æœ‰æ•ˆè½½è·ï¼ˆpayloadï¼‰å‘å‡ºä½çº§ `CALL` è°ƒç”¨ï¼Œå¹¶**è¿”å›äº¤æ˜“æˆåŠŸçŠ¶æ€å’Œè¿”å›æ•°æ®**ï¼ˆè°ƒç”¨åˆçº¦çš„æ–¹æ³•å¹¶è½¬è´¦ï¼‰
6. `.delegatecall(bytes memory)`: ç”¨ç»™å®šçš„æœ‰æ•ˆè½½è·ï¼ˆpayloadï¼‰å‘å‡ºä½çº§ `DELEGATECALL` è°ƒç”¨ï¼Œå¹¶**è¿”å›äº¤æ˜“æˆåŠŸçŠ¶æ€å’Œè¿”å›æ•°æ®**ï¼ˆè°ƒç”¨åˆçº¦çš„æ–¹æ³•å¹¶è½¬è´¦ï¼‰
7. `staticcall(bytes memory)`: ç”¨ç»™å®šçš„æœ‰æ•ˆè½½è·ï¼ˆpayloadï¼‰å‘å‡ºä½çº§ `STATICCALL` è°ƒç”¨ï¼Œå¹¶**è¿”å›äº¤æ˜“æˆåŠŸçŠ¶æ€å’Œè¿”å›æ•°æ®**ï¼ˆè°ƒç”¨åˆçº¦çš„æ–¹æ³•å¹¶è½¬è´¦ï¼‰

####  address()

**1.è·å–å½“å‰åˆçº¦åœ°å€**:

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Address {
    mapping(address => uint256) public balances; // ç”¨åœ¨ mapping ç»“æ„å†…

    // å­˜æ¬¾
    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    function getAddress() external view returns (address) {
        return address(this);
    }

    function getBalance1() external view returns (uint256) {
        return address(this).balance;
    }

    function getBalance2() external view returns (uint256) {
        return address(msg.sender).balance;
    }
}
```

**2.uint å€¼è½¬æ¢æˆåœ°å€**:

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    function getAddress()
        external
        pure
        returns (
            address,
            address,
            address,
            address,
            address
        )
    {
        return (address(0), address(1), address(3), address(6), address(9));
    }
}
```

è¿”å›ç»“æœå¦‚ä¸‹:

```
0: address: 0x0000000000000000000000000000000000000000
1: address: 0x0000000000000000000000000000000000000001
2: address: 0x0000000000000000000000000000000000000003
3: address: 0x0000000000000000000000000000000000000006
4: address: 0x0000000000000000000000000000000000000009
```

**3.è·å–å³å°†éƒ¨ç½²çš„åœ°å€**

è¿™æ˜¯ _uint å€¼è½¬æ¢æˆåœ°å€_ çš„ä¸€ç§åº”ç”¨ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    // è·å–å³å°†éƒ¨ç½²çš„åœ°å€
    function getAddress(bytes memory bytecode, uint256 _salt)
        external
        view
        returns (address)
    {
        bytes32 hash = keccak256(
            abi.encodePacked(
                bytes1(0xff), // å›ºå®šå­—ç¬¦ä¸²
                address(this), // å½“å‰å·¥å‚åˆçº¦åœ°å€
                _salt, // salt
                keccak256(bytecode) //éƒ¨ç½²åˆçº¦çš„ bytecode
            )
        );
        return address(uint160(uint256(hash)));
    }
}
```

####  payable()

æ³¨æ„ï¼šæ”¯ä»˜çš„æ—¶å€™ï¼Œåœ°å€å¿…é¡» `payable` ç±»å‹ï¼ä» `address` åˆ° `address payable` çš„è½¬æ¢ã€‚å¯ä»¥é€šè¿‡ `payable(x)` è¿›è¡Œ ï¼Œå…¶ä¸­ `x` å¿…é¡»æ˜¯ `address` ç±»å‹ã€‚

è®©æ™®é€šåœ°å€ä¸º payable æœ‰ä¸¤ç§æ–¹å¼

- æ–¹å¼ä¸€: å‚æ•°ä¸­ åœ°å€æ ‡æ³¨ address payable ,å¹¶ä¸”å‡½æ•°çŠ¶æ€å¯å˜æ€§æ ‡ä¸º `payable`;
  - è¿™ç§æ›´çœ gas (**æ¨è**)
- æ–¹å¼äºŒ: ä»…åœ¨å†…éƒ¨è¿›è¡Œ `payable(address)` æ˜¾ç¤ºè½¬æ¢

##### ä¾‹å­

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Payable {
    address payable public owner;

    constructor() {
        // ç›´æ¥èµ‹å€¼ä¼šæŠ¥é”™,å› ä¸º msg.sender ä¸æ˜¯ payable ç±»å‹çš„åœ°å€ã€‚
        // Type address is not implicitly convertible to expected type address payable.
        // owner = msg.sender;

        // ä½¿ç”¨ payable å‡½æ•°ï¼Œæ˜¾ç¤ºè½¬æ¢ä¸€ä¸‹å°±å¯ä»¥äº†ã€‚
        owner = payable(msg.sender);
    }

    // deposit1 æ²¡æœ‰ payable æ ‡ç¤ºï¼›å¦‚æœä¼ å…¥ETHå¸ï¼Œä¼šæŠ¥é”™
    // transact to Payable.deposit1 errored: VM error: revert.
    function deposit1() external {}

    // deposit2 æœ‰ payableï¼Œ æ‰€ä»¥å¯ä»¥å‘é€ETHåˆ°åˆçº¦
    function deposit2() external payable {}

    function getBalance() external view returns (uint256) {
        // ä½¿ç”¨ address(this) å°±å¯ä»¥åŒ…è£…å½“å‰åˆçº¦ï¼Œç„¶åå°±å¯ä»¥ä½¿ç”¨ .balance è·å–ä½™é¢äº†ã€‚
        return address(this).balance;
    }
}
```

**æ³¨æ„ç‚¹**:

- å¦‚æœçŠ¶æ€å˜é‡æ˜¯ `payable` ç±»å‹ï¼Œèµ‹å€¼çš„æ—¶å€™éœ€è¦ä½¿ç”¨ `payable()` è¿›è¡Œæ˜¾ç¤ºè½¬æ¢
- å¦‚æœå‡½æ•°æ²¡æœ‰ `payable` æ ‡ç¤ºï¼Œé‚£ä¹ˆè°ƒç”¨æ—¶å€™ä¸èƒ½å‘é€ç½‘ç»œä¸»å¸ã€‚
  - å¦‚æœå°è¯•è¿™ä¹ˆåšä¼šæ”¶åˆ°é”™è¯¯: `transact to Payable.functionName errored: VM error: revert.`

##### è½¬æ¢ 0 åœ°å€

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    function getAddress()
        external
        pure
        returns (
            address,
            address,
            address,
            address,
            address
        )
    {
        return (address(0), address(1), address(3), address(6), address(999));
    }

    function getPayaableAddress() external pure returns (address) {
        // Explicit type conversion not allowed from "int_const 1" to "address payable".
        // return payable(1);
        return payable(0);
    }
}
```

####  transfer()

å°†ä½™é¢è½¬åˆ°å½“å‰åœ°å€ï¼ˆåˆçº¦åœ°å€è½¬è´¦ï¼‰,è¯­æ³•å¦‚ä¸‹:

```
<address payable>.transfer(uint256 amount)
```

1. éœ€è¦ payable address
2. ä½¿ç”¨å›ºå®šï¼ˆä¸å¯è°ƒèŠ‚ï¼‰çš„ 2300 gas çš„çŸ¿å·¥è´¹ï¼Œé”™è¯¯ä¼š reverts ï¼ˆå›æ»šæ‰€æœ‰çŠ¶æ€ï¼‰
   1. 2300 gas è¶³å¤Ÿè½¬è´¦ï¼Œä½†æ˜¯å¦‚æœæ¥æ”¶åˆçº¦å†…çš„ `fallback` å’Œ `receive` å‡½æ•°æœ‰æ¶æ„ä»£ç ï¼Œå¤æ‚ä»£ç ã€‚å®¹æ˜“å¯¼è‡´ gas è€—å°½çš„é”™è¯¯ã€‚
3. å¤±è´¥æ—¶æŠ›å‡ºå¼‚å¸¸,
   1. å¦‚æœå½“å‰åˆçº¦çš„ä½™é¢ä¸å¤Ÿå¤šï¼Œåˆ™ `transfer` å‡½æ•°ä¼šæ‰§è¡Œå¤±è´¥ï¼Œæˆ–è€…å¦‚æœä»¥å¤ªè½¬ç§»è¢«æ¥æ”¶å¸æˆ·æ‹’ç»ï¼Œ `transfer` å‡½æ•°åŒæ ·ä¼šå¤±è´¥è€Œè¿›è¡Œå›é€€ã€‚
4. å¦‚æœç›®æ ‡åœ°å€æ˜¯ä¸€ä¸ªåˆçº¦ï¼Œé‚£ä¹ˆç›®æ ‡åˆçº¦å†…éƒ¨çš„ receive/fallback å‡½æ•°ä¼šéšç€è°ƒç”¨ `transfer`å‡½æ•°ä¸€èµ·æ‰§è¡Œï¼Œè¿™æ˜¯ EVM çš„ç‰¹æ€§ï¼Œæ²¡åŠæ³•é˜»æ­¢ã€‚

ä¾‹å­æ¼”ç¤º:

æ ¸å¿ƒ: `_to.transfer(200);`

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract SendEth {
    event Log(string funName, address from, uint256 value, bytes data);

    fallback() external payable {
        emit Log("fallback", msg.sender, msg.value, msg.data);
    }

    receive() external payable {
        emit Log("receive", msg.sender, msg.value, "");
    }

    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }

    // transfer :  åœ°å€å¿…é¡»ä¸º   payable ç±»å‹
    // æ–¹å¼ä¸€: å‚æ•°ä¸­ åœ°å€æ ‡æ³¨ address payable ,å¹¶ä¸”å‡½æ•°æ ‡æ³¨ payable; è¿™ç§æ›´çœ gas
    // 28767 gas
    function transfer1(address payable _to) external payable {
        _to.transfer(100);
    }

    // ä¹Ÿå¯ä»¥ åœ¨å†…éƒ¨è¿›è¡Œæ˜¾ç¤ºè½¬æ¢
    // æ–¹å¼äºŒ: ä»…åœ¨å†…éƒ¨è¿›è¡Œ payable(address) æ˜¾ç¤ºè½¬æ¢
    // 28813 gas
    function transfer2(address _to) external {
        payable(_to).transfer(200);
    }
}

```

####  send()

å°†ä½™é¢è½¬åˆ°å½“å‰åœ°å€ï¼Œå¹¶**è¿”å›äº¤æ˜“æˆåŠŸçŠ¶æ€**ï¼ˆåˆçº¦åœ°å€è½¬è´¦ï¼‰

```
<address payable>.send(uint256 amount) returns (bool)
```

`send` æ˜¯ `transfer` çš„ä½çº§ç‰ˆæœ¬ã€‚å¦‚æœæ‰§è¡Œå¤±è´¥ï¼Œå½“å‰çš„åˆçº¦ä¸ä¼šå› ä¸ºå¼‚å¸¸è€Œç»ˆæ­¢ã€‚`transfer` ç­‰ä»·äº`require(send())`

1. éœ€è¦ payable address
2. ä½¿ç”¨å›ºå®šï¼ˆä¸å¯è°ƒèŠ‚ï¼‰çš„ 2300 gas çš„çŸ¿å·¥è´¹ã€‚
   1. gas åŒ`transfer`ä¸€æ ·çš„æ˜¯ 2300 gas ï¼›è¶³å¤Ÿè½¬è´¦ï¼Œä½†æ˜¯å¦‚æœæ¥æ”¶åˆçº¦å†…çš„ `fallback` å’Œ `receive` å‡½æ•°æœ‰æ¶æ„ä»£ç ï¼Œå¤æ‚ä»£ç ã€‚å®¹æ˜“å¯¼è‡´ gas è€—å°½çš„é”™è¯¯ã€‚
3. å¤±è´¥æ—¶ä»…ä¼šè¿”å› `false`ï¼Œä¸ä¼šç»ˆæ­¢æ‰§è¡Œï¼ˆåˆçº¦åœ°å€è½¬è´¦ï¼‰;
   1. `send()` æ‰§è¡Œæœ‰ä¸€äº›é£é™©ï¼šä¸ºäº†ä¿è¯å®‰å…¨ï¼Œå¿…é¡»æ£€æŸ¥ send çš„è¿”å›å€¼ï¼Œå¦‚æœäº¤æ˜“å¤±è´¥ï¼Œä¼šå›é€€ä»¥å¤ªå¸ã€‚
4. è¡¥å……ï¼šsend ä¸ transfer å¯¹åº”ï¼Œä½† **send æ›´åº•å±‚**ã€‚å¦‚æœæ‰§è¡Œå¤±è´¥ï¼Œtransfer ä¸ä¼šå› å¼‚å¸¸åœæ­¢ï¼Œè€Œ send ä¼šè¿”å› falseã€‚transfer ç›¸å¯¹ send è¾ƒå®‰å…¨

ä¾‹å­æ¼”ç¤º:

æ ¸å¿ƒ: `bool success = _to.send(100);`

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract SendEth {
    event Log(string funName, address from, uint256 value, bytes data);

    fallback() external payable {
        emit Log("fallback", msg.sender, msg.value, msg.data);
    }

    receive() external payable {
        emit Log("receive", msg.sender, msg.value, "");
    }

    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }

    // 28791 gas
    function send1(address payable _to) external payable {
        bool success = _to.send(100);
        require(success, "Send Faied");
    }

    // 28793 gas
    function send2(address _to) external {
        bool success = payable(_to).send(100);
        require(success, "Send Faied");
    }
}
```

`.transfer(uint256 amount)` å¤±è´¥æ—¶æŠ›å‡ºå¼‚å¸¸, ç­‰ä»·äº`require(send())` ä½¿ç”¨å›ºå®šï¼ˆä¸å¯è°ƒèŠ‚ï¼‰çš„ 2300 gas çš„çŸ¿å·¥è´¹ï¼Œé”™è¯¯ä¼š reverts.

####  call/delegatecall/staticcall

ä¸ºäº†ä¸ä¸çŸ¥é“ ABI çš„åˆçº¦è¿›è¡Œäº¤äº’ï¼ŒSolidity æä¾›äº†å‡½æ•° `call`/`delegatecall`/`staticcall` ç›´æ¥æ§åˆ¶ç¼–ç ã€‚å®ƒä»¬éƒ½å¸¦æœ‰ä¸€ä¸ª `bytes memory` å‚æ•°å’Œè¿”å›æ‰§è¡Œ**æˆåŠŸçŠ¶æ€**ï¼ˆboolï¼‰å’Œ**æ•°æ®**ï¼ˆbytes memoryï¼‰ã€‚

å‡½æ•° `abi.encode`ï¼Œ`abi.encodePacked`ï¼Œ`abi.encodeWithSelector` å’Œ `abi.encodeWithSignature` å¯ç”¨äºç¼–ç ç»“æ„åŒ–æ•°æ®ã€‚

**å®ƒä»¬å¯ä»¥æ¥å—ä»»æ„ç±»å‹ï¼Œä»»æ„æ•°é‡çš„å‚æ•°**ã€‚è¿™äº›å‚æ•°ä¼šè¢«æ‰“åŒ…åˆ°ä»¥ 32 å­—èŠ‚ä¸ºå•ä½çš„è¿ç»­åŒºåŸŸä¸­å­˜æ”¾ã€‚å…¶ä¸­ä¸€ä¸ª**ä¾‹å¤–æ˜¯å½“ç¬¬ä¸€ä¸ªå‚æ•°è¢«ç¼–ç æˆæ­£å¥½ 4 ä¸ªå­—èŠ‚çš„æƒ…å†µ**ã€‚ åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¿™ä¸ªå‚æ•°åè¾¹ä¸ä¼šå¡«å……åç»­å‚æ•°ç¼–ç ï¼Œä»¥å…è®¸ä½¿ç”¨å‡½æ•°ç­¾åã€‚

ä¸‹é¢å…·ä½“çš„ä»‹ç»ä¸‰ç§ callã€‚

####  call()

ç”¨ç»™å®šçš„æœ‰æ•ˆè½½è·ï¼ˆpayloadï¼‰å‘å‡ºä½çº§ `CALL` è°ƒç”¨ï¼Œå¹¶**è¿”å›äº¤æ˜“æˆåŠŸçŠ¶æ€å’Œè¿”å›æ•°æ®**ï¼ˆè°ƒç”¨åˆçº¦çš„æ–¹æ³•å¹¶è½¬è´¦ï¼‰, æ ¼å¼å¦‚ä¸‹ï¼š

```
<address>.call(bytes memory) returns (bool, bytes memory)
```

1. ä½çº§ `CALL` è°ƒç”¨ï¼šä¸éœ€è¦ payable address, æ™®é€šåœ°å€å³å¯
   1. æ³¨æ„: è°ƒç”¨ `call` çš„æ—¶å€™ï¼Œåœ°å€å¯ä»¥ä¸å…·å¤‡ payable å±æ€§
2. è¿”å›ä¸¤ä¸ªå‚æ•°ï¼Œä¸€ä¸ª `bool` å€¼ä»£è¡¨æˆåŠŸæˆ–è€…å¤±è´¥ï¼Œå¦å¤–ä¸€ä¸ªæ˜¯å¯èƒ½å­˜åœ¨çš„ `data`
3. å‘é€æ‰€æœ‰å¯ç”¨ gasï¼Œä¹Ÿå¯ä»¥è‡ªå·±è°ƒèŠ‚ gasã€‚
   1. å¦‚æœ `fallback` å’Œ `receive` å†…çš„ä»£ç ç›¸å¯¹å¤æ‚ä¹Ÿå¯ä»¥ï¼Œä½†æ˜¯å¦‚æœæ˜¯æ¶æ„ä»£ç ï¼Œéœ€è¦è€ƒè™‘æ¶ˆè€—çš„ gas æ˜¯å¦å€¼å¾—æ‰§è¡Œã€‚
   2. `_ads.call{value: msg.value,gas:2300}(data)`
4. å½“åˆçº¦è°ƒç”¨åˆçº¦æ—¶ï¼Œä¸çŸ¥é“å¯¹æ–¹æºç å’Œ ABI æ—¶å€™ï¼Œå¯ä»¥ä½¿ç”¨ call è°ƒç”¨å¯¹æ–¹åˆçº¦
5. æ¨èä½¿ç”¨ call è½¬è´¦ ETHï¼Œä½†æ˜¯ä¸æ¨èä½¿ç”¨ call æ¥è°ƒç”¨å…¶ä»–åˆçº¦ã€‚
   1. åŸå› æ˜¯: call è°ƒç”¨çš„æ—¶å€™ï¼Œå°†åˆçº¦æ§åˆ¶æƒäº¤ç»™å¯¹æ–¹ï¼Œå¦‚æœç¢°åˆ°æ¶æ„ä»£ç ï¼Œæˆ–è€…ä¸å®‰å…¨çš„ä»£ç å°±å¾ˆå®¹æ˜“å‡‰å‡‰ã€‚
6. å½“è°ƒç”¨ä¸å­˜åœ¨çš„åˆçº¦æ–¹æ³•æ—¶å€™ï¼Œä¼šè§¦å‘å¯¹æ–¹åˆçº¦å†…çš„ `fallback` æˆ–è€… `receive`ã€‚
   1. æˆ‘ä»¬çš„åˆçº¦ä¹Ÿå¯ä»¥åœ¨ `fallback` / `receive` è¿™ä¸¤ä¸ªæ–¹æ³•å†…æŠ›å‡ºäº‹ä»¶ï¼ŒæŸ¥çœ‹æ˜¯å¦æœ‰äººå¯¹å…¶åšäº†ä»€ä¹ˆæ“ä½œã€‚
7. ä¸‰ç§æ–¹æ³•éƒ½æä¾› `gas` é€‰é¡¹ï¼Œè€Œ `value` é€‰é¡¹ä»… `call` æ”¯æŒ ã€‚ä¸‰ç§ call é‡Œåªæœ‰ `call` å¯ä»¥è¿›è¡Œ ETH è½¬è´¦ï¼Œå…¶ä»–ä¸¤ç§ä¸å¯ä»¥è¿›è¡Œè½¬è´¦ã€‚

**ä¾‹å­ 1:å‘é€ ETH**

æ ¸å¿ƒ: `(bool success, ) = _to.call{value: 100}("");`

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract SendEth {
    event Log(string funName, address from, uint256 value, bytes data);

    fallback() external payable {
        emit Log("fallback", msg.sender, msg.value, msg.data);
    }

    receive() external payable {
        emit Log("receive", msg.sender, msg.value, "");
    }

    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }

    // 29005
    function call1(address payable _to) external payable {
        (bool success, bytes memory data) = _to.call{value: 100}("");
        require(success, "call Faied");
    }

    // 29007
    function call2(address _to) external {
        (bool success, bytes memory data) = payable(_to).call{value: 100}("");
        require(success, "call Faied");
    }
}
```

**ä¾‹å­ 2ï¼ˆé‡è¦ï¼‰ï¼šè°ƒç”¨å…¶ä»–åˆçº¦æ–¹æ³•**

**å®Œæ•´ä»£ç å¦‚ä¸‹**:

åˆ†åˆ«ä½¿ç”¨ `Test1` å’Œ `Test2` çš„åœ°å€è¿›è¡Œæµ‹è¯•ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test1 {
    string public name;
    uint256 public age;
    address public owner;
    event Log(string message);

    fallback() external payable {
        emit Log("fallback was called");
    }

    receive() external payable {
        emit Log("receive was called");
    }

    function setNameAndAge(string memory name_, uint256 age_)
        external
        payable
        returns (string memory __name, uint256 __age)
    {
        name = name_;
        age = age_;
        owner = msg.sender;
        return (name_, age_);
    }

    // è·å–åˆçº¦çš„ä½™é¢
    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}

contract Test2 {}

contract CallTest {
    // éœ€è¦ä¸€ä¸ªç½‘é¡µï¼ŒåŠ¨æ€çš„è§£æ _bys
    bytes public bys;

    function call_Test1_setNameAndAge(
        address ads_,
        string memory name_,
        uint256 age_
    ) external payable {
        bytes memory data = abi.encodeWithSignature(
            "setNameAndAge(string,uint256)",
            name_,
            age_
        );
        (bool success, bytes memory _bys) = ads_.call{value: msg.value}(data);
        require(success, "Call Failed");
        bys = _bys;
    }
}
```

ç®€å•è¯´ä¸‹è¿™ä¸ªä¾‹å­çš„åŸç†

```
/**
æ™®é€šè°ƒç”¨
ç”¨æˆ·A è°ƒç”¨ callB åˆçº¦, å‘é€ 100 wei ; callB è°ƒç”¨ Test1, å‘é€ 50 wei
æ­¤æ—¶åœ¨ Test1 åˆçº¦å†…éƒ¨
        msg.sender = B
        msg.value = 50
        Test1 å†…éƒ¨å¦‚æœæœ‰çŠ¶æ€å˜é‡ä¿®æ”¹ï¼Œåˆ™ä¼šè¢«ä¿®æ”¹
        å‘é€åˆ° Test1 å†…çš„ETHä¸»å¸ä¹Ÿä¼šè¢«ç•™åœ¨Test1å†…
 */
```

**call æ ¸å¿ƒä»£ç å¦‚ä¸‹**

```
bytes memory data = abi.encodeWithSignature(
    "setNameAndAge(string,uint256)",
    _name,
    _age
);
(bool success, bytes memory _bys) = _ads.call{value: msg.value}(data);
require(success, "Call Failed");
bys = _bys;
```

####  delegatecall() å§”æ‰˜è°ƒç”¨

å‘å‡ºä½çº§å‡½æ•° `DELEGATECALL`ï¼Œå¤±è´¥æ—¶è¿”å› falseï¼Œå‘é€æ‰€æœ‰å¯ç”¨ gasï¼Œä¹Ÿå¯ä»¥è‡ªå·±è°ƒèŠ‚ gasã€‚

```
<address>.delegatecall(bytes memory) returns (bool, bytes memory)
```

`delegatecall` ä½¿ç”¨æ–¹æ³•å’Œ `call` å®Œå…¨ä¸€æ ·ã€‚åŒºåˆ«åœ¨äºï¼Œ`delegatecall` åªè°ƒç”¨ç»™å®šåœ°å€çš„ä»£ç ï¼ˆå‡½æ•°ï¼‰ï¼Œå…¶ä»–çŠ¶æ€å±æ€§å¦‚ï¼ˆå­˜å‚¨ï¼Œä½™é¢ â€¦ï¼‰éƒ½æ¥è‡ªå½“å‰åˆçº¦ã€‚`delegatecall` çš„ç›®çš„æ˜¯ä½¿ç”¨å¦ä¸€ä¸ªåˆçº¦ä¸­çš„åº“ä»£ç ã€‚

å§”æ‰˜è°ƒç”¨æ˜¯ï¼š**å§”æ‰˜å¯¹æ–¹è°ƒç”¨è‡ªå·±æ•°æ®çš„**ã€‚ç±»ä¼¼æˆæƒè½¬è´¦ï¼Œæ¯”å¦‚æˆ‘éƒ¨ç½²ä¸€ä¸ª Bank åˆçº¦ï¼Œ æˆæƒ ContractA ä½¿ç”¨ Bank åœ°å€å†…çš„èµ„é‡‘ï¼ŒContractA åªæ‹¥æœ‰æ§åˆ¶æƒï¼Œä½†æ˜¯æ²¡æœ‰æ‹¥æœ‰æƒã€‚

- å§”æ‰˜è°ƒç”¨åï¼Œæ‰€æœ‰å˜é‡ä¿®æ”¹éƒ½æ˜¯å‘ç”Ÿåœ¨å§”æ‰˜åˆçº¦å†…éƒ¨ï¼Œå¹¶ä¸ä¼šä¿å­˜åœ¨è¢«å§”æ‰˜åˆçº¦ä¸­ã€‚
  - åˆ©ç”¨è¿™ä¸ªç‰¹æ€§ï¼Œå¯ä»¥é€šè¿‡æ›´æ¢è¢«å§”æ‰˜åˆçº¦ï¼Œæ¥å‡çº§å§”æ‰˜åˆçº¦ã€‚
- å§”æ‰˜è°ƒç”¨åˆçº¦å†…éƒ¨ï¼Œéœ€è¦å’Œè¢«å§”æ‰˜åˆçº¦çš„å†…éƒ¨å‚æ•°å®Œå…¨ä¸€æ ·ï¼Œå¦åˆ™å®¹æ˜“å¯¼è‡´æ•°æ®æ··ä¹±
  - å¯ä»¥é€šè¿‡é¡ºåºæ¥é¿å…è¿™ä¸ªé—®é¢˜ï¼Œä½†æ˜¯æ¨èå®Œå…¨ä¸€æ ·

**ä¾‹å­ 1ï¼ˆé‡è¦ï¼‰**

ä»£ç å¦‚ä¸‹:

- `DelegateCall` æ˜¯å§”æ‰˜åˆçº¦
- `TestVersion1` æ˜¯ç¬¬ 1 æ¬¡è¢«å§”æ‰˜åˆçº¦
- `TestVersion2` æ˜¯ç¬¬ 2 æ¬¡è¢«å§”æ‰˜åˆçº¦

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

// åˆçº¦ç‰ˆæœ¬ V.1
contract TestVersion1 {
    address public sender;
    uint256 public value;
    uint256 public num;

    function set(uint256 num_) external payable {
        sender = msg.sender;
        value = msg.value;
        num = num_;
    }
}

// åˆçº¦ç‰ˆæœ¬ V.2
contract TestVersion2 {
    address public sender;
    uint256 public value;
    uint256 public num;

    function set(uint256 num_) external payable {
        sender = msg.sender;
        value = msg.value;
        num = num_ * 2;
    }
}

// å§”æ‰˜è°ƒç”¨æµ‹è¯•
contract DelegateCall {
    address public sender;
    uint256 public value;
    uint256 public num;

    function set(address _ads, uint256 num_) external payable {
        sender = msg.sender;
        value = msg.value;
        num = num_;
        // ç¬¬1ç§ encode
        // ä¸éœ€çŸ¥é“åˆçº¦åå­—ï¼Œå‡½æ•°å®Œå…¨è‡ªå®šä¹‰
        bytes memory data1 = abi.encodeWithSignature("set(uint256)", num_);
        // ç¬¬2ç§ encode
        // éœ€è¦åˆçº¦åå­—ï¼Œå¯ä»¥é¿å…å‡½æ•°å’Œå‚æ•°å†™é”™
        bytes memory data2 = abi.encodeWithSelector(TestVersion1.set.selector, num_);

        (bool success, bytes memory _data) = _ads.delegatecall(data2);

        require(success, "DelegateCall set failed");
    }
}
```

ç®€å•è¯´ä¸‹è¿™ä¸ªä¾‹å­çš„åŸç†

```
/**
å§”æ‰˜è°ƒç”¨
ç”¨æˆ·A è°ƒç”¨ DelegateCallB åˆçº¦, å‘é€ 100 wei ; DelegateCallB å§”æ‰˜è°ƒç”¨ Test1
æ­¤æ—¶åœ¨ Test1 åˆçº¦å†…éƒ¨
        msg.sender = A
        msg.value = 100
        Test1 å†…éƒ¨å¦‚æœæœ‰çŠ¶æ€å˜é‡ä¿®æ”¹ï¼Œä¹Ÿä¸ä¼šè¢«ä¿®æ”¹ï¼Œä¼šåœ¨DelegateCallB å†…æ”¹å˜
        å‘é€åˆ° Test1 å†…çš„ETHä¸»å¸ï¼Œä¼šè¢«ç•™åœ¨ DelegateCallB å†…ï¼Œä¸ä¼šåœ¨Test1 å†…
 */
```

####  staticcall() é™æ€è°ƒç”¨

ç”¨ç»™å®šçš„æœ‰æ•ˆè½½è·ï¼ˆpayloadï¼‰å‘å‡ºä½çº§ `STATICCALL` è°ƒç”¨ï¼Œå¹¶**è¿”å›äº¤æ˜“æˆåŠŸçŠ¶æ€å’Œè¿”å›æ•°æ®**ï¼ˆè°ƒç”¨åˆçº¦çš„æ–¹æ³•å¹¶è½¬è´¦ï¼‰

```
<address>.staticcall(bytes memory) returns (bool, bytes memory)
```

å®ƒä¸ call åŸºæœ¬ç›¸åŒï¼Œå‘é€æ‰€æœ‰å¯ç”¨ gasï¼Œä¹Ÿå¯ä»¥è‡ªå·±è°ƒèŠ‚ gasï¼Œ**ä½†å¦‚æœè¢«è°ƒç”¨çš„å‡½æ•°ä»¥ä»»ä½•æ–¹å¼ä¿®æ”¹çŠ¶æ€å˜é‡ï¼Œéƒ½å°†å›é€€**ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

// è¢«è°ƒç”¨çš„åˆçº¦
contract Hello1 {
    function echo() external pure returns (string memory) {
        return "Hello World!";
    }
}

contract Hello2 {
    uint8 public a;
    function echo() external returns (string memory) {
        a = 1;
        return "Hello World!";
    }
}

// è°ƒç”¨è€…åˆçº¦
contract SoldityTest {
    function callHello(address ads_) external view returns (string memory) {
        // ç¼–ç è¢«è°ƒç”¨è€…çš„æ–¹æ³•ç­¾å
        bytes4 methodId = bytes4(keccak256("echo()"));

        // è°ƒç”¨åˆçº¦
        (bool success, bytes memory data) = ads_.staticcall(
            abi.encodeWithSelector(methodId)
        );
        if (success) {
            return abi.decode(data, (string));
        } else {
            return "error";
        }
    }
}
```

####  ä¸‰ç§ call çš„æ€»ç»“

1. `call` ï¼Œ `delegatecall` å’Œ `staticcall` éƒ½æ˜¯éå¸¸ä½çº§çš„å‡½æ•°ï¼Œåº”è¯¥åªæŠŠå®ƒä»¬å½“ä½œæœ€åä¸€æ‹›æ¥ä½¿ç”¨ï¼Œå®ƒä»¬ç ´åäº† Solidity çš„ç±»å‹å®‰å…¨æ€§ã€‚
2. ä¸‰ç§æ–¹æ³•éƒ½æä¾› `gas` é€‰é¡¹ï¼Œè€Œ `value` é€‰é¡¹ä»… `call` æ”¯æŒ ã€‚æ‰€ä»¥ä¸‰ç§ call é‡Œåªæœ‰ `call` å¯ä»¥è¿›è¡Œ ETH è½¬è´¦ï¼Œå…¶ä»–ä¸¤ç§ä¸å¯ä»¥è¿›è¡Œè½¬è´¦ã€‚
3. ä¸ç®¡æ˜¯è¯»å–çŠ¶æ€è¿˜æ˜¯å†™å…¥çŠ¶æ€ï¼Œæœ€å¥½é¿å…åœ¨åˆçº¦ä»£ç ä¸­ç¡¬ç¼–ç ä½¿ç”¨çš„ gas å€¼ã€‚è¿™å¯èƒ½ä¼šå¼•å…¥**é”™è¯¯**ï¼Œè€Œä¸” gas çš„æ¶ˆè€—ä¹Ÿæ˜¯åŠ¨æ€æ”¹å˜çš„ã€‚
4. å¦‚æœåœ¨é€šè¿‡ä½çº§å‡½æ•° `delegatecall` å‘èµ·è°ƒç”¨æ—¶éœ€è¦è®¿é—®å­˜å‚¨ä¸­çš„å˜é‡ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªåˆçº¦çš„å­˜å‚¨å¸ƒå±€éœ€è¦ä¸€è‡´ï¼Œä»¥ä¾¿è¢«è°ƒç”¨çš„åˆçº¦ä»£ç å¯ä»¥æ­£ç¡®åœ°é€šè¿‡å˜é‡åè®¿é—®åˆçº¦çš„å­˜å‚¨å˜é‡ã€‚ è¿™ä¸æ˜¯æŒ‡åœ¨åº“å‡½æ•°è°ƒç”¨ï¼ˆé«˜çº§çš„è°ƒç”¨æ–¹å¼ï¼‰æ—¶æ‰€ä¼ é€’çš„å­˜å‚¨å˜é‡æŒ‡é’ˆéœ€è¦æ»¡è¶³é‚£æ ·æƒ…å†µã€‚

> âš ï¸ æ³¨æ„: åœ¨ 0.5.0 ç‰ˆæœ¬ä»¥å‰, `.call`, `.delegatecall` and `.staticcall` ä»…ä»…è¿”å›æˆåŠŸçŠ¶æ€ï¼Œæ²¡æœ‰è¿”å›å€¼ã€‚

> âš ï¸ åœ¨ 0.5.0 ç‰ˆæœ¬ä»¥å‰, è¿˜æœ‰ä¸€ä¸ª `callcode` å‡½æ•°ï¼Œç°åœ¨å·²ç»å»é™¤ã€‚

####  transfer / send / call ä¸‰ç§è½¬è´¦çš„æ€»ç»“

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    mapping(address => uint256) public balances;

    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    function byTransfer() public {
        payable(msg.sender).transfer(100);
    }

    function bySend() public {
        bool success = payable(msg.sender).send(100);
        require(success, "Send Fail");
    }

    // å¦‚æœä½¿ç”¨ transfer æˆ– send å‡½æ•°å¿…é¡»æ·»åŠ fallbackå›é€€å‡½æ•°
    fallback() external {}

    receive() external payable {}
}
```

ç›¸åŒç‚¹:

- ä¸‰ç§æ–¹æ³•éƒ½å¯ä»¥è¿›è¡Œè½¬è´¦
- `_to.transfer(100)`ã€`_to.send(100)`ã€`_to.call{value: 100}("")` çš„æ¥æ”¶æ–¹éƒ½æ˜¯`_to`ã€‚
  - å¦‚æœ`_to`æ˜¯åˆçº¦ï¼Œåˆ™åˆçº¦ä¸­å¿…é¡»å¢åŠ  `fallback` æˆ–è€… `receive` å‡½æ•°ï¼
  - å¦åˆ™æŠ¥é”™`In order to receive Ether transfer the contract should have either 'receive' or payable 'fallback' function`

ä¸åŒç‚¹:

- ä½çº§ `CALL` è°ƒç”¨ï¼šä¸éœ€è¦ `payable address`
  - transfer å’Œ send åªèƒ½æ˜¯ `payable address`
- `call` çš„ gas å¯ä»¥åŠ¨æ€è°ƒæ•´
  - transfer å’Œ send åªèƒ½æ˜¯å›ºå®šåˆ¶ `2300`
- `call` é™¤äº†å¯ä»¥è½¬è´¦å¤–ï¼Œå¯ä»¥è¿˜å¯ä»¥è°ƒç”¨ä¸çŸ¥é“ ABI çš„æ–¹æ³•ï¼Œè¿˜å¯ä»¥è°ƒç”¨çš„æ—¶å€™è½¬è´¦
  - å½“è°ƒç”¨ä¸å­˜åœ¨çš„åˆçº¦æ–¹æ³•æ—¶å€™ï¼Œä¼šè§¦å‘å¯¹æ–¹åˆçº¦å†…çš„ `fallback` æˆ–è€… `receive`ã€‚
  - å¦‚æœä½¿ç”¨ `_to.call{value: 100}(data)`ï¼Œé‚£ä¹ˆ`data`ä¸­è¢«è°ƒç”¨çš„æ–¹æ³•å¿…é¡»æ·»åŠ  `payable` ä¿®é¥°ç¬¦ï¼Œå¦åˆ™è½¬è´¦å¤±è´¥ï¼
  - å› ä¸ºå¯ä»¥è°ƒç”¨æ–¹æ³•ï¼Œæ‰€ä»¥ call æœ‰ä¸¤ä¸ªå‚æ•°ï¼Œé™¤äº†ä¸€ä¸ª `bool` å€¼ä»£è¡¨æˆåŠŸæˆ–è€…å¤±è´¥ï¼Œå¦å¤–ä¸€ä¸ªæ˜¯å¯èƒ½å­˜åœ¨çš„ `data`ï¼Œæ¯”å¦‚åˆ›å»ºåˆçº¦æ—¶å€™å¾—åˆ°éƒ¨ç½²çš„åœ°å€ï¼Œè°ƒç”¨å‡½æ•°æ—¶å€™å¾—åˆ°çš„å‡½æ•°æ”¾å›å€¼ã€‚

####  æ³¨æ„äº‹é¡¹Â·

**send**

ä½¿ç”¨ send æœ‰å¾ˆå¤šå±é™©ï¼šå¦‚æœè°ƒç”¨æ ˆæ·±åº¦å·²ç»è¾¾åˆ° 1024ï¼ˆè¿™æ€»æ˜¯å¯ä»¥ç”±è°ƒç”¨è€…æ‰€å¼ºåˆ¶æŒ‡å®šï¼‰ï¼Œè½¬è´¦ä¼šå¤±è´¥ï¼›å¹¶ä¸”å¦‚æœæ¥æ”¶è€…ç”¨å…‰äº† gasï¼Œè½¬è´¦åŒæ ·ä¼šå¤±è´¥ã€‚ä¸ºäº†ä¿è¯ä»¥å¤ªå¸è½¬è´¦å®‰å…¨ï¼Œæ€»æ˜¯æ£€æŸ¥ send çš„è¿”å›å€¼ï¼Œåˆ©ç”¨ transfer æˆ–è€…ä¸‹é¢æ›´å¥½çš„æ–¹å¼ï¼š ç”¨è¿™ç§æ¥æ”¶è€…å–å›é’±çš„æ¨¡å¼ã€‚

**call**

åœ¨æ‰§è¡Œå¦ä¸€ä¸ªåˆçº¦å‡½æ•°æ—¶ï¼Œåº”è¯¥å°½å¯èƒ½é¿å…ä½¿ç”¨ .call() ï¼Œå› ä¸ºå®ƒç»•è¿‡äº†ç±»å‹æ£€æŸ¥ï¼Œå‡½æ•°å­˜åœ¨æ£€æŸ¥å’Œå‚æ•°æ‰“åŒ…ã€‚

ç”±äº EVM ä¼šæŠŠå¯¹ä¸€ä¸ªä¸å­˜åœ¨çš„åˆçº¦çš„è°ƒç”¨ä½œä¸ºæ˜¯æˆåŠŸçš„ã€‚ Solidity ä¼šåœ¨æ‰§è¡Œå¤–éƒ¨è°ƒç”¨æ—¶ä½¿ç”¨ extcodesize æ“ä½œç è¿›è¡Œé¢å¤–æ£€æŸ¥ã€‚ è¿™ç¡®ä¿äº†å³å°†è¢«è°ƒç”¨çš„åˆçº¦è¦ä¹ˆå®é™…å­˜åœ¨ï¼ˆå®ƒåŒ…å«ä»£ç ï¼‰æˆ–è€…è§¦å‘ä¸€ä¸ªå¼‚å¸¸ã€‚ä½çº§è°ƒç”¨ä¸ åŒ…æ‹¬è¿™ä¸ªæ£€æŸ¥ï¼Œ**è¿™ä½¿å¾—å®ƒä»¬åœ¨ GAS æ–¹é¢æ›´ä¾¿å®œï¼Œä½†ä¹Ÿæ›´ä¸å®‰å…¨**ã€‚

ä¸Šé¢çš„è¿™ä¸‰ä¸ª call æ–¹æ³•éƒ½æ˜¯åº•å±‚çš„æ¶ˆæ¯ä¼ é€’è°ƒç”¨ï¼Œæœ€å¥½ä»…åœ¨ä¸‡ä¸å¾—å·²æ‰è¿›è¡Œä½¿ç”¨ï¼Œå› ä¸ºä»–ä»¬ç ´åäº† Solidity çš„ç±»å‹å®‰å…¨ã€‚

## å€¼ç±»å‹:åˆçº¦ç±»å‹

æ¯ä¸€ä¸ªåˆçº¦å®šä¹‰éƒ½æœ‰ä»–è‡ªå·±çš„ç±»å‹ã€‚

- å¯ä»¥éšå¼åœ°å°†åˆçº¦è½¬æ¢ä¸ºä»ä»–ä»¬ç»§æ‰¿çš„åˆçº¦ã€‚
- åˆçº¦å¯ä»¥æ˜¾å¼è½¬æ¢ä¸º `address` ç±»å‹ã€‚
- å¯ä»¥è½¬æ¢ä¸º `address payable` ç±»å‹

âš ï¸ æ³¨æ„ï¼šåˆçº¦ä¸æ”¯æŒä»»ä½•è¿ç®—ç¬¦ã€‚

### åˆ›å»ºçš„ä¾‹å­

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract A {
    uint256 public a = 123;

    fallback() external {}

    receive() external payable {}
}

contract C {
    A public a1;
    // A public a1 = A(payable(0xa0808B3e1713ff8C66b89aa4d0033c9ACfe37016));
    A public a2 = new A();

    // å…ˆéƒ¨ç½²åï¼Œç„¶åä¼ å…¥åœ°å€
    function getA1(A _a) external pure returns (address, address) {
        return (address(_a), payable(address(_a)));
    }

    // å†…éƒ¨ç›´æ¥newåˆ›å»º
    function getA2() external view returns (address, address) {
        return (address(a2), payable(address(a2)));
    }


    function test1(A _a) external view returns (uint256) {
        return _a.a();
    }
    function test2() external view returns (uint256) {
        return a2.a();
    }
}
```

å¦‚æœå£°æ˜ä¸€ä¸ªåˆçº¦ç±»å‹çš„å±€éƒ¨å˜é‡ï¼ˆ `MyContract c` ï¼‰ï¼Œåˆ™å¯ä»¥è°ƒç”¨è¯¥åˆçº¦çš„å‡½æ•°ã€‚ æ³¨æ„éœ€è¦èµ‹ç›¸åŒåˆçº¦ç±»å‹çš„å€¼ç»™å®ƒã€‚

è¿˜å¯ä»¥å®ä¾‹åŒ–åˆçº¦ï¼ˆå³æ–°åˆ›å»ºä¸€ä¸ªåˆçº¦å¯¹è±¡ï¼‰ï¼Œä½¿ç”¨ `new` åˆ›å»ºåˆçº¦ã€‚

åˆçº¦å’Œ address çš„æ•°æ®è¡¨ç¤ºæ˜¯ç›¸åŒçš„.

### è½¬é’±çš„ä¾‹å­

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract A {
    uint256 public a = 123;

    fallback() external {}

    receive() external payable {}
}

contract B {
    // æ²¡æœ‰ fallback / receive
    uint256 public b = 123;
}

contract C {
    A public a = new A();
    B public b = new B();

    function transferA() external payable returns (address, address) {
        payable(address(a)).transfer(msg.value);
        return (address(a), payable(address(a)));
    }


    function transferB() external payable returns (address, address) {
        payable(address(b)).transfer(msg.value);
        return (address(b), payable(address(b)));
    }

        // è·å–åˆçº¦çš„ä½™é¢
    function getBalance(address ads_) external view returns (uint256) {
        return ads_.balance;
    }
}
```

### åˆçº¦çš„å±æ€§

åˆçº¦ç±»å‹çš„æˆå‘˜æ˜¯åˆçº¦çš„å¤–éƒ¨å‡½æ•°åŠ public çš„ çŠ¶æ€å˜é‡ã€‚

å¯¹äºåˆçº¦ C å¯ä»¥ä½¿ç”¨ type(C) è·å–åˆçº¦çš„ç±»å‹ä¿¡æ¯ï¼Œ

- `type(C).name`
  - è·å¾—åˆçº¦å
- `type(C).creationCode`
  - è·å¾—åŒ…å«åˆ›å»ºåˆçº¦å­—èŠ‚ç çš„å†…å­˜å­—èŠ‚æ•°ç»„ã€‚
  - è¯¥å€¼å’Œåˆçº¦å†…ä½¿ç”¨ `address(this).code;` ç»“æœä¸€æ ·ã€‚
  - å®ƒå¯ä»¥åœ¨å†…è”æ±‡ç¼–ä¸­æ„å»ºè‡ªå®šä¹‰åˆ›å»ºä¾‹ç¨‹ï¼Œå°¤å…¶æ˜¯ä½¿ç”¨ `create2` æ“ä½œç ã€‚
  - ä¸èƒ½åœ¨åˆçº¦æœ¬èº«æˆ–æ´¾ç”Ÿçš„åˆçº¦è®¿é—®æ­¤å±æ€§ã€‚ å› ä¸ºä¼šå¼•èµ·å¾ªç¯å¼•ç”¨ã€‚
- `type(C).runtimeCode`
  - è·å¾—åˆçº¦çš„è¿è¡Œæ—¶å­—èŠ‚ç çš„å†…å­˜å­—èŠ‚æ•°ç»„ã€‚è¿™æ˜¯é€šå¸¸ç”± `C` çš„æ„é€ å‡½æ•°éƒ¨ç½²çš„ä»£ç ã€‚
  - å¦‚æœ `C` æœ‰ä¸€ä¸ªä½¿ç”¨å†…è”æ±‡ç¼–çš„æ„é€ å‡½æ•°ï¼Œé‚£ä¹ˆå¯èƒ½ä¸å®é™…éƒ¨ç½²çš„å­—èŠ‚ç ä¸åŒã€‚
  - è¿˜è¦æ³¨æ„åº“åœ¨éƒ¨ç½²æ—¶ä¿®æ”¹å…¶è¿è¡Œæ—¶å­—èŠ‚ç ä»¥é˜²èŒƒå®šæœŸè°ƒç”¨ï¼ˆguard against regular callsï¼‰ã€‚ ä¸ `.creationCode` æœ‰ç›¸åŒçš„é™åˆ¶ï¼Œä¸èƒ½åœ¨åˆçº¦æœ¬èº«æˆ–æ´¾ç”Ÿçš„åˆçº¦è®¿é—®æ­¤å±æ€§ã€‚ å› ä¸ºä¼šå¼•èµ·å¾ªç¯å¼•ç”¨ã€‚

####  æ—  constructor

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    address public owner;

    function getCode() public view returns (bytes memory) {
        return address(this).code;
    }
}

contract C {
    string public name = type(Test).name;

    bytes public creationCode = type(Test).creationCode;

    bytes public runtimeCode = type(Test).runtimeCode;
}

// Test.getCode
//

// creationCode
//

// runtimeCode
// å’Œ Test.getCode ç›¸åŒ
```

####  æœ‰ constructor

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    function getCode() public view returns (bytes memory) {
        return address(this).code;
    }
}

contract C {
    string public name = type(Test).name;

    bytes public creationCode = type(Test).creationCode;

    // runtimeCode ä¸èƒ½è·å– constructor ä¿®æ”¹ immutable å˜é‡çš„æ•°æ®
    // æ¯”å¦‚ Test é‡Œçš„owner ä¸èƒ½æ˜¯ immutable ç±»å‹
    // "runtimeCode" is not available for contracts containing immutable variables.
    // ç­‰äºåˆçº¦åœ°å€ä¸Šçš„å±æ€§ address(this).code
    bytes public runtimeCode = type(Test).runtimeCode;
}

// Test.getCode
//

// creationCode
//

// runtimeCode
// å’Œ Test.getCode ç›¸åŒ
```

## å¼•ç”¨ç±»å‹çš„é¢å¤–æ³¨è§£:æ•°æ®ä½ç½®

data location ï¼Œä¸­æ–‡åä¸ºæ•°æ®ä½ç½®ã€‚

åœ¨è®²å¼•ç”¨ç±»å‹ä¹‹å‰ï¼Œå…ˆä»‹ç»æ•°æ®ä½ç½®ã€‚è¿™æ˜¯å› ä¸ºåœ¨ Solidity ä¸­ï¼Œå¼•ç”¨ç±»å‹æ˜¯ç”±ç®€å•æ•°æ®ç±»å‹ç»„åˆè€Œæˆï¼Œç›¸æ¯”äºç®€å•çš„å€¼ç±»å‹ï¼Œè¿™äº›ç±»å‹é€šå¸¸é€šè¿‡åç§°å¼•ç”¨ã€‚è¿™äº›ç±»å‹æ¶‰åŠåˆ°çš„æ•°æ®é‡è¾ƒå¤§ï¼Œå¤åˆ¶å®ƒä»¬å¯èƒ½è¦æ¶ˆè€—å¤§é‡ Gasï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨ä½¿ç”¨å¼•ç”¨æ•°æ®ç±»å‹æ—¶ï¼Œå¿…é¡»è€ƒè™‘å­˜å‚¨ä½ç½®ã€‚æˆ‘ä»¬éœ€è¦ä»”ç»†è€ƒè™‘æ•°æ®æ˜¯ä¿å­˜åœ¨å†…å­˜ä¸­ï¼Œè¿˜æ˜¯åœ¨ EVM å­˜å‚¨åŒºä¸­ã€‚è¿™å°±æ˜¯çº¿ä»‹ç»æ•°æ®ä½ç½®çš„åŸå› ã€‚

æ³¨æ„ï¼šæ‰€æœ‰çš„å¼•ç”¨ç±»å‹ï¼Œéƒ½æœ‰æ•°æ®ä½ç½®è¿™ä¸ªé¢å¤–çš„æ³¨è§£æ¥æŒ‡å®šå­˜å‚¨åœ¨å“ªé‡Œï¼Œæ‰€ä»¥ä¸€å®šè¦æŒæ¡å¥½ã€‚

æ€»ç»“ï¼š**å¦‚æœä½¿ç”¨å¼•ç”¨ç±»å‹ï¼Œåˆ™å¿…é¡»æ˜ç¡®æŒ‡æ˜æ•°æ®å­˜å‚¨å“ªç§ç±»å‹çš„ä½ç½®ï¼ˆç©ºé—´ï¼‰é‡Œ**ï¼š

### æ•°æ®ä½ç½®çš„åŸºç¡€ä»‹ç»

åœ¨åˆçº¦ä¸­å£°æ˜å’Œä½¿ç”¨çš„å˜é‡éƒ½æœ‰ä¸€ä¸ªæ•°æ®ä½ç½®ï¼Œåˆçº¦å˜é‡çš„æ•°æ®ä½ç½®å°†ä¼šå½±å“ Gas æ¶ˆè€—é‡ã€‚

Solidity æä¾›çš„æœ‰ä¸‰ç§å¦‚ä¸‹æ•°æ®ä½ç½®ã€‚

- å­˜å‚¨ storage : çŠ¶æ€å˜é‡ä¿å­˜çš„ä½ç½®ï¼Œåªè¦åˆçº¦å­˜åœ¨å°±ä¸€ç›´å­˜å‚¨ï¼
- å†…å­˜ memory : å³æ•°æ®åœ¨å†…å­˜ä¸­ï¼Œå› æ­¤æ•°æ®ä»…åœ¨å…¶ç”Ÿå‘½å‘¨æœŸå†…ï¼ˆå‡½æ•°è°ƒç”¨æœŸé—´ï¼‰æœ‰æ•ˆã€‚ä¸èƒ½ç”¨äºå¤–éƒ¨è°ƒç”¨ã€‚
- è°ƒç”¨æ•°æ® calldata : ç”¨æ¥ä¿å­˜å‡½æ•°å‚æ•°çš„ç‰¹æ®Šæ•°æ®ä½ç½®ï¼Œæ˜¯ä¸€ä¸ªåªè¯»ä½ç½®ã€‚
  - è°ƒç”¨æ•°æ® calldata æ˜¯ä¸å¯ä¿®æ”¹çš„ã€éæŒä¹…çš„å‡½æ•°å‚æ•°å­˜å‚¨åŒºåŸŸï¼Œæ•ˆæœå¤§å¤šç±»ä¼¼ å†…å­˜ memory ã€‚
  - ä¸»è¦ç”¨äºå¤–éƒ¨å‡½æ•°çš„å‚æ•°ï¼Œä½†ä¹Ÿå¯ç”¨äºå…¶ä»–å˜é‡ï¼Œæ— è®ºå¤–éƒ¨å†…éƒ¨å‡½æ•°éƒ½å¯ä»¥ä½¿ç”¨ã€‚

æ ¸å¿ƒï¼šæ›´æ”¹æ•°æ®ä½ç½®æˆ–ç±»å‹è½¬æ¢å°†å§‹ç»ˆäº§ç”Ÿè‡ªåŠ¨è¿›è¡Œä¸€ä»½æ‹·è´ï¼Œè€Œåœ¨åŒä¸€æ•°æ®ä½ç½®å†…ï¼ˆå¯¹äº å­˜å‚¨ storage æ¥è¯´ï¼‰çš„å¤åˆ¶ä»…åœ¨æŸäº›æƒ…å†µä¸‹è¿›è¡Œæ‹·è´ã€‚

####  storage

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract DataLocation {
    // storage
    uint256 stateVariable = 1;
    uint256[] stateArray = [1, 2, 3];

    // uint storage stateVariable; // Expected identifier but got 'storage'
    // uint[] memory stateArray; // Expected identifier but got 'memory'
}
```

è¯¥å­˜å‚¨ä½ç½®å­˜å‚¨æ°¸ä¹…æ•°æ®ï¼Œè¿™æ„å‘³ç€è¯¥æ•°æ®å¯ä»¥è¢«åˆçº¦ä¸­çš„æ‰€æœ‰å‡½æ•°è®¿é—®ã€‚å¯ä»¥æŠŠå®ƒè§†ä¸ºè®¡ç®—æœºçš„ç¡¬ç›˜æ•°æ®ï¼Œæ‰€æœ‰æ•°æ®éƒ½æ°¸ä¹…å­˜å‚¨ã€‚ä¿å­˜åœ¨å­˜å‚¨åŒº(storage)ä¸­çš„å˜é‡ï¼Œä»¥æ™ºèƒ½åˆçº¦çš„çŠ¶æ€å­˜å‚¨ï¼Œå¹¶ä¸”åœ¨å‡½æ•°è°ƒç”¨ä¹‹é—´ä¿æŒæŒä¹…æ€§ã€‚ä¸å…¶ä»–æ•°æ®ä½ç½®ç›¸æ¯”ï¼Œå­˜å‚¨åŒºæ•°æ®ä½ç½®çš„æˆæœ¬è¾ƒé«˜ã€‚

storage æ˜¯æ°¸ä¹…å­˜å‚¨åœ¨ä»¥å¤ªåŠåŒºå—é“¾ä¸­ï¼Œæ›´å…·ä½“åœ°è¯´å­˜å‚¨åœ¨å­˜å‚¨ Merkle Patricia æ ‘ä¸­ï¼Œ**å½¢æˆå¸æˆ·çŠ¶æ€ä¿¡æ¯çš„ä¸€éƒ¨åˆ†**ã€‚ä¸€æ—¦ä½¿ç”¨è¿™ä¸ªç±»å‹ï¼Œæ•°æ®å°†æ°¸è¿œå­˜åœ¨ã€‚ æ‰©å±•: [é»˜å…‹å°”æ ‘ï¼ˆmerkle treeï¼‰](https://zhuanlan.zhihu.com/p/39271872)

**é‡ç‚¹:çŠ¶æ€å˜é‡æ€»æ˜¯å­˜å‚¨åœ¨å­˜å‚¨åŒº(storage)ä¸­,å¹¶ä¸”ä¸èƒ½æ˜¾å¼åœ°æ ‡è®°çŠ¶æ€å˜é‡çš„ä½ç½®ã€‚**ã€‚çŠ¶æ€å˜é‡æ˜¯å¼ºåˆ¶ä¸º storageã€‚

####  memory

å†…å­˜ä½ç½®æ˜¯ä¸´æ—¶æ•°æ®ï¼Œæ¯”å­˜å‚¨ä½ç½®ä¾¿å®œã€‚å®ƒåªèƒ½åœ¨å‡½æ•°ä¸­è®¿é—®ã€‚é€šå¸¸ï¼Œå†…å­˜æ•°æ®ç”¨äºä¿å­˜ä¸´æ—¶å˜é‡ï¼Œä»¥ä¾¿åœ¨å‡½æ•°æ‰§è¡ŒæœŸé—´è¿›è¡Œè®¡ç®—ã€‚ä¸€æ—¦å‡½æ•°æ‰§è¡Œå®Œæ¯•ï¼Œå®ƒçš„å†…å®¹å°±ä¼šè¢«ä¸¢å¼ƒã€‚ä½ å¯ä»¥æŠŠå®ƒæƒ³è±¡æˆæ¯ä¸ªå•ç‹¬å‡½æ•°çš„å†…å­˜(RAM)ã€‚

memoryï¼š**å­˜å‚¨åœ¨å†…å­˜ä¸­ï¼Œå³åˆ†é…ã€å³ä½¿ç”¨ï¼Œè¶Šè¿‡ä½œç”¨åŸŸåˆ™ä¸å¯è®¿é—®ï¼Œç­‰å¾…è¢«å›æ”¶**ã€‚

##### **é‡ç‚¹ 1:å‡½æ•°å‚æ•°(åŒ…æ‹¬è¿”å›å‚æ•°)éƒ½å­˜å‚¨åœ¨å†…å­˜ä¸­ã€‚**

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract DataLocation {
    function add(uint256 num1, uint256 num2)
        public
        pure
        returns (uint256 result)
    {
        return num1 + num2;
    }
}
```

ä¸Šé¢ä¾‹å­ä¸­: å‡½æ•°å‚æ•° `uint num1` ä¸ `uint num2`ï¼Œè¿”å›å€¼ `uint result` éƒ½å­˜å‚¨åœ¨å†…å­˜ä¸­ã€‚

##### **é‡ç‚¹ 2:å¼•ç”¨ç±»å‹çš„å±€éƒ¨å˜é‡ï¼Œéœ€è¦æ˜¾å¼æŒ‡å®šæ•°æ®ä½ç½®(storage/memory)**

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Locations {
    struct Book {
        string title;
        string author;
        uint256 book_id;
    }
    Book public java; // ä¸€æœ¬ java ä¹¦
    mapping(address => uint256) public balances;

    function test() public {
        /* æ­¤å¤„éƒ½æ˜¯å±€éƒ¨å˜é‡  */
        // å€¼ç±»å‹:æ‰€ä»¥å®ƒä»¬è¢«å­˜å‚¨åœ¨å†…å­˜ä¸­
        bool flag = true;
        uint256 number = 1;
        address account = 0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac;
        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff)));

        // Data location can only be specified for array, struct or mapping types,
        // but "memory" was given.
        // bool memory flag2; // é”™è¯¯:å€¼ç±»å‹çš„æ•°æ®ä¸èƒ½æ ‡ç¤º memory

        // å¼•ç”¨ç±»å‹:éœ€è¦æ˜¾ç¤ºæŒ‡å®šæ•°æ®ä½ç½®ï¼Œæ­¤å¤„æŒ‡å®šä¸ºå†…å­˜
        uint256[] memory localArray; // array
        // uint8[] memory nums = [1, 2, 3]; // å†…å­˜ä¸­ä¸èƒ½åˆ›å»ºåŠ¨æ€æ•°ç»„
        uint8[3] memory numsFixed = [1, 2, 3];
        uint256[] memory a = new uint256[](5); // æ¨è
        a[1] = 1;
        a[2] = 2;
        a[3] = 3;
        a[4] = 4;

        string memory myStr = "hello"; // string

        // æ˜ å°„ä¸èƒ½åœ¨å‡½æ•°ä¸­åŠ¨æ€åˆ›å»ºï¼Œæ‚¨å¿…é¡»ä»çŠ¶æ€å˜é‡ä¸­åˆ†é…å®ƒä»¬ã€‚
        // mapping(address => bool) memory myMapping;
        mapping(address => uint256) storage ref = balances; // mapping
        java = Book({title: "Solidity", author: "Anbang", book_id: 1}); // struct
        bytes memory bc = bytes("!"); //
    }
}
```

- mapping å’Œ struct ç±»å‹ï¼Œä¸èƒ½åœ¨å‡½æ•°ä¸­åŠ¨æ€åˆ›å»ºï¼Œå¿…é¡»ä»çŠ¶æ€å˜é‡ä¸­åˆ†é…å®ƒä»¬ã€‚
- å†…å­˜ä¸­ä¸èƒ½åˆ›å»ºåŠ¨æ€æ•°ç»„

##### **é‡ç‚¹ 3:å‡½æ•°çš„è¾“å…¥å’Œè¾“å‡ºå‚æ•°å¦‚æœæ˜¯æ•°ç»„,ä½¿ç”¨ memory**

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract DataLocations {
    // name_ æ˜¯ string ï¼Œæ‰€ä»¥ä½¿ç”¨ memory
    // mm_ æ˜¯ uint256[] ï¼Œæ‰€ä»¥ä½¿ç”¨ memory
    // è¾“å‡ºç›¸åŒï¼Œä¹Ÿæ˜¯ä½¿ç”¨ memory
    function examples2(string memory name_, uint256[] memory mm_)
        external
        pure
        returns (uint256[] memory memArr, string memory myName)
    {
        memArr = new uint256[](mm_.length);
        myName = name_;
        for (uint256 index = 0; index < mm_.length; index++) {
            memArr[index] = mm_[index];
        }
    }
}
```

##### **é‡ç‚¹ 4:å¼•ç”¨ç±»å‹çš„å±€éƒ¨å˜é‡:æŒ‡å®š storage å’Œ memory çš„åŒºåˆ«**

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract DataLocations {
    struct MyStruct {
        string name;
        uint256 age;
    }
    mapping(address => MyStruct) public myStructs;

    function test1() external returns (MyStruct memory) {
        myStructs[msg.sender] = MyStruct({name: "Anbang1", age: 18});

        // storage ä¼šä¿®æ”¹çŠ¶æ€å˜é‡
        MyStruct storage myStruct1 = myStructs[msg.sender];
        myStruct1.age++;
        return myStruct1;
    }

    function test2() external returns (MyStruct memory) {
        myStructs[msg.sender] = MyStruct({name: "Anbang2", age: 18});

        // memory å‡½æ•°è¿è¡Œå®Œåå³æ¶ˆå¤±ï¼Œä¿®æ”¹çš„å€¼ä¹Ÿä¸ä¼šå‚¨å­˜åœ¨çŠ¶æ€å˜é‡ä¸­
        MyStruct memory myStruct2 = myStructs[msg.sender];
        myStruct2.age++;
        return myStruct2;
    }
}
```

- `storage`ä¿®æ”¹å¼•ç”¨æ•°æ®: ä¼šä¿®æ”¹çŠ¶æ€å˜é‡
- `memory`ä¿®æ”¹å¼•ç”¨æ•°æ®: å‡½æ•°è¿è¡Œå®Œåå³æ¶ˆå¤±ï¼Œä¿®æ”¹çš„å€¼ä¹Ÿä¸ä¼šå‚¨å­˜åœ¨çŠ¶æ€å˜é‡ä¸­

####  calldata

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract DataLocations {
    function test(uint256[] calldata mm_)
        external
        pure
        returns (uint256[] calldata)
    {
        // mm_[0] = 1; // Calldata arrays are read-only.
        return mm_;
    }
}
```

calldata æ˜¯ä¸å¯ä¿®æ”¹çš„éæŒä¹…æ€§æ•°æ®ä½ç½®ï¼Œæ‰€æœ‰ä¼ é€’ç»™å‡½æ•°çš„å€¼ï¼Œéƒ½å­˜å‚¨åœ¨è¿™é‡Œã€‚æ­¤å¤–ï¼Œ`calldata` æ˜¯å¤–éƒ¨å‡½æ•°(external function)çš„å‚æ•°çš„é»˜è®¤ä½ç½®ã€‚å¤–éƒ¨å‡½æ•°(external function)çš„å‚æ•°å­˜å‚¨åœ¨ calldata ä¸­ã€‚å‡½æ•°çš„è¿”å›å€¼ä¸­ä¹Ÿå¯ä»¥ä½¿ç”¨ calldata æ•°æ®ä½ç½®çš„æ•°ç»„å’Œç»“æ„ï¼Œä½†æ˜¯æ— æ³•ç»™å…¶åˆ†é…ç©ºé—´ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract DataLocations {
    // å‚æ•° [1,2,3]      æ¶ˆè€— 25586 gas
    // å‚æ•° [1,2,3,4,5,6,7,8,9,0] æ¶ˆè€— 32114 gas
    function iMemory(uint256[] memory _mm)
        external
        pure
        returns (uint256[] memory memArr)
    {
        memArr = new uint256[](_mm.length);
        for (uint256 index = 0; index < _mm.length; index++) {
            memArr[index] = _mm[index];
        }
    }

    // å‚æ•° [1,2,3]      æ¶ˆè€— 24551 gas
    // å‚æ•° [1,2,3,4,5,6,7,8,9,0] æ¶ˆè€— 29510 gas
    function iCalldata(uint256[] calldata _mm)
        external
        pure
        returns (uint256[] memory memArr)
    {
        memArr = new uint256[](_mm.length);
        for (uint256 index = 0; index < _mm.length; index++) {
            memArr[index] = _mm[index];
        }
    }
}
```

- **è¦ç‚¹: calldata åªèƒ½ç”¨åœ¨å‡½æ•°çš„è¾“å…¥å’Œè¾“å‡ºå‚æ•°ä¸­**
- **è¦ç‚¹: calldata ç”¨åœ¨è¾“å…¥å‚æ•°ä¸­ï¼Œæ¯” memorg æ›´çœ gas**
- **è¦ç‚¹: calldata çš„å‚æ•°ä¸å…è®¸ä¿®æ”¹ï¼Œä½†æ˜¯ memorg å‚æ•°å…è®¸ä¿®æ”¹**

å­˜å‚¨å‡½æ•°å‚æ•°ï¼Œå®ƒæ˜¯åªè¯»çš„ï¼Œä¸ä¼šæ°¸ä¹…å­˜å‚¨çš„ä¸€ä¸ªæ•°æ®ä½ç½®ã€‚å¤–éƒ¨å‡½æ•°(external function)çš„å‚æ•°è¢«å¼ºåˆ¶æŒ‡å®šä¸º calldataï¼Œæ•ˆæœä¸ memory ç±»ä¼¼ã€‚

> æ³¨è§£: å¦‚æœå¯ä»¥çš„è¯ï¼Œè¯·å°½é‡ä½¿ç”¨ calldata ä½œä¸ºæ•°æ®ä½ç½®ï¼Œå› ä¸ºå®ƒå°†é¿å…å¤åˆ¶ï¼Œå¹¶ç¡®ä¿ä¸èƒ½ä¿®æ”¹æ•°æ®ã€‚

> æ³¨è§£: åœ¨ 0.6.9 ç‰ˆæœ¬ä¹‹å‰ï¼Œå¼•ç”¨ç±»å‹å‚æ•°çš„æ•°æ®ä½ç½®æœ‰é™åˆ¶ï¼Œä¸»è¦è¡¨ç°åœ¨å‡½æ•°çš„å¯è§æ€§ä¸Šï¼›å¤–éƒ¨å‡½æ•°ä¸­ä½¿ç”¨ calldata ï¼Œå…¬å…±å‡½æ•°ä¸­ä½¿ç”¨ memory ï¼Œä»¥åŠå†…éƒ¨å’Œç§æœ‰å‡½æ•°ä¸­çš„ memory æˆ– storage ã€‚ ç°åœ¨ memory å’Œ calldata åœ¨æ‰€æœ‰å‡½æ•°ä¸­éƒ½è¢«å…è®¸ä½¿ç”¨ï¼Œæ— è®ºå…¶å¯è§æ€§å¦‚ä½•ã€‚

<!-- âŒ å¤–éƒ¨å‡½æ•° (external function) çš„å‚æ•°å¼ºåˆ¶ä¸ºï¼šcalldataã€‚`TODO`: è¿™é‡Œè¯¥æ€ä¹ˆç†è§£ï¼Ÿ -->

<!-- ```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo1 {
    function test1(string memory _name) external pure returns (string memory) {
        return _name;
    }

    function test2(string memory _name) public pure returns (string memory) {
        return _name;
    }
}
``` -->

####  stack

å †æ ˆæ˜¯ç”± EVM (Ethereum è™šæ‹Ÿæœº)ç»´æŠ¤çš„éæŒä¹…æ€§æ•°æ®ã€‚EVM ä½¿ç”¨å †æ ˆæ•°æ®ä½ç½®åœ¨æ‰§è¡ŒæœŸé—´åŠ è½½å˜é‡ã€‚å †æ ˆä½ç½®æœ€å¤šæœ‰ 1024 ä¸ªçº§åˆ«çš„é™åˆ¶ã€‚

####  å°ç»“

æŒ‰ç…§å…³é”®å­—:

- storage: å­˜å‚¨åŒº: çŠ¶æ€å˜é‡æ€»æ˜¯å‚¨å­˜åœ¨**å­˜å‚¨åŒº**ä¸Š
- memory: å†…å­˜åŒº: å±€éƒ¨å˜é‡ä½¿ç”¨ï¼Œåªåœ¨å†…å­˜ä¸­ç”Ÿæ•ˆã€‚
  - å€¼ç±»å‹çš„å±€éƒ¨å˜é‡ï¼Œå­˜å‚¨åœ¨**å†…å­˜**ä¸­ã€‚
  - **å¼•ç”¨ç±»å‹å±€éƒ¨å˜é‡ï¼Œéœ€è¦æ˜¾å¼åœ°æŒ‡å®šæ•°æ®ä½ç½®**ã€‚
  - å‡½æ•°çš„è¾“å…¥å‚æ•°å¦‚æœæ˜¯æ•°ç»„æˆ–è€… stringï¼Œå¿…é¡»æ˜¯ `memory` æˆ– `calldata`
  - å†…å­˜ä¸­çš„æ•°ç»„å¿…é¡»æ˜¯å®šé•¿æ•°ç»„ï¼ˆä¸èƒ½ä½¿ç”¨ push èµ‹å€¼ï¼‰ï¼ŒåŠ¨æ€æ•°ç»„åªèƒ½å‚¨å­˜åœ¨çŠ¶æ€å˜é‡ä¸­ã€‚
- calldata
  - å’Œ memory ç±»ä¼¼ï¼Œä½†æ˜¯ calldata åªèƒ½ç”¨åœ¨å‡½æ•°çš„è¾“å…¥å‚æ•°ä¸­ã€‚
  - ç›¸æ¯”ä½¿ç”¨ memory ,åˆçº¦è¾“å…¥å‚æ•°å¦‚æœä½¿ç”¨ calldata, å¯ä»¥èŠ‚çº¦ gas

æŒ‰ç…§å‡½æ•°å‚æ•°:

- å†…éƒ¨å‡½æ•°å‚æ•°: (åŒ…æ‹¬è¿”å›å‚æ•°)éƒ½å­˜å‚¨åœ¨**memoryï¼ˆå†…å­˜ï¼‰**ä¸­ã€‚
- å¤–éƒ¨å‡½æ•°å‚æ•°: (ä¸åŒ…æ‹¬è¿”å›å‚æ•°)å­˜å‚¨åœ¨ `calldata` ä¸­ã€‚

### ä¸åŒæ•°æ®ä½ç½®ä¹‹é—´çš„èµ‹å€¼è§„åˆ™

æœ¬å°èŠ‚æ€»ç»“å¦‚ä¸‹:

1. å°† <strong style="color:blue;">å­˜å‚¨å˜é‡</strong> èµ‹å€¼ç»™ **å­˜å‚¨å˜é‡** (åŒç±»å‹)
   - `å€¼ ç±» å‹`: åˆ›å»ºä¸€ä¸ªæ–°å‰¯æœ¬ã€‚
   - `å¼•ç”¨ç±»å‹`: åˆ›å»ºä¸€ä¸ªæ–°å‰¯æœ¬ã€‚
2. å°† <strong style="color:red;">å†…å­˜å˜é‡</strong> èµ‹å€¼ç»™ **å­˜å‚¨å˜é‡**
   - `å€¼ ç±» å‹`: åˆ›å»ºä¸€ä¸ªæ–°å‰¯æœ¬ã€‚
   - `å¼•ç”¨ç±»å‹`: åˆ›å»ºä¸€ä¸ªæ–°å‰¯æœ¬ã€‚
3. å°† <strong style="color:blue;">å­˜å‚¨å˜é‡</strong> èµ‹å€¼ç»™ å†…å­˜å˜é‡
   - `å€¼ ç±» å‹`: åˆ›å»ºä¸€ä¸ªæ–°å‰¯æœ¬ã€‚
   - `å¼•ç”¨ç±»å‹`: åˆ›å»ºä¸€ä¸ªæ–°å‰¯æœ¬ã€‚
4. å°† <strong style="color:red;">å†…å­˜å˜é‡</strong> èµ‹å€¼ç»™ å†…å­˜å˜é‡ (åŒç±»å‹)
   - `å€¼ ç±» å‹`: åˆ›å»ºä¸€ä¸ªæ–°å‰¯æœ¬ã€‚
   - `å¼•ç”¨ç±»å‹`: ä¸ä¼šåˆ›å»ºå‰¯æœ¬ã€‚(**é‡è¦**)

####  å°†<strong style="color:blue;">å­˜å‚¨å˜é‡</strong>èµ‹å€¼ç»™å­˜å‚¨å˜é‡

å°†ä¸€ä¸ªçŠ¶æ€(å­˜å‚¨)å˜é‡èµ‹å€¼ç»™å¦ä¸€ä¸ªçŠ¶æ€(å­˜å‚¨)å˜é‡ï¼Œå°†åˆ›å»ºä¸€ä¸ªæ–°çš„å‰¯æœ¬ã€‚

- `å€¼ ç±» å‹`: åˆ›å»ºä¸€ä¸ªæ–°å‰¯æœ¬ã€‚
- `å¼•ç”¨ç±»å‹`: åˆ›å»ºä¸€ä¸ªæ–°å‰¯æœ¬ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Locations {
    // å€¼ç±»å‹
    uint256 public stateA1 = 10;
    uint256 public stateA2 = 20;
    // å¼•ç”¨ç±»å‹
    string public stateB1 = "ABCD";
    string public stateB2 = "1234";

    function testA() public returns (uint256) {
        stateA1 = stateA2;
        stateA2 = 30;
        return stateA1; // returns 20
    }

    function testB() public returns (string memory) {
        stateB1 = stateB2;
        bytes(stateB2)[0] = bytes1("9");
        return stateB1; // returns 1234
    }
}
```

**é—®ç­”é¢˜: ä¸Šé¢å‡½æ•° `testA` å’Œ `testB` çš„è¿”å›å€¼æ˜¯ä»€ä¹ˆï¼Ÿ**

- `testA`: ç¬¬ä¸€æ¬¡æ‰§è¡Œè¿”å›å€¼æ˜¯ `20`ï¼Œä¹‹åæ‰§è¡Œè¿”å›å€¼æ˜¯ `30`
- `testB`: ç¬¬ä¸€æ¬¡æ‰§è¡Œè¿”å›å€¼æ˜¯å­—ç¬¦ä¸² `"1234"`ï¼Œä¹‹åæ‰§è¡Œè¿”å›å€¼æ˜¯å­—ç¬¦ä¸² `"9234"`

**å€¼ç±»å‹**: å…ˆå°† stateA2 èµ‹å€¼ç»™ stateA1,å†æŠŠ stateA2 ä¿®æ”¹ï¼›ç»“æœå¾—åˆ°çš„ stateA1 æ˜¯ stateA2 ä¿®æ”¹å‰çš„å€¼ï¼Œè¯´æ˜å¯¹äºå€¼ç±»å‹çš„å±€éƒ¨å˜é‡æ¥è¯´ => åˆ›å»ºä¸€ä¸ªæ–°å‰¯æœ¬ã€‚

**å¼•ç”¨ç±»å‹**: å…ˆå°† stateB2 èµ‹å€¼ç»™ stateB1,å†æŠŠ stateB2 ä¿®æ”¹ï¼›ç»“æœå¾—åˆ°çš„ stateB1 æ˜¯ stateB2 ä¿®æ”¹å‰çš„å€¼ï¼Œè¯´æ˜å¯¹äºå¼•ç”¨ç±»å‹çš„å±€éƒ¨å˜é‡æ¥è¯´ => åˆ›å»ºä¸€ä¸ªæ–°å‰¯æœ¬ã€‚

####  å°†<strong style="color:red;">å†…å­˜å˜é‡</strong>èµ‹å€¼ç»™å­˜å‚¨å˜é‡

å°†å†…å­˜å˜é‡èµ‹å€¼ç»™å­˜å‚¨å˜é‡ï¼Œæ€»ä¼šåˆ›å»ºä¸€ä¸ªæ–°å‰¯æœ¬ã€‚

- `å€¼ ç±» å‹`: åˆ›å»ºä¸€ä¸ªæ–°å‰¯æœ¬ã€‚
- `å¼•ç”¨ç±»å‹`: åˆ›å»ºä¸€ä¸ªæ–°å‰¯æœ¬ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Locations {
    uint256 public stateA1 = 10; //storage
    string public stateB1 = "ABCD";

    function testA() public returns (uint256) {
        uint256 memoryA2 = 20; // memory
        stateA1 = memoryA2;
        memoryA2 = 40;
        return stateA1; // returns 20
    }

    function testB() public returns (string memory) {
        string memory memoryB2 = "1234"; // memory
        stateB1 = memoryB2;
        bytes(memoryB2)[0] = bytes1("9");
        return stateB1; // returns 1234
    }
}
```

**é—®ç­”é¢˜: ä¸Šé¢å‡½æ•° `testA` å’Œ `testB` çš„è¿”å›å€¼æ˜¯ä»€ä¹ˆï¼Ÿ**

- `testA`: æ°¸è¿œè¿”å› `20`
- `testB`: æ°¸è¿œè¿”å›å­—ç¬¦ä¸² `"1234"`

**å€¼ç±»å‹**: å…ˆå°† memoryA2 èµ‹å€¼ç»™ stateA1,å†æŠŠ memoryA2 ä¿®æ”¹ï¼›ç»“æœå¾—åˆ°çš„ stateA1 æ˜¯ memoryA2 ä¿®æ”¹å‰çš„å€¼ï¼Œè¯´æ˜å¯¹äºå€¼ç±»å‹çš„å±€éƒ¨å˜é‡æ¥è¯´ => åˆ›å»ºä¸€ä¸ªæ–°å‰¯æœ¬ã€‚

**å¼•ç”¨ç±»å‹**: å…ˆå°† memoryB2 èµ‹å€¼ç»™ stateB1,å†æŠŠ memoryB2 ä¿®æ”¹ï¼›ç»“æœå¾—åˆ°çš„ stateB1 æ˜¯ memoryB2 ä¿®æ”¹å‰çš„å€¼ï¼Œè¯´æ˜å¯¹äºå¼•ç”¨ç±»å‹çš„å±€éƒ¨å˜é‡æ¥è¯´ => åˆ›å»ºä¸€ä¸ªæ–°å‰¯æœ¬ã€‚

####  å°†<strong style="color:blue;">å­˜å‚¨å˜é‡</strong>èµ‹å€¼ç»™å†…å­˜å˜é‡

ä»å­˜å‚¨å˜é‡å¤åˆ¶åˆ°å†…å­˜å˜é‡ï¼Œå°†åˆ›å»ºä¸€ä¸ªå‰¯æœ¬ã€‚

- `å€¼ ç±» å‹`: åˆ›å»ºä¸€ä¸ªæ–°å‰¯æœ¬ã€‚
- `å¼•ç”¨ç±»å‹`: åˆ›å»ºä¸€ä¸ªæ–°å‰¯æœ¬ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Locations {
    uint256 public stateA1 = 10; //storage
    string public stateB1 = "ABCD";

    function testA() public returns (uint256) {
        uint256 memoryA2 = 20; // memory
        memoryA2 = stateA1;
        stateA1 = 40;
        return memoryA2; // returns ç¬¬ä¸€æ¬¡æ˜¯ 10, ä»¥åéƒ½æ˜¯40
    }

    function testB() public returns (string memory) {
        string memory memoryB2 = "1234"; // memory
        memoryB2 = stateB1;
        bytes(stateB1)[0] = bytes1("9");
        return memoryB2; // returns ç¬¬ä¸€æ¬¡æ˜¯ "ABCD", ä»¥åéƒ½æ˜¯ "9BCD"
    }
}
```

**é—®ç­”é¢˜: ä¸Šé¢å‡½æ•° testA å’Œ testB çš„è¿”å›å€¼æ˜¯ä»€ä¹ˆï¼Ÿ**

- `testA`: ç¬¬ä¸€æ¬¡æ‰§è¡Œè¿”å›å€¼æ˜¯ 10ï¼Œä¹‹åæ‰§è¡Œè¿”å›å€¼æ˜¯ 40
- `testB`: ç¬¬ä¸€æ¬¡æ‰§è¡Œè¿”å›å€¼æ˜¯å­—ç¬¦ä¸² `"ABCD"`ï¼Œä¹‹åæ‰§è¡Œè¿”å›å€¼æ˜¯å­—ç¬¦ä¸² `"9BCD"`

**å€¼ç±»å‹**: å…ˆå°† stateA1 èµ‹å€¼ç»™ memoryA2,å†æŠŠ stateA1 ä¿®æ”¹ï¼›ç»“æœå¾—åˆ°çš„ memoryA2 æ˜¯ stateA1 ä¿®æ”¹å‰çš„å€¼ï¼Œè¯´æ˜å¯¹äºå€¼ç±»å‹çš„å±€éƒ¨å˜é‡æ¥è¯´ => åˆ›å»ºä¸€ä¸ªæ–°å‰¯æœ¬ã€‚

**å¼•ç”¨ç±»å‹**: å…ˆå°† stateB1 èµ‹å€¼ç»™ memoryB2,å†æŠŠ stateB1 ä¿®æ”¹ï¼›ç»“æœå¾—åˆ°çš„ memoryB2 æ˜¯ stateB1 ä¿®æ”¹å‰çš„å€¼ï¼Œè¯´æ˜å¯¹äºå¼•ç”¨ç±»å‹çš„å±€éƒ¨å˜é‡æ¥è¯´ => åˆ›å»ºä¸€ä¸ªæ–°å‰¯æœ¬ã€‚

####  å°†<strong style="color:red;">å†…å­˜å˜é‡</strong>èµ‹å€¼ç»™å†…å­˜å˜é‡

- å¯¹äºå€¼ç±»å‹çš„å±€éƒ¨å˜é‡: åˆ›å»ºä¸€ä¸ªæ–°å‰¯æœ¬ã€‚
- å¯¹äºå¼•ç”¨ç±»å‹å±€éƒ¨å˜é‡: **ä¸ä¼šåˆ›å»ºå‰¯æœ¬**ã€‚(é‡è¦)

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Locations {
    function testA() public pure returns (uint256) {
        uint256 memoryA1 = 10; // memory
        uint256 memoryA2 = 20; // memory
        memoryA1 = memoryA2;
        memoryA2 = 40;
        return memoryA1; // returns æ°¸è¿œæ˜¯ 20
    }

    function testB() public pure returns (string memory) {
        string memory memoryB1 = "ABCD"; // memory
        string memory memoryB2 = "1234"; // memory
        memoryB1 = memoryB2;
        bytes(memoryB2)[0] = bytes1("9");
        return memoryB1; // returns æ°¸è¿œæ˜¯ "9234"
    }
}
```

**é—®ç­”é¢˜: ä¸Šé¢å‡½æ•° testA å’Œ testB çš„è¿”å›å€¼æ˜¯ä»€ä¹ˆï¼Ÿ**

- `testA`: æ°¸è¿œæ˜¯ `20`
- `testB`: æ°¸è¿œæ˜¯å­—ç¬¦ä¸² `"9234"`

**å€¼ç±»å‹**: å…ˆå°† memoryA2 èµ‹å€¼ç»™ memoryA1,å†æŠŠ memoryA2 ä¿®æ”¹ï¼›ç»“æœå¾—åˆ°çš„ memoryA1 æ˜¯ memoryA2 ä¿®æ”¹å‰çš„å€¼ï¼Œè¯´æ˜å¯¹äºå€¼ç±»å‹çš„å±€éƒ¨å˜é‡æ¥è¯´ï¼Œæ­¤æ—¶ä»ç„¶åˆ›å»ºä¸€ä¸ªæ–°å‰¯æœ¬ã€‚

**å¼•ç”¨ç±»å‹**: å…ˆå°† memoryB2 èµ‹å€¼ç»™ memoryB1,å†æŠŠ memoryB2 ä¿®æ”¹ï¼›ç»“æœå¾—åˆ°çš„ memoryB1 æ˜¯ memoryB2 ä¿®æ”¹åçš„å€¼ã€‚è¯´æ˜å®ƒä»¬éƒ½æŒ‡å‘ç›¸åŒçš„å­˜å‚¨ä½ç½®ï¼Œå¹¶ä¸ä¼šåˆ›å»ºæ–°å‰¯æœ¬ã€‚

âš ï¸ é‡ç‚¹ï¼š**å¯¹äºå¼•ç”¨ç±»å‹çš„å±€éƒ¨å˜é‡ï¼Œä»ä¸€ä¸ªå†…å­˜å˜é‡å¤åˆ¶åˆ°å¦ä¸€ä¸ªå†…å­˜å˜é‡ä¸ä¼šåˆ›å»ºå‰¯æœ¬ï¼Œå…±äº«å†…å­˜**ã€‚

####  å°ç»“

æ•°æ®ä½ç½®ä¸ä»…ä»…è¡¨ç¤ºæ•°æ®å¦‚ä½•ä¿å­˜ï¼Œå®ƒåŒæ ·å½±å“ç€èµ‹å€¼è¡Œä¸ºï¼š

- åœ¨ storage å’Œ memory ä¹‹é—´ä¸¤ä¸¤èµ‹å€¼ï¼ˆæˆ–è€…ä» calldata èµ‹å€¼ ï¼‰ï¼Œéƒ½ä¼šåˆ›å»ºä¸€ä»½ç‹¬ç«‹çš„æ‹·è´ã€‚
- ä» memory åˆ° memory çš„èµ‹å€¼åªåˆ›å»ºå¼•ç”¨ï¼Œè¿™æ„å‘³ç€æ›´æ”¹å†…å­˜å˜é‡ï¼Œå…¶ä»–å¼•ç”¨ç›¸åŒæ•°æ®çš„æ‰€æœ‰å…¶ä»–å†…å­˜å˜é‡çš„å€¼ä¹Ÿä¼šè·Ÿç€æ”¹å˜ã€‚
- ä» storage åˆ°æœ¬åœ°å­˜å‚¨å˜é‡çš„èµ‹å€¼ä¹Ÿåªåˆ†é…ä¸€ä¸ªå¼•ç”¨ã€‚
- å…¶ä»–çš„å‘ storage çš„èµ‹å€¼ï¼Œæ€»æ˜¯è¿›è¡Œæ‹·è´ã€‚ è¿™ç§æƒ…å†µçš„ç¤ºä¾‹ï¼Œå¦‚å¯¹çŠ¶æ€å˜é‡æˆ– storage çš„ç»“æ„ä½“ç±»å‹çš„å±€éƒ¨å˜é‡æˆå‘˜çš„èµ‹å€¼ï¼Œå³ä½¿å±€éƒ¨å˜é‡æœ¬èº«æ˜¯ä¸€ä¸ªå¼•ç”¨ï¼Œä¹Ÿä¼šè¿›è¡Œä¸€ä»½æ‹·è´ã€‚

### æ·±åˆ»ç†è§£å¼•ç”¨ç±»å‹èµ‹å€¼å’Œä¿®æ”¹

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Locations {
    string public stateB1 = "ABCD";
    struct MyStruct {
        string name;
        uint256 age;
    }
    mapping(address => MyStruct) public stateC1;

    constructor() {
        stateC1[msg.sender] = MyStruct({name: "Anbang", age: 1});
    }

    function testB1() public returns (string memory, string memory) {
        string memory memoryB2 = "1234"; // memory
        stateB1 = memoryB2;

        // storage ä¿®æ”¹:ä¼šæ”¹å˜çŠ¶æ€å˜é‡
        string storage stateB3 = stateB1;
        bytes(stateB3)[0] = bytes1("9");
        return (stateB1, stateB3);
        // returns (9234,9234)
        // å‚¨å­˜ç©ºé—´ä¸­ stateB1 = 9234
    }

    function testB2() public returns (string memory, string memory) {
        string memory memoryB2 = "1234"; // memory
        stateB1 = memoryB2;

        // memory ä¿®æ”¹:ä¸ä¼šæ”¹å˜çŠ¶æ€å˜é‡
        string memory memoryB3 = stateB1;
        bytes(memoryB3)[0] = bytes1("9");
        return (stateB1, memoryB3);
        // returns (1234,9234)
        // å‚¨å­˜ç©ºé—´ä¸­ stateB1 = 1234
    }

    function testC1() external returns (MyStruct memory, MyStruct memory) {
        MyStruct memory memoryC2 = MyStruct({name: "Anbang1", age: 18});
        stateC1[msg.sender] = memoryC2;

        // storage ä¿®æ”¹:ä¼šæ”¹å˜çŠ¶æ€å˜é‡
        MyStruct storage stateC3 = stateC1[msg.sender];
        stateC3.age++;
        return (stateC1[msg.sender], stateC3);
        // returns ({name: "Anbang1", age: 19},{name: "Anbang1", age: 19})
        // å‚¨å­˜ç©ºé—´ä¸­ stateC1 = {name: "Anbang1", age: 19}
    }

    function testC2() external returns (MyStruct memory, MyStruct memory) {
        MyStruct memory memoryC2 = MyStruct({name: "Anbang2", age: 18});
        stateC1[msg.sender] = memoryC2;

        // memory ä¿®æ”¹:ä¸ä¼šæ”¹å˜çŠ¶æ€å˜é‡
        MyStruct memory memoryC3 = stateC1[msg.sender];
        memoryC3.age++;
        return (stateC1[msg.sender], memoryC3);
        // returns ({name: "Anbang2", age: 18},{name: "Anbang2", age: 19})
        // å‚¨å­˜ç©ºé—´ä¸­ stateC1 = {name: "Anbang2", age: 18}
    }
}
```

é—®ç­”é¢˜ï¼š

- testB1 è¿è¡Œåï¼Œè¿”å›ä»€ä¹ˆï¼Ÿ
  - `(9234,9234)`
- testB2 è¿è¡Œåï¼Œè¿”å›ä»€ä¹ˆï¼Ÿ
  - `(1234,9234)`
- testC1 è¿è¡Œåï¼Œè¿”å›ä»€ä¹ˆï¼Ÿ
  - `({name: "Anbang1", age: 19},{name: "Anbang1", age: 19})`
- testC2 è¿è¡Œåï¼Œè¿”å›ä»€ä¹ˆï¼Ÿ
  - `({name: "Anbang2", age: 18},{name: "Anbang2", age: 19})`

### calldata å’Œ memeory åŒºåˆ«

**å‡½æ•°è°ƒç”¨å‡½æ•°æ—¶çš„åŒºåˆ«**:

####  `calldataå¯ä»¥éšå¼è½¬æ¢ä¸ºmemory`

- calldata å‚æ•°å¯ä»¥éšå¼è½¬æ¢ä¸º memory
- memory å‚æ•°ä¸å¯ä»¥éšå¼è½¬æ¢ä¸º calldata

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract DataLocations {
    function memoryFn(uint256[] memory _mm)
        private
        pure
        returns (uint256[] memory memArr)
    {
        memArr = new uint256[](_mm.length);
        for (uint256 index = 0; index < _mm.length; index++) {
            memArr[index] = _mm[index];
        }
    }

    function calldataFn(uint256[] calldata _mm)
        private
        pure
        returns (uint256[] memory memArr)
    {
        memArr = new uint256[](_mm.length);
        for (uint256 index = 0; index < _mm.length; index++) {
            memArr[index] = _mm[index];
        }
    }


    function examples1(uint256[] memory _mm)
        external
        pure
        returns (uint256[] memory memArr)
    {
        // memoryFn å‚æ•°æ˜¯ memoryï¼Œå¯ä»¥è°ƒç”¨
        // calldataFn å‚æ•°æ˜¯ calldata ï¼Œä¸å¯ä»¥è°ƒç”¨ï¼Œ memory ä¸å¯ä»¥éšå¼è½¬æ¢ä¸º calldata
        // memory å‚æ•°ï¼Œè°ƒç”¨éœ€è¦ memory å‚æ•°çš„å‡½æ•°: æˆåŠŸ
        memArr = memoryFn(_mm);

        // memory ä¸èƒ½éšå¼è½¬æ¢ä¸º calldata
        // memArr = calldataFn(_mm); // memory å‚æ•°ï¼Œè°ƒç”¨éœ€è¦ calldata å‚æ•°çš„å‡½æ•°: ç¦æ­¢
    }

    function examples2(uint256[] calldata _mm)
        external
        pure
        returns (uint256[] memory memArr)
    {
        // calldata å‚æ•°ï¼Œè°ƒç”¨éœ€è¦ calldata å‚æ•°çš„å‡½æ•°: æˆåŠŸ
        memArr = calldataFn(_mm);

        // memoryFn å‚æ•°æ˜¯ memoryï¼Œå¯ä»¥è°ƒç”¨ï¼Œcalldataå¯ä»¥éšå¼è½¬æ¢ä¸º memory
        // calldataFn å‚æ•°æ˜¯ calldata ï¼Œç›´æ¥ä½¿ç”¨calldataæ›´çœgas
        // calldataï¼ˆå°:çº¦æŸå¤šï¼‰ å¯ä»¥éšå¼çš„è½¬æ¢ memoryï¼ˆå¤§ï¼‰
        // calldata å‚æ•°ï¼Œè°ƒç”¨éœ€è¦ memory å‚æ•°çš„å‡½æ•°: æˆåŠŸ
        // memArr = memoryFn(_mm);
    }

}
```

####  calldata å’Œ memeory å¯¹æ¯”

```
contract Test {
    function memoryFn(uint256[] memory _num)
        public
        pure
        returns (uint256[] memory)
    {
        _num[0] = 999; // ä¿®æ”¹å‚æ•°
        return (_num);
    }

    function calldataFn(uint256[] calldata _num)
        public
        pure
        returns (uint256[] calldata)
    {
        // _num[0] = 999; // ç¦æ­¢ä¿®æ”¹ calldata æ•°æ®
        return (_num);
    }
}
```

## å¼•ç”¨ç±»å‹

Solidity ä¸­ï¼Œæœ‰ä¸€äº›æ•°æ®ç±»å‹ç”±å€¼ç±»å‹ç»„åˆè€Œæˆï¼Œç›¸æ¯”äºç®€å•çš„å€¼ç±»å‹ï¼Œè¿™äº›ç±»å‹é€šå¸¸é€šè¿‡åç§°å¼•ç”¨ï¼Œè¢«ç§°ä¸ºå¼•ç”¨ç±»å‹ã€‚

- array
  - åŸºæœ¬ç±»å‹ç»„æˆçš„æ•°ç»„é›†åˆã€‚
  ```
  uint256[5] public T1 = [1, 2, 3, 4, 5];
  address[5] public A = [0xff...6ac];
  byte[5] public A = [0xff...6ac];
  ```
  - å­—ç¬¦ä¸²ä¸ bytes æ˜¯ç‰¹æ®Šçš„æ•°ç»„ï¼Œæ‰€ä»¥ä¹Ÿæ˜¯å¼•ç”¨ç±»å‹
- string: æ˜¯ä¸€ä¸ªåŠ¨æ€å°ºå¯¸çš„ utf-8 ç¼–ç å­—ç¬¦ä¸²
  - ä»–å…¶å®æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„å¯å˜å­—èŠ‚æ•°ç»„ï¼ŒåŒæ—¶å…¶ä¹Ÿæ˜¯ä¸€ä¸ªå¼•ç”¨ç±»å‹
- bytes: åŠ¨æ€åå…­è¿›åˆ¶å­—èŠ‚æ•°ç»„
  - bytes ç±»ä¼¼äº `byte[]`ï¼Œä½†å®ƒåœ¨ calldata ä¸­è¢«ç´§å¯†åœ°æ‰“åŒ…ã€‚å› æ­¤ï¼Œç›¸æ¯”äº `byte[]`ï¼Œbytes åº”è¯¥ä¼˜å…ˆä½¿ç”¨ï¼Œå› ä¸ºæ›´ä¾¿å®œã€‚
  - string ç­‰ä»·äº bytesï¼Œä½†ä¸å…è®¸é•¿åº¦æˆ–ç´¢å¼•è®¿é—®ã€‚
- mapping
- structï¼šä¸ºäº†å…è®¸ evm çš„ä¼˜åŒ–ï¼Œè¯·ç¡®ä¿ storage ä¸­çš„å˜é‡å’Œ `struct` æˆå‘˜çš„ä¹¦å†™é¡ºåºå…è®¸å®ƒä»¬è¢«ç´§å¯†åœ°æ‰“åŒ…ã€‚ä¾‹å¦‚ï¼Œåº”è¯¥æŒ‰ç…§ `uint128ï¼Œuint128ï¼Œuint256` çš„é¡ºåºæ¥å£°æ˜çŠ¶æ€å˜é‡ï¼Œè€Œä¸æ˜¯ä½¿ç”¨ `uint128ï¼Œuint256ï¼Œuint128`ï¼Œå› ä¸ºå‰è€…åªå ç”¨ä¸¤ä¸ªå­˜å‚¨æ’æ§½ï¼Œè€Œåè€…å°†å ç”¨ä¸‰ä¸ªã€‚

### array æ•°ç»„

æ•°ç»„æ˜¯å­˜å‚¨**åŒç±»å…ƒç´ çš„æœ‰åºé›†åˆ**ã€‚æ•°ç»„å£°æ˜æ—¶å¯ä»¥æ˜¯å›ºå®šå¤§å°çš„ï¼Œä¹Ÿå¯ä»¥æ˜¯åŠ¨æ€è°ƒæ•´é•¿åº¦ã€‚

ä¸‹é¢æ˜¯ array çš„æ€»ç»“:

- å£°æ˜å’Œåˆå§‹åŒ–æ•°ç»„
  - æ•°ç»„å…ƒç´ å¯ä»¥æ˜¯ä»»ä½•ç±»å‹ï¼ŒåŒ…æ‹¬æ˜ å°„æˆ–ç»“æ„ä½“ã€‚å¯¹ç±»å‹çš„é™åˆ¶æ˜¯æ˜ å°„åªèƒ½å­˜å‚¨åœ¨ å­˜å‚¨ storage ä¸­ï¼Œå¹¶ä¸”å…¬å¼€è®¿é—®å‡½æ•°çš„å‚æ•°éœ€è¦æ˜¯ ABI ç±»å‹ã€‚
- è®¿é—®å’Œä¿®æ”¹æ•°ç»„å…ƒç´ 
  - `arr[_index]`:
    - é€šè¿‡ç´¢å¼•è¿›è¡Œè·å–ç‰¹å®šå…ƒç´ 
    - å¯ä»¥é€šè¿‡ç´¢å¼•ä¿®æ”¹å€¼
  - çŠ¶æ€å˜é‡æ ‡è®° `public` çš„æ•°ç»„ï¼ŒSolidity åˆ›å»ºä¸€ä¸ª `getterå‡½æ•°` ã€‚ ä¸‹æ ‡çš„ç´¢å¼•æ•°å­—å°±æ˜¯ `getterå‡½æ•°` çš„å‚æ•°ã€‚
  - è®¿é—®è¶…å‡ºæ•°ç»„é•¿åº¦çš„å…ƒç´ ä¼šå¯¼è‡´å¼‚å¸¸ï¼ˆassert ç±»å‹å¼‚å¸¸ ï¼‰ã€‚ å¯ä»¥ä½¿ç”¨ .push() æ–¹æ³•åœ¨æœ«å°¾è¿½åŠ ä¸€ä¸ªæ–°å…ƒç´ ï¼Œå…¶ä¸­ .push() è¿½åŠ ä¸€ä¸ªé›¶åˆå§‹åŒ–çš„å…ƒç´ å¹¶è¿”å›å¯¹å®ƒçš„å¼•ç”¨ã€‚
- å‡½æ•°ä¸­è¿”å›æ•°ç»„
  - å¦‚æœæƒ³æŠŠæ•°ç»„å…¨éƒ¨è¿”å›ï¼Œéœ€è¦é€šè¿‡å‡½æ•°è¿›è¡Œæ“ä½œã€‚åœ¨å‡½æ•°ä¸­è¿”å›æ•°ç»„
- åŠ¨æ€æ•°ç»„å’Œå®šé•¿æ•°ç»„
  - åŠ¨æ€æ•°ç»„åªèƒ½å­˜åœ¨äºçŠ¶æ€å˜é‡ä¸­
  - å†…å­˜ä¸­åªèƒ½åˆ›å»ºå®šé•¿æ•°ç»„
- åˆ›å»ºå†…å­˜æ•°ç»„
  - å¯¹äº storage æ•°ç»„ï¼Œå…ƒç´ å¯ä»¥æ˜¯ä»»æ„ç±»å‹(å…¶ä»–æ•°ç»„ã€æ˜ å°„æˆ–ç»“æ„)ã€‚
  - å¯¹äº memory æ•°ç»„ï¼Œå…ƒç´ ç±»å‹ä¸èƒ½æ˜¯æ˜ å°„ç±»å‹ï¼Œå¦‚æœå®ƒæ˜¯ä¸€ä¸ª public å‡½æ•°çš„å‚æ•°ï¼Œé‚£ä¹ˆå…ƒç´ ç±»å‹å¿…é¡»æ˜¯ ABI ç±»å‹ã€‚
- æ•°ç»„çš„å±æ€§
  - `length`: è·å–æ•°ç»„çš„é•¿åº¦
- æ•°ç»„çš„æ–¹æ³•
  - push : åªæœ‰åŠ¨æ€æ•°ç»„å¯ä»¥ä½¿ç”¨ï¼Œåªèƒ½ç”¨åœ¨åŠ¨æ€æ•°ç»„ä¸Š
  - pop: åˆ é™¤æœ€åä¸€ä¸ªé•¿åº¦ï¼Œåªèƒ½ç”¨åœ¨åŠ¨æ€æ•°ç»„ä¸Š
  - delete: æ¸…ç©ºå¯¹åº”çš„ç´¢å¼•ï¼›æ¸…ç©ºä¸æ˜¯åˆ é™¤ï¼Œå¹¶ä¸ä¼šæ”¹å˜é•¿åº¦ï¼Œç´¢å¼•ä½ç½®çš„å€¼ä¼šæ”¹ä¸ºé»˜è®¤å€¼ã€‚
  - æ•°ç»„åˆ‡ç‰‡: `x[start:end]`
- å†™ä¸€ä¸ªå®Œå…¨åˆ é™¤çš„ delete æ–¹æ³•

####  æ•°ç»„çš„åˆ›å»º

æ•°ç»„é•¿åº¦ä¸Šåˆ†ä¸º **å›ºå®šé•¿åº¦æ•°ç»„** å’Œ **å¯å˜é•¿åº¦æ•°ç»„**ï¼Œç±»å‹ä¸Šåˆ†ä¸º**ä¸€ç»´æ•°ç»„**å’Œ**å¤šç»´æ•°ç»„**ï¼›

ä¸€ä¸ªå…ƒç´ ç±»å‹ä¸º `T`ï¼Œå›ºå®šé•¿åº¦ä¸º `k` çš„æ•°ç»„å¯ä»¥å£°æ˜ä¸º `T[k]`ï¼Œè€ŒåŠ¨æ€æ•°ç»„å£°æ˜ä¸º `T[]`ã€‚

- å›ºå®šé•¿åº¦æ•°ç»„:åˆ›å»º
- å¯å˜é•¿åº¦æ•°ç»„:åˆ›å»º
- äºŒç»´æ•°ç»„:åˆ›å»º
- å…¶å®ƒ
  - `uint256[2][] public T = new uint256[2][](10);`

##### **å›ºå®šé•¿åº¦æ•°ç»„:åˆ›å»º**

å›ºå®šé•¿åº¦æ•°ç»„:åˆ›å»º

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    // å›ºå®šé•¿åº¦æ•°ç»„
    uint256[5] public T = [1, 2, 3, 4, 5];
    address[5] public A =   [0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac];
    uint256[10] public arr1 = [0, 1, 2]; // èµ‹å€¼çš„æ•°ç»„é•¿åº¦ä¸è¶…è¿‡10éƒ½å¯ä»¥
    uint256[10] public arr2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

    // å¦‚æœåˆå§‹åŒ–è¶…å‡ºäº†æ•°ç»„çš„é¢„æœŸé•¿åº¦ï¼ŒæŠ¥é”™:
    // Type uint8[11] memory is not implicitly convertible to expected
    // type uint256[10] storage ref.
    // uint256[10] public arr3 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
}
```

- è¯­æ³•: `type[arraySize] arrayName;`ï¼Œè¿™æ˜¯ä¸€ç»´æ•°ç»„ï¼Œå…¶ä¸­ arraySize å¿…é¡»æ˜¯ä¸€ä¸ªå¤§äºé›¶çš„æ•´æ•°æ•°å­—ï¼Œtype å¯ä»¥æ˜¯ä»»ä½•æ•°æ®ç±»å‹ã€‚
- å›ºå®šé•¿åº¦æ•°ç»„åˆ›å»ºåä¸å¯å¯¹é•¿åº¦è¿›è¡Œä¿®æ”¹,ä½†æ˜¯å¯ä»¥å¯¹å†…å®¹è¿›è¡Œä¿®æ”¹
  - ï¼ˆä¸å¯å¯¹é•¿åº¦è¿›è¡Œä¿®æ”¹æ˜¯ä¸ä¸å¯å˜å­—èŠ‚æ•°ç»„ä¹‹é—´ä¸åŒç‚¹ï¼‰

**æ•°ç»„å…ˆå£°æ˜å†èµ‹å€¼**

é€šè¿‡ç´¢å¼•è¿›è¡Œèµ‹å€¼ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    uint256[10] public arr1;

    function test() external {
        arr1[0] = 1;
        arr1[1] = 10;
        arr1[2] = 100;
        arr1[9] = 900;
    }
}
```

##### **å¯å˜é•¿åº¦æ•°ç»„:åˆ›å»º**

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    // å¯å˜é•¿åº¦æ•°ç»„
    uint256[] public T1 = [1, 2, 3, 4, 5]; // æ–¹å¼ 1
    uint256[] public T2 = new uint256[](5); // æ–¹å¼ 2
}
```

- æ–¹å¼ 1: `uint256[] T1 = [1, 2, 3, 4, 5];`
  - è¯¥æ–¹å¼ä¸å¯ä»¥åœ¨å‡½æ•°å†…åˆ›å»º
- æ–¹å¼ 2: `uint256[] T2 = new uint256[](5);`
  - ç”¨æ–¹å¼ 2 åˆ›å»ºæ•°ç»„æ—¶ï¼Œè‹¥æ•°ç»„ä¸ºæˆå‘˜å˜é‡, åˆ™é»˜è®¤ä¸º storage ç±»å‹ï¼›
  - è‹¥ä¸ºå±€éƒ¨å˜é‡é»˜è®¤ä¸º `memory` ç±»å‹ï¼Œ`memory` ç±»å‹çš„æ•°ç»„ï¼Œå¿…é¡»å£°æ˜é•¿åº¦ï¼Œå¹¶ä¸”é•¿åº¦åˆ›å»ºåä¸å¯å˜ã€‚
  - `push` æ–¹æ³•ä¸èƒ½ç”¨åœ¨ `memeory` çš„æ•°ç»„ä¸Š,åªèƒ½é€ä¸ªç´¢å¼•çš„èµ‹å€¼ã€‚

##### å†…å­˜ä¸­åˆ›å»ºæ•°ç»„

ä¸èƒ½ç›´æ¥åˆ›å»ºï¼š

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    uint256[] public x = [uint256(1), 3, 4];

    // ä¸‹é¢è¿™æ®µä»£ç å¹¶ä¸èƒ½ç¼–è¯‘ã€‚
    function f() public {
        uint256[] memory x = [uint256(1), 3, 4];
    }
}
```

å¯ä»¥ä½¿ç”¨ `new` å…³é”®å­—åœ¨å†…å­˜ä¸­åˆ›å»ºåŠ¨æ€æ•°ç»„ã€‚åˆ›å»ºæ ¼å¼: `uint256[] memory x = new uint256[](3);`

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract C {
    function f() public pure {
        uint256[] memory x = new uint256[](3);
    }
}
```

- å†…å­˜ä¸­åˆ›å»ºçš„æ•°ç»„æ˜¯å±€éƒ¨å˜é‡ã€‚
- å†…å­˜ä¸­ä¸èƒ½åˆ›å»ºåŠ¨æ€æ•°ç»„ï¼Œå¿…é¡»åˆ›å»ºå®šé•¿æ•°ç»„ã€‚
  - æ€è€ƒ: æ’å…¥æ’åºçš„ä¾‹å­ä¸­ï¼Œä¼˜åŒ–åçš„ä»£ç æ˜¯åŠ¨æ€æ•°ç»„ï¼Œè¿˜æ˜¯å®šé•¿æ•°ç»„ï¼Ÿ(æ’å…¥æ’åºåœ¨åé¢ç®—æ³•é‚£ä¸€ç« )

memory ç±»å‹çš„æ•°ç»„é•¿åº¦åˆ›å»ºåä¸å¯å˜ï¼Œä¸èƒ½é€šè¿‡ä¿®æ”¹æˆå‘˜å˜é‡ `.push` æ”¹å˜ memory æ•°ç»„çš„å¤§å°ã€‚å¿…é¡»æå‰è®¡ç®—æ•°ç»„å¤§å°ï¼Œæˆ–è€…åˆ›å»ºä¸€ä¸ªæ–°çš„å†…å­˜æ•°ç»„å¹¶å¤åˆ¶æ¯ä¸ªå…ƒç´ ã€‚

ä¾‹å­ 0 : æ˜¾ç¤ºç»™å„ä¸ªå…ƒç´ èµ‹å€¼:

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract C {
    function f() public pure {
        uint256[] memory x = new uint256[](3);
        x[0] = 1;
        x[1] = 3;
        x[2] = 4;
    }
}
```

ä¾‹å­ 1: æ–°åˆ†é…çš„æ•°ç»„å…ƒç´ æ€»æ˜¯ä»¥ é»˜è®¤å€¼ åˆå§‹åŒ–ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract FunctionOutputs {
    function examples1() external pure returns (uint256[] memory) {
        uint256[] memory a = new uint256[](5);
        a[1] = 1;
        a[2] = 2;
        a[3] = 3;
        a[4] = 4;
        return a;
    }

    // åœ¨ Solidity ä¸­çš„æ‰€æœ‰å˜é‡ï¼Œæ–°åˆ†é…çš„æ•°ç»„å…ƒç´ æ€»æ˜¯ä»¥ é»˜è®¤å€¼ åˆå§‹åŒ–ã€‚
    function examples2(uint256 _len)
        external
        pure
        returns (uint256[] memory b)
    {
        require(_len > 1, "length > 1");
        b = new uint256[](_len);
        b[0] = 666;
    }

    function examples3(uint256 _len) external pure returns (bytes memory b) {
        require(_len > 1, "length > 1");
        b = new bytes(_len);
        b[0] = bytes1("A");
    }
}
```

##### åŠ¨æ€æ•°ç»„å’Œå®šé•¿æ•°ç»„çš„ gas åŒºåˆ«

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract FunctionOutputs {
    // 26086 gas
    uint256[] public nums = [1, 2, 3];

    // 23913 gas
    uint256[3] public numsFixed = [1, 2, 3];
}
```

åœ¨ Remix ä¸­éƒ¨ç½²åï¼Œå¦‚æœè·å– numsï¼Œéœ€è¦ä¼ å…¥ç´¢å¼•è·å– nums çš„å¯¹åº” inedx å€¼ã€‚å…¶ä¸­åŠ¨æ€æ•°ç»„ nums æŸ¥çœ‹éœ€è¦ 26086 gasï¼Œå®šé•¿æ•°ç»„ numsFixed æŸ¥çœ‹ä»…éœ€ 23913 gasã€‚**å¦‚æœèƒ½ä½¿ç”¨å®šé•¿æ•°ç»„ï¼Œå°±ä½¿ç”¨å®šé•¿æ•°ç»„ï¼Œå› ä¸ºå®ƒå¾ˆä¾¿å®œã€‚**

##### **äºŒç»´æ•°ç»„:åˆ›å»º**:

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    // length:3
    uint256[2][3] public T = [[1, 2], [3, 4], [5, 6]];

    function getLength() external view returns (uint256) {
        return T.length;
    }
}
```

- ä¸¾ä¸ªä¾‹å­ï¼Œä¸€ä¸ªé•¿åº¦ä¸º `5`ï¼Œå…ƒç´ ç±»å‹ä¸º uint çš„åŠ¨æ€æ•°ç»„çš„æ•°ç»„ï¼ˆäºŒç»´æ•°ç»„ï¼‰ï¼Œåº”å£°æ˜ä¸º `uint[][5]` ï¼ˆæ³¨æ„è¿™é‡Œè·Ÿå…¶å®ƒè¯­è¨€æ¯”ï¼Œæ•°ç»„é•¿åº¦çš„å£°æ˜ä½ç½®æ˜¯åçš„ï¼‰ã€‚åœ¨ Solidity ä¸­ï¼Œ `X[3]` æ€»æ˜¯ä¸€ä¸ªåŒ…å«ä¸‰ä¸ª X ç±»å‹å…ƒç´ çš„æ•°ç»„ï¼Œå³ä½¿ X æœ¬èº«å°±æ˜¯ä¸€ä¸ªæ•°ç»„.
- `uint256[2][3] public T = [[1, 2], [3, 4], [5, 6]];`
- `T.length` ä¸º 3

####  è®¿é—®å’Œä¿®æ”¹æ•°ç»„å…ƒç´ 

- é€šè¿‡ç´¢å¼•è®¿é—®æ•°ç»„å…ƒç´ 
- é€šè¿‡ç´¢å¼•ä¿®æ”¹æ•°ç»„å…ƒç´ 

æ³¨æ„: `arr[index]` ä¸­çš„ index éœ€è¦å°äº `arr.length`ï¼›

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    uint256[10] public arr1 = [0, 1, 2]; // èµ‹å€¼çš„æ•°ç»„é•¿åº¦ä¸è¶…è¿‡10éƒ½å¯ä»¥
    uint256[10] public arr2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

    function test() external view returns (uint256, uint256) {
        return (arr1[2], arr2[5]);
    }

    function modi() external {
        arr1[2] = 666;
        arr2[5] = 666;
    }
}
```

è¿™ç§å¯ä»¥æŸ¥çœ‹åˆ°å…ƒç´ çš„æŒ‡å®šå…ƒç´ ï¼Œä½†æœ‰æ—¶å€™æˆ‘ä»¬å¯èƒ½æƒ³è¦æŸ¥çœ‹å…ƒç´ çš„æ‰€æœ‰å†…å®¹ã€‚è¿™æ—¶å€™å°±éœ€è¦å‡½æ•°å¤„ç†ä¸€ä¸‹ã€‚

####  å‡½æ•°ä¸­è¿”å›æ•´ä¸ªæ•°ç»„

é€šè¿‡å‡½æ•°æŠŠæ•°ç»„çš„æ‰€æœ‰å†…å®¹å…¨éƒ¨è¿”å›ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract FunctionOutputs {
    uint256[] public nums1 = [1, 2, 3];
    uint256[3] public nums2 = [1, 2, 3];

    function test1() external view returns (uint256[] memory) {
        return nums1;
    }

    function test2() external view returns (uint256[3] memory) {
        return nums2;
    }
}
```

####  æ•°ç»„å¸¸é‡

æ­£å¸¸çœ‹åˆ°ä¸‹æ–¹ä»£ç åº”è¯¥æ²¡ä»€ä¹ˆé—®é¢˜ï¼Œä½†æ˜¯æ³¨æ„:å‡½æ•° s ä¸­æ•°ç»„ç±»å‹æ˜¯`uint256`ï¼Œè€Œå‡½æ•° t ä¸­è¾“å…¥çš„æ•°ç»„ç±»å‹æ˜¯`uint8`, è¿™é‡Œéœ€è¦å°† uint8 è½¬æ¢ä¸€ä¸‹`s([uint256(1), uint256(2)]);`;

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract T {
    function s(uint256[2] memory _arr) public {}

    function t() public {
        // Invalid type for argument in function call.
        // Invalid implicit conversion from uint8[2] memory to uint256[2] memory requested.
        // s([1, 2]); // é»˜è®¤è¿™ä¹ˆå†™ä¸è¡Œçš„ âŒ
        s([uint256(1), uint256(2)]); // âœ…
    }
}
```

æ•°ç»„å¸¸é‡ï¼ˆå­—é¢é‡ï¼‰æ˜¯åœ¨æ–¹æ‹¬å·ä¸­ï¼ˆ `[...]` ï¼‰ åŒ…å«ä¸€ä¸ªæˆ–å¤šä¸ªé€—å·åˆ†éš”çš„è¡¨è¾¾å¼ã€‚ä¾‹å¦‚ `[1, a, f(3)]` ã€‚

æ•°ç»„å¸¸é‡çš„ç±»å‹é€šè¿‡ä»¥ä¸‹çš„æ–¹å¼ç¡®å®š:

- å®ƒæ€»æ˜¯ä¸€ä¸ªé™æ€å¤§å°çš„å†…å­˜æ•°ç»„ï¼Œå…¶é•¿åº¦ä¸ºè¡¨è¾¾å¼çš„æ•°é‡ã€‚
- æ•°ç»„çš„åŸºæœ¬ç±»å‹æ˜¯åˆ—è¡¨ä¸Šçš„ç¬¬ä¸€ä¸ªè¡¨è¾¾å¼çš„ç±»å‹ï¼Œä»¥ä¾¿æ‰€æœ‰å…¶ä»–è¡¨è¾¾å¼å¯ä»¥éšå¼åœ°è½¬æ¢ä¸ºå®ƒã€‚å¦‚æœä¸å¯ä»¥è½¬æ¢ï¼Œå°†å‡ºç°ç±»å‹é”™è¯¯ã€‚
- æ‰€æœ‰å…ƒç´ éƒ½éƒ½å¯ä»¥è½¬æ¢ä¸ºåŸºæœ¬ç±»å‹ä¹Ÿæ˜¯ä¸å¤Ÿçš„ã€‚å…¶ä¸­ä¸€ä¸ªå…ƒç´ å¿…é¡»æ˜¯æ˜ç¡®ç±»å‹çš„ã€‚

åœ¨ä¸‹é¢çš„ä¾‹å­ä¸­ï¼Œ`[1, 2, 3]` çš„ç±»å‹æ˜¯ `uint8[3] memory`ã€‚ å› ä¸ºæ¯ä¸ªå¸¸é‡çš„ç±»å‹éƒ½æ˜¯ `uint8` ï¼Œå¦‚æœä½ å¸Œæœ›ç»“æœæ˜¯ `uint256[3] memory` ç±»å‹ï¼Œä½ éœ€è¦å°†ç¬¬ä¸€ä¸ªå…ƒç´ è½¬æ¢ä¸º `uint256` ã€‚è™½ç„¶æ‰€æœ‰å…ƒç´ éƒ½éƒ½å¯ä»¥è½¬æ¢ä¸º`uint256`ï¼Œä½†æ˜¯é»˜è®¤æ˜¯è½¬æ¢ä¸º`uint8`ï¼Œèƒ½è½¬æˆå°çš„ç±»å‹ï¼Œå°±ä¸ä¼šè½¬æˆå¤§çš„ï¼Œè¿™æ˜¯æ•°ç»„å¸¸é‡çš„**æ‡’æƒ°æ€§**ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract LBC {
    function f() public pure returns (uint256[3] memory) {
        return g([uint256(1), 2, 3]);
    }

    function g(uint256[3] memory _arr)
        internal
        pure
        returns (uint256[3] memory)
    {
        return _arr;
    }
}
```

å¦‚ä¸‹æ˜¯ä¸€ä¸ªæ¯”è¾ƒç»å…¸çš„ä¾‹å­

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract T {
    int8[2] public a = [1, -1];
    // int8[2] public a = [int8(1), -1];
}
```

æ•°ç»„å¸¸é‡ `[1, -1]` æ˜¯æ— æ•ˆçš„ï¼Œå› ä¸ºç¬¬ä¸€ä¸ªè¡¨è¾¾å¼ç±»å‹æ˜¯ `uint8` è€Œç¬¬äºŒä¸ªç±»ä¼¼æ˜¯ `int8` ä»–ä»¬ä¸å¯ä»¥éšå¼çš„ç›¸äº’è½¬æ¢ã€‚ ä¸ºäº†ç¡®ä¿å¯ä»¥è¿è¡Œï¼Œä½ æ˜¯å¯ä»¥ä½¿ç”¨ä¾‹å¦‚ï¼š `[int8(1), -1]` ã€‚

ç”±äºä¸åŒç±»å‹çš„å›ºå®šå¤§å°çš„å†…å­˜æ•°ç»„ä¸èƒ½ç›¸äº’è½¬æ¢(å°½ç®¡åŸºç¡€ç±»å‹å¯ä»¥)ï¼Œå¦‚æœä½ æƒ³ä½¿ç”¨äºŒç»´æ•°ç»„å¸¸é‡ï¼Œä½ å¿…é¡»æ˜¾å¼åœ°æŒ‡å®šä¸€ä¸ªåŸºç¡€ç±»å‹:

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    function f() public pure returns (uint24[2][4] memory) {
        // ä¸‹é¢ä»£ç æ— æ³•å·¥ä½œï¼Œå› ä¸ºæ²¡æœ‰åŒ¹é…å†…éƒ¨ç±»å‹
        // uint[2][4] memory x = [[0x1, 1], [0xffffff, 2], [0xff, 3], [0xffff, 4]];

        uint24[2][4] memory x = [
            [uint24(0x1), 1],
            [0xffffff, 2],
            [uint24(0xff), 3],
            [uint24(0xffff), 4]
        ];

        return x;
    }
}
```

####  æ•°ç»„çš„å±æ€§

##### length

æ•°ç»„æœ‰ `length` å±æ€§è¡¨ç¤ºå½“å‰æ•°ç»„çš„é•¿åº¦ã€‚ ä¸€ç»åˆ›å»ºï¼Œå†…å­˜ memory æ•°ç»„çš„å¤§å°å°±æ˜¯å›ºå®šçš„ï¼ˆä½†å´æ˜¯åŠ¨æ€çš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒå¯ä»¥æ ¹æ®è¿è¡Œæ—¶çš„å‚æ•°åˆ›å»ºï¼‰ã€‚

ä¾‹å­ 1: **é€šè¿‡ `arr.length` è·å–æ•°ç»„çš„é•¿åº¦**

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    uint256[10] public arr1 = [0, 1, 2];
    uint256[10] public arr2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

    function test1() external view returns (uint256) {
        return arr1.length;
    }

    function test2() external view returns (uint256) {
        return arr2.length;
    }
}
```

ä¾‹å­ 2: **å¯ä»¥é€šè¿‡ length å±æ€§æ¥åˆ¤æ–­é•¿åº¦ã€‚**

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract TX {
    function f(uint len) public pure {
        uint[] memory a = new uint[](7);
        bytes memory b = new bytes(len);

        assert(a.length == 7);
        assert(b.length == len);
    }
}
```

ä¾‹å­ 3:**ä¸èƒ½é€šè¿‡è®¾ç½® `arr.length` æ¥è°ƒæ•´åŠ¨æ€æ•°ç»„çš„é•¿åº¦ã€‚**

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    uint256[10] public arr1 = [0, 1, 2];
    // Member "length" is read-only and cannot be used to resize arrays.
    function test1() external {
        arr1.length = 8;
    }
}
```

####  æ•°ç»„çš„æ–¹æ³•

- push : åªæœ‰åŠ¨æ€æ•°ç»„å¯ä»¥ä½¿ç”¨ï¼ŒåŠ¨æ€çš„ storage æ•°ç»„ä»¥åŠ `bytes` ç±»å‹å¯ä»¥ç”¨ï¼Œ`string` ç±»å‹ä¸å¯ä»¥
  - `push()`: å®ƒç”¨æ¥æ·»åŠ æ–°çš„é›¶åˆå§‹åŒ–å…ƒç´ åˆ°æ•°ç»„æœ«å°¾ï¼Œå¹¶è¿”å›å…ƒç´ å¼•ç”¨.å› æ­¤å¯ä»¥è¿™æ ·ï¼š`x.push().t = 2` æˆ– `x.push() = b`.
  - `push(x)`: ç”¨æ¥åœ¨æ•°ç»„æœ«å°¾æ·»åŠ ä¸€ä¸ªç»™å®šçš„å…ƒç´ ï¼Œè¿™ä¸ªå‡½æ•°æ²¡æœ‰è¿”å›å€¼ï¼
- `pop`: åˆ é™¤æœ€åä¸€ä¸ªé•¿åº¦
  - å®ƒç”¨æ¥ä»æ•°ç»„æœ«å°¾åˆ é™¤å…ƒç´ ã€‚ åŒæ ·çš„ä¼šåœ¨ç§»é™¤çš„å…ƒç´ ä¸Šéšå«è°ƒç”¨ delete ã€‚
- `delete`: åˆ é™¤å¯¹åº”çš„ç´¢å¼•ï¼›åˆ é™¤å¹¶ä¸ä¼šæ”¹å˜é•¿åº¦ï¼Œç´¢å¼•ä½ç½®çš„å€¼ä¼šæ”¹ä¸ºé»˜è®¤å€¼ã€‚
- `x[start:end]`: æ•°ç»„åˆ‡ç‰‡ï¼Œä»…å¯ä½¿ç”¨äº `calldata` æ•°ç»„.

##### push

é€šè¿‡ `push()`ã€€å¢åŠ  storage æ•°ç»„çš„é•¿åº¦å…·æœ‰å›ºå®šçš„ gas æ¶ˆè€—ï¼Œå› ä¸º storage æ€»æ˜¯è¢«é›¶åˆå§‹åŒ–ï¼›

ä¾‹å­: çŠ¶æ€å˜é‡çš„å®šé•¿æ•°ç»„å¯ä»¥é€šè¿‡ push æ¥æ”¹å˜é•¿åº¦ã€‚ä½†æ˜¯å†…å­˜ä¸­ä¸å¯ä»¥ä½¿ç”¨ pushã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    uint256[] public a1 = new uint256[](5);

    function setStorageA() external {
        a1.push(8);
    }

    function setMemoryA() external pure {
        uint256[] memory a2 = new uint256[](5);

        // Type uint8[5] memory is not implicitly convertible to expected
        // type uint256[] memory. uint256[] memory a3 = [1, 2, 3, 4, 5];

        // Member "push" is not available in uint256[] memory outside of storage.
        // a2.push(8);
    }
}
```

##### pop & delete

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract FunctionOutputs {
    uint256[] private nums = [1, 2, 3];
    uint256[3] private numsFixed = [1, 2, 3];

    function setArray()
        external
        returns (
            uint256 len1,
            uint256 len2,
            uint256 len3
        )
    {
        nums.push(4); // push
        len1 = nums.length;

        nums.pop(); // åˆ é™¤
        len2 = nums.length;

        nums[2] = 666;

        delete nums[1];
        // delete nums;
        len3 = nums.length;
    }

    function getArray() external view returns (uint256[] memory) {
        return nums;
    }
}
```

- `pop` åˆ é™¤æœ€åä¸€ä¸ªå…ƒç´ 
- `delete array[x]` ä»…ä»…æ˜¯æ¸…é™¤å…ƒç´ å¯¹åº”ç´¢å¼•ä¸ºé»˜è®¤å€¼
- `delete array` array çš„ length é‡ç½®ä¸º 0

é€šè¿‡ `pop()`ã€€åˆ é™¤æ•°ç»„æˆæœ¬æ˜¯å¾ˆé«˜çš„,å› ä¸ºå®ƒåŒ…æ‹¬å·²åˆ é™¤çš„å…ƒç´ çš„æ¸…ç†ï¼Œç±»ä¼¼äºåœ¨è¿™äº›å…ƒç´ ä¸Šè°ƒç”¨ `delete`ã€‚

æ³¨æ„:å¦‚æœéœ€è¦åœ¨å¤–éƒ¨ï¼ˆexternalï¼‰å‡½æ•°ä¸­ä½¿ç”¨å¤šç»´æ•°ç»„ï¼Œè¿™éœ€è¦å¯ç”¨ ABI coder v2ã€‚ public å‡½æ•°ä¸­æ˜¯æ”¯æŒçš„ä½¿ç”¨å¤šç»´æ•°ç»„ã€‚å› ä¸ºå¤šç»´æ•°ç»„ç”¨çš„åœºæ™¯ä¸å¤šï¼Œè¿™é‡Œå°±ä¸ä»‹ç»äº†ã€‚

##### æ•°ç»„åˆ‡ç‰‡: x[start:end]

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    uint256[] internal nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];
    uint256[] temp1;
    uint256[] temp2;
    uint256[] temp3;

    // è¾“å…¥ [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
    function setTemp(uint256[] calldata _arr)
        external
        returns (
            uint256[] memory,
            uint256[] memory,
            uint256[] memory
        )
    {
        temp1 = _arr[0:2];
        temp2 = _arr[:2];
        temp3 = _arr[2:];

        // Index range access is only supported for dynamic calldata arrays.
        // temp3 = nums[2:];

        return (temp1, temp2, temp3);
    }
}
```

æ•°ç»„åˆ‡ç‰‡æ˜¯æ•°ç»„è¿ç»­éƒ¨åˆ†çš„è§†å›¾ï¼Œç”¨æ³•å¦‚ï¼š`x[start:end]` ï¼Œ `start` å’Œ `end` æ˜¯ `uint256` ç±»å‹ï¼ˆæˆ–ç»“æœä¸º `uint256` çš„è¡¨è¾¾å¼ï¼‰ã€‚ `x[start:end]` çš„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯ `x[start]` ï¼Œ æœ€åä¸€ä¸ªå…ƒç´ æ˜¯ `x[end - 1]` ã€‚(åŒ…å« startï¼Œä¸åŒ…å« end)

- ç›®å‰æ•°ç»„åˆ‡ç‰‡ï¼Œä»…å¯ä½¿ç”¨äº `calldata` æ•°ç»„.
- å¦‚æœ `start` æ¯” `end` å¤§æˆ–è€… `end` æ¯”æ•°ç»„é•¿åº¦è¿˜å¤§ï¼Œå°†ä¼šæŠ›å‡ºå¼‚å¸¸ã€‚
- `start` å’Œ `end` éƒ½å¯ä»¥æ˜¯å¯é€‰çš„ï¼š `start` é»˜è®¤æ˜¯ 0ï¼Œ è€Œ `end` é»˜è®¤æ˜¯æ•°ç»„é•¿åº¦ã€‚

æ•°ç»„åˆ‡ç‰‡æ²¡æœ‰ä»»ä½•æˆå‘˜ã€‚ å®ƒä»¬å¯ä»¥éšå¼è½¬æ¢ä¸ºå…¶â€œèƒŒåâ€ç±»å‹çš„æ•°ç»„ï¼Œå¹¶æ”¯æŒç´¢å¼•è®¿é—®ã€‚ ç´¢å¼•è®¿é—®ä¹Ÿæ˜¯ç›¸å¯¹äºåˆ‡ç‰‡çš„å¼€å§‹ä½ç½®ã€‚ æ•°ç»„åˆ‡ç‰‡æ²¡æœ‰ç±»å‹åç§°ï¼Œè¿™æ„å‘³ç€æ²¡æœ‰å˜é‡å¯ä»¥å°†æ•°ç»„åˆ‡ç‰‡ä½œä¸ºç±»å‹ï¼Œå®ƒä»¬ä»…å­˜åœ¨äºä¸­é—´è¡¨è¾¾å¼ä¸­ã€‚

####  æ¨¡æ‹Ÿåˆ‡ç‰‡çš„ slice æ–¹æ³•

åˆ‡ç‰‡å½“å‰ä»…æ”¯æŒ calldata çš„æ•°æ®ï¼Œå¦‚æœæ˜¯ memory å°±ä¸æ”¯æŒäº†ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract FunctionOutputs {
    function slice(
        uint256[] memory arr,
        uint256 begin,
        uint256 end
    ) internal pure returns (uint256[] memory) {
        require(begin < arr.length, "index out of bound");

        //å¦‚æœèµ·å§‹ä½ç½®è¶Šç•Œï¼Œè¿”å›ç©ºæ•°ç»„
        if (begin >= arr.length) return arr;

        //å¤„ç† begin å’Œ endå°äº0çš„æƒ…å†µï¼Œä½¿ç”¨ uint256 ï¼Œä¸å­˜åœ¨è´Ÿæ•°
        // if (begin < 0) {
        //     begin = begin + arr.length < 0 ? 0 : begin + arr.length;
        // }
        // if (end < 0) {
        //     end = end + arr.length < 0 ? 0 : end + arr.length;
        // }

        //å£°æ˜ä¸€ä¸ªç©ºæ•°ç»„ï¼Œä½œä¸ºå¤åˆ¶åè¿”å›å€¼
        uint256[] memory temp = new uint256[](end - begin);

        //å¤åˆ¶beginè‡³endçš„å…ƒç´ åˆ° temp ä¸­ åŒ…æ‹¬arr[begin] ä¸åŒ…æ‹¬arr[end]
        for (uint256 index = begin; index < end; index++) {
            temp[index - begin] = arr[index];
        }
        return temp;
    }

    function test()
        external
        pure
        returns (
            uint256[] memory arr,
            uint256[] memory temp1,
            uint256[] memory temp2,
            uint256[] memory temp3
        )
    {
        arr = new uint256[](5);
        arr[0] = 1;
        arr[1] = 2;
        arr[2] = 3;
        arr[3] = 4;
        arr[4] = 5;

        temp1 = slice(arr, 1, 3); // [2,3]
        temp2 = slice(arr, 1, 4); // [2,3,4]
        temp3 = slice(arr, 1, 5); // [2,3,4,5]
    }
}
```

####  delete å®Œå…¨åˆ é™¤æ•°ç»„çš„æŒ‡å®šç´¢å¼•

åˆ é™¤æ•°ç»„çš„æŒ‡å®šç´¢å¼•ï¼Œæ•°ç»„çš„é•¿åº¦ä¹Ÿä¼šæ”¹å˜

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract FunctionOutputs {
    function deletePro(uint256[] memory arr, uint256 _index)
        internal
        pure
        returns (uint256[] memory temp)
    {
        require(_index < arr.length, "index out of bound");
        temp = new uint256[](arr.length - 1);
        for (uint256 index = 0; index <= temp.length - 1; index++) {
            if (index >= _index) {
                temp[_index] = arr[_index + 1];
            } else {
                temp[index] = arr[index];
            }
        }
    }

    function test()
        external
        pure
        returns (uint256[] memory arr, uint256[] memory temp)
    {
        arr = new uint256[](3);
        arr[0] = 1;
        arr[1] = 2;
        arr[2] = 3;
        assert(arr[0] == 1);
        assert(arr[1] == 2);
        assert(arr[2] == 3);
        assert(arr.length == 3);

        temp = deletePro(arr, 1);
        assert(temp[0] == 1);
        assert(temp[1] == 3);
        assert(temp.length == 2);
    }
}
```

### bytes

`string` å’Œ `bytes` ç±»å‹çš„å˜é‡æ˜¯ç‰¹æ®Šçš„æ•°ç»„ã€‚ `bytes` å¯ä»¥é€šè¿‡ç´¢å¼•æˆ–è€…`.length`æ¥è®¿é—®æ•°æ®ã€‚string ä¸ bytes ç›¸åŒï¼Œä½†ä¸å…è®¸ç”¨`.length`æˆ–ç´¢å¼•æ¥è®¿é—®æ•°æ®ã€‚

- å¯¹ä»»æ„é•¿åº¦çš„åŸå§‹å­—èŠ‚æ•°æ®ä½¿ç”¨ `bytes`ï¼Œå¯¹ä»»æ„é•¿åº¦å­—ç¬¦ä¸²ï¼ˆUTF-8ï¼‰æ•°æ®ä½¿ç”¨ `string` ã€‚
- å¦‚æœä½¿ç”¨ä¸€ä¸ªé•¿åº¦é™åˆ¶çš„å­—èŠ‚æ•°ç»„ï¼Œåº”è¯¥ä½¿ç”¨ä¸€ä¸ª `bytes1` åˆ° `bytes32` çš„å…·ä½“ç±»å‹ï¼Œå› ä¸ºå®ƒä»¬ä¾¿å®œå¾—å¤šã€‚
- `bytesN[]` å’Œ `bytes` å¯ä»¥è½¬æ¢: bytes1 æ˜¯å€¼ç±»å‹ï¼Œæ¯”å¦‚ `0x61`; `bytes`æ˜¯å¯å˜å­—èŠ‚æ•°ç»„,å¦‚æœ bytes1 æƒ³è¦å€Ÿç”¨ bytes çš„æ–¹æ³•ï¼Œå°±éœ€è¦è½¬æ¢æˆ bytes;
- åŸºæœ¬è§„åˆ™:å¯¹ä»»æ„é•¿åº¦çš„åŸå§‹å­—èŠ‚æ•°æ®ä½¿ç”¨ `bytes`ï¼Œå¯¹ä»»æ„é•¿åº¦å­—ç¬¦ä¸²ï¼ˆUTF-8ï¼‰æ•°æ®ä½¿ç”¨ `string` ã€‚

####  åˆ›å»º

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    bytes public welcome = bytes("1.Welcome");
    bytes public temp1 = new bytes(2); // å¯å˜å­—èŠ‚æ•°ç»„åˆ›å»ºæ–¹å¼

    function test1(uint256 len_) public pure  returns(bytes memory){
        bytes memory temp2 = new bytes(len_);
        temp2[0] = "a";
        return temp2;
    }
    function test2() public{
        temp1[0] = "a";
    }
}
```

çŠ¶æ€å˜é‡çš„åˆ›å»ºæ–¹å¼

```
bytes public welcome = bytes("1.Welcome");
```

å‡½æ•°ä¸­å¯å˜å­—èŠ‚æ•°ç»„åˆ›å»ºæ–¹å¼ï¼š

```
bytes memory temp2 = new bytes(length); // å¯å˜å­—èŠ‚æ•°ç»„åˆ›å»ºæ–¹å¼
```

####  bytes å’Œ `bytes32[]` åŒºåˆ«

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

// bytes / bytes32 / bytes32[] åŒºåˆ«
// bytes:å¯å˜å­—èŠ‚æ•°ç»„ ï¼š å¼•ç”¨ç±»å‹
// bytes32: å›ºå®šé•¿åº¦çš„å­—èŠ‚æ•°ç»„ ï¼š å€¼ç±»å‹
// bytes32[]: ç”±â€œå›ºå®šé•¿åº¦çš„å­—èŠ‚æ•°ç»„â€ ç»„æˆçš„ æ•°ç»„ç±»å‹
contract Demo {
    bytes public welcome1 = bytes("1.Welcome");
    bytes32 public welcome2 = "a";
    bytes32[] public welcome3 = [bytes32("a")];
}
```

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    bytes32[] public abcArray = [bytes1("a"), bytes1("b"), bytes1("c")];

    // 0x616263
    bytes public abcBytes = bytes("abc");

    function getAbcArr() external view returns (bytes32[] memory) {
        return abcArray;
    }
}
```

`abcBytes` çš„å€¼æ˜¯: `0x616263`;

`abcArray` çš„å€¼æ˜¯ï¼š

```
[
    0x6100000000000000000000000000000000000000000000000000000000000000,
    0x6200000000000000000000000000000000000000000000000000000000000000,
    0x6300000000000000000000000000000000000000000000000000000000000000
]
```

`bytes` æœ‰ç‚¹ç±»ä¼¼äº `bytes1[]`çš„ç´§æ‰“åŒ…ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠä¸Šé¢ä¾‹å­ä¸­ bytes32 æ”¹ä¸º bytes1 ç±»å‹è¿›è¡Œå¯¹æ¯”ã€‚

æˆ‘ä»¬æ›´å¤šæ—¶å€™åº”è¯¥ä½¿ç”¨ `bytes` è€Œä¸æ˜¯ `bytes32[]`è¿™ç§æ•°ç»„ç±»å‹ ï¼Œå› ä¸º Gas è´¹ç”¨æ›´ä½;

- `bytes32[]` ä¼šåœ¨å…ƒç´ ä¹‹é—´æ·»åŠ  31 ä¸ªå¡«å……å­—èŠ‚ã€‚
- `bytes` ç”±äºç´§å¯†åŒ…è£…ï¼Œè¿™æ²¡æœ‰å¡«å……å­—èŠ‚ã€‚

####  å±æ€§

- è·å– bytes é•¿åº¦
  - bytesVar.length:ä»¥å­—èŠ‚é•¿åº¦è¡¨ç¤ºå­—ç¬¦ä¸²çš„é•¿åº¦
- è·å–æŒ‡å®šç´¢å¼•çš„æ•°æ®
  ```
  bytes1 temp1 = bytes(welcome)[_index]; // è¿”å›å›ºå®šé•¿åº¦çš„ bytes1
  ```
- ä¿®æ”¹ bytes
  - `bytesVar[7] = 'x'`

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    bytes public welcome = bytes("1.Welcome");

    function getLength() public view returns (uint256 welcomeLength) {
        welcomeLength = welcome.length;
    }

    function modi() public {
        welcome[0] = bytes1("2");
    }
}
```

####  æ–¹æ³•

- bytes æ‹¼æ¥
  - `bytes.concat(...) returns (bytes memory):`
  - å¦‚æœä¸ä½¿ç”¨å‚æ•°è°ƒç”¨ bytes.concat å°†è¿”å›ç©ºæ•°ç»„ã€‚
- push æ–¹æ³•
  - `a.push(b)` å¾€å­—èŠ‚æ•°ç»„æ·»åŠ å­—èŠ‚
- `delete bys;`:æ¸…ç©ºå­—èŠ‚æ•°ç»„
- `x[start:end]`: æ•°ç»„åˆ‡ç‰‡
- `bytes()`: å°†å­—ç¬¦ä¸²è½¬æ¢åˆ° bytes
- `string()`:å°† bytes æ•°æ®è½¬æ¢åˆ°å­—ç¬¦ä¸²
- æ¯”è¾ƒä¸¤ä¸ª bytes
  - `keccak256(bytes1) == keccak256(bytes2)`

##### bytes.concat æ‹¼æ¥

- `bytes.concat(...) returns (bytes memory)`

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    bytes public welcome = bytes("a");
    bytes public concatBytes = bytes.concat(welcome, bytes("b"), bytes1("c"),"a");
}
```

bytes.concat å‡½æ•°å¯ä»¥è¿æ¥ä»»æ„æ•°é‡çš„ `bytes` æˆ– `bytes1` ... `bytes32` å€¼ã€‚ è¯¥å‡½æ•°è¿”å›ä¸€ä¸ª `bytes memory` ï¼ŒåŒ…å«æ‰€æœ‰å‚æ•°çš„å†…å®¹ï¼Œæ— å¡«å……æ–¹å¼æ‹¼æ¥åœ¨ä¸€èµ·ã€‚ å¦‚æœä½ æƒ³ä½¿ç”¨å­—ç¬¦ä¸²å‚æ•°æˆ–å…¶ä»–ä¸èƒ½éšå¼è½¬æ¢ä¸º `bytes` çš„ç±»å‹ï¼Œä½ éœ€è¦å…ˆå°†å®ƒä»¬è½¬æ¢ä¸º `bytes`æˆ– `bytes1/â€¦/ bytes32`ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    bytes public welcome = bytes("a");
    bytes public concatBytes = bytes.concat();
}
```

å¦‚æœä½ ä¸ä½¿ç”¨å‚æ•°è°ƒç”¨ `bytes.concat` å°†è¿”å›ç©ºæ•°ç»„ã€‚

##### push æ–¹æ³•

æ³¨æ„ï¼š push æ˜¯å•ä¸ªå­—èŠ‚ï¼Œæ˜¯ `bytes1`çš„å›ºå®šé•¿åº¦,è€Œä¸æ˜¯ `bytes`ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    bytes public welcome1 = bytes("Welcome");
    bytes public welcome2 = new bytes(10);

    function testPush() public {
        welcome1.push(bytes("A")[0]);
        welcome2.push(bytes("B")[0]);
    }
}
```

##### pop æ–¹æ³•

åˆ é™¤æ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    bytes public welcome1 = bytes("Welcome");
    bytes public welcome2 = new bytes(10);

    function testPop() public {
        welcome1.pop();
        welcome2.pop();
    }
}
```

##### `delete` æ¸…ç©ºå­—èŠ‚æ•°ç»„

ä½¿ç”¨ `delete` å…¨å±€å…³é”®å­—;

- `delete bytesName`
- `delete bytesName[index]`

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    bytes public welcome1 = bytes("Welcome");

    function deleteAll() public {
        delete welcome1;
    }

    function deleteIndex(uint256 index_) public {
        delete welcome1[index_];
    }
}
```

##### `x[start:end]`:æ•°ç»„åˆ‡ç‰‡

æ³¨æ„ï¼šæ•°ç»„åˆ‡ç‰‡åªèƒ½ç”¨åœ¨ calldata ç±»å‹ä¸Šã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Proxy {
    bytes public welcome1 = bytes("Welcome");
    bytes4 public temp1 = bytes4(welcome1); // 0x57656c63

    // æŠŠ welcome1 çš„å€¼ä¼ å…¥å‚æ•°
    function forward(bytes calldata payload)
        external pure
        returns(bytes memory temp2,bytes4 temp3)
    {
        // åˆ‡ç‰‡æ–¹æ³•åªèƒ½ç”¨åœ¨ calldata ä¸Šã€‚
        temp2 = payload[:4];
        temp3 = bytes4(payload[:4]);
    }
}
```

å¦ä¸€ä¸ªä¾‹å­: `bts_[:4]` å’Œ `bytes4(bts_)` ç»“æœä¸ä¸€æ ·ï¼

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

// x[start:end]
//      1.åªèƒ½ç”¨åœ¨ caldata ç±»å‹çš„æ•°æ®ä¸Š
//      2.åˆ‡å‡ºæ¥çš„æ˜¯æ•°ç»„ï¼š`bts_[:4]` å’Œ `bytes4(bts_)` ç»“æœä¸ä¸€æ ·ï¼
//          ä¸¤è€…è™½ç„¶çœ‹èµ·æ¥å€¼æ„ä¹‰ï¼Œä½†æ˜¯ç±»å‹ä¸ä¸€æ ·ï¼å¤„ç†çš„æ—¶å€™ä¹Ÿéœ€è¦æ³¨æ„
contract Demo {
    // 0x57656c636f6d65
    bytes public welcome1 = bytes("Welcome");
    bytes4 public welcome2 = bytes4(welcome1);

    // bytes: temp1 0x57656c63
    // bytes4: temp2 0x57656c63
    function test(bytes calldata bts_) public pure returns(
        bytes memory temp1,
        bytes4 temp2,
        bytes4 temp3
    ){
        temp1 = bts_[:4]; // åˆ‡çš„è¿”å›å€¼æ˜¯æ•°ç»„
        temp2 = bytes4(bts_[:4]); //
        temp3 = bytes4(bts_); // åˆ‡ï¼š ç”±å¤§åˆ°å° => åˆ‡å‡ºæ¥çš„æ˜¯å€¼ç±»å‹
    }

}
```

ä¾‹å­: **æ•°ç»„åˆ‡ç‰‡åœ¨ ABI è§£ç æ•°æ®çš„æ—¶å€™éå¸¸æœ‰ç”¨**ï¼Œå¦‚ï¼š

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Proxy {
    /// è¢«å½“å‰åˆçº¦ç®¡ç†çš„ å®¢æˆ·ç«¯åˆçº¦åœ°å€
    address client;

    constructor(address client_) {
        client = client_;
    }

    /// åœ¨è¿›è¡Œå‚æ•°éªŒè¯ä¹‹åï¼Œè½¬å‘åˆ°ç”±clientå®ç°çš„ "setOwner(address)"
    function forward(bytes calldata payload) external {
        bytes4 sig = bytes4(payload[:4]);

        // ç”±äºæˆªæ–­è¡Œä¸ºï¼Œä¸æ‰§è¡Œ bytes4(payload) æ˜¯ç›¸åŒçš„
        // bytes4 sig = bytes4(payload);

        if (sig == bytes4(keccak256("setOwner(address)"))) {
            address owner = abi.decode(payload[4:], (address));
            require(owner != address(0), "Address of owner cannot be zero.");
        }
        (bool status, ) = client.delegatecall(payload);
        require(status, "Forwarded call failed.");
    }
}
```

####  å­—ç¬¦ä¸² åˆ° bytes çš„è½¬æ¢

è½¬æ¢æ–¹æ³•: å¯ä»¥ä½¿ç”¨ `bytes()` æ„é€ å‡½æ•°å°†å­—ç¬¦ä¸²è½¬æ¢ä¸º `bytes`ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    function trans(string memory _str) external pure returns (bytes memory) {
        return bytes(_str);
    }
}
```

####  bytes åˆ° å­—ç¬¦ä¸² çš„è½¬æ¢

è½¬æ¢æ–¹æ³•: å¯ä»¥ä½¿ç”¨ `string()` æ„é€ å‡½æ•°å°† `bytes` è½¬æ¢ä¸ºå­—ç¬¦ä¸²ã€‚

æ³¨æ„: å­—èŠ‚æ•°ç»„åˆ†ä¸ºåŠ¨æ€å¤§å°å’Œå›ºå®šå¤§å°çš„ã€‚å¦‚æœæ˜¯å›ºå®šå¤§å°å­—èŠ‚æ•°ç»„ï¼Œéœ€è¦å…ˆè½¬ä¸ºåŠ¨æ€å¤§å°å­—èŠ‚æ•°ç»„ã€‚

- `åŠ¨æ€å¤§å°å­—èŠ‚æ•°ç»„` â€”> `string`
- `å›ºå®šå¤§å°å­—èŠ‚æ•°ç»„` â€”> `åŠ¨æ€å¤§å°å­—èŠ‚æ•°ç»„` â€”> `string`

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test {
    string public data1;
    string public data2;

    // `åŠ¨æ€å¤§å°å­—èŠ‚æ•°ç»„` â€”> `string`
    function trans1() external {
        bytes memory bstr = new bytes(2);
        bstr[0] = "a";
        bstr[1] = "b";
        data1 = string(bstr);
    }

    // `å›ºå®šå¤§å°å­—èŠ‚æ•°ç»„` â€”> `åŠ¨æ€å¤§å°å­—èŠ‚æ•°ç»„` â€”> `string`
    function trans2() external {
        // å›ºå®šå¤§å°å­—èŠ‚æ•°ç»„
        bytes2 ab = 0x6162;

        // `å›ºå®šå¤§å°å­—èŠ‚æ•°ç»„` â€”> `åŠ¨æ€å¤§å°å­—èŠ‚æ•°ç»„`
        bytes memory temp = new bytes(ab.length); // å¯å˜å­—èŠ‚æ•°ç»„åˆ›å»ºæ–¹å¼
        for (uint256 i = 0; i < ab.length; i++) {
            temp[i] = ab[i];
        }

        // `åŠ¨æ€å¤§å°å­—èŠ‚æ•°ç»„` â€”> `string`
        data2 = string(temp);
    }
}
```

####  æ¯”è¾ƒ 2 ä¸ª bytes å€¼æ˜¯å¦ç›¸ç­‰

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    bytes welcome1 = bytes("Welcome");
    bytes welcome2 = bytes("Welcome");

    function test1() public view returns (bool) {
        return keccak256(welcome2) == keccak256(welcome1);
    }
}
```

### string

Solidity ä¸­ï¼Œå­—ç¬¦ä¸²å€¼ä½¿ç”¨åŒå¼•å·(`""`)æˆ–å•å¼•å·(`''`)åŒ…æ‹¬ï¼Œå­—ç¬¦ä¸²ç±»å‹ç”¨ string è¡¨ç¤ºã€‚`string` å’Œ `bytes` ç±»å‹çš„å˜é‡æ˜¯ç‰¹æ®Šçš„æ•°ç»„ï¼Œæ˜¯å¼•ç”¨ç±»å‹ã€‚

####  æ ¼å¼

```
"abc"
'hello'
```

ä¾‹å­

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract For {
    string public a = "a" "b" "c";
    string public b = "abc";
    string public c = 'x' 'y' 'z';
    string public d = 'xyz';
}
```

####  å±æ€§

string å¹¶æ²¡æœ‰è·å–å…¶å­—ç¬¦ä¸²é•¿åº¦çš„ length å±æ€§; ä¹Ÿæ²¡æä¾›è·å–æŸä¸ªç´¢å¼•å­—èŠ‚ç çš„ç´¢å¼•å±æ€§ã€‚

æˆ‘ä»¬å¯ä»¥é€šè¿‡æŠŠ string è½¬æ¢æˆ `bytes`ï¼Œå€ŸåŠ©`bytes` çš„å±æ€§ã€‚

ä¾‹å­: ä¸‹é¢æ˜¯ä½¿ç”¨ `getLength()` è·å–é•¿åº¦ï¼Œä½¿ç”¨`modi()`ä¿®æ”¹å­—ç¬¦ä¸²ï¼Œä½¿ç”¨ `getIndexValue()` è·å–å­—ç¬¦ä¸²çš„æŒ‡å®šç´¢å¼•çš„æ•°æ®ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    string public welcome = "1.Welcome";

    function getLength() public view returns (uint256 welcomeLength) {
        welcomeLength = bytes(welcome).length;
    }

    function getIndexValue(uint256 _index) public view returns (string memory) {
        bytes1 temp1 = bytes(welcome)[_index]; // è¿”å›å›ºå®šé•¿åº¦çš„ bytes1
        bytes memory temp2 = new bytes(1); // å¯å˜å­—èŠ‚æ•°ç»„åˆ›å»ºæ–¹å¼
        temp2[0] = temp1;
        return string(temp2);
    }

    function modi() public {
        bytes(welcome)[0] = bytes1("2");
    }
}
```

- è·å–å­—ç¬¦ä¸²çš„é•¿åº¦
  - `bytes(str).length`:ä»¥å­—èŠ‚é•¿åº¦è¡¨ç¤ºå­—ç¬¦ä¸²çš„é•¿åº¦
- æŸä¸ªå­—ç¬¦ä¸²ç´¢å¼•çš„å­—èŠ‚ç 
  - `bytes1 temp1 = bytes(str)[_index];`
    ```
    function getIndexValue(uint256 _index) public view return(string memory) {
        bytes1 temp1 = bytes(welcome)[_index]; // è¿”å›å›ºå®šé•¿åº¦çš„ bytes1
        bytes memory temp2 = new bytes(1); // å¯å˜å­—èŠ‚æ•°ç»„åˆ›å»ºæ–¹å¼
        temp2[0] = temp1;
        return string(temp2);
    }
    ```
- ä¿®æ”¹å­—ç¬¦ä¸²
  - `bytes(s)[7] = 'x'`

####  æ–¹æ³•

Solidity string æœ¬èº«å¹¶æ²¡æœ‰æ“ä½œå‡½æ•°ï¼Œéœ€è¦å€ŸåŠ©å…¨å±€çš„å‡½æ•°

- å­—ç¬¦ä¸²æ‹¼æ¥
  - `string.concat()`
  - å¦‚æœä¸ä½¿ç”¨å‚æ•°è°ƒç”¨ string.concat å°†è¿”å›ç©ºæ•°ç»„ã€‚
- å°† bytes è½¬æ¢åˆ° å­—ç¬¦ä¸²
  - `string()`
- å°† å­—ç¬¦ä¸² è½¬æ¢åˆ° bytes
  - `bytes()`
- æ¯”è¾ƒä¸¤ä¸ªå­—ç¬¦ä¸²

  - `keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))`
  - `keccak256(bytes(s1)) == keccak256(bytes(s2))`:æ›´çœ gas

- æœ‰æ²¡æœ‰å¦‚ä¸‹åŠæ³•å‘¢ï¼Ÿ
  - push
  - pop
  - delete
  - `x[start:end]`

####  å­—ç¬¦ä¸²æ‹¼æ¥

å¯ä»¥ä½¿ç”¨ `string.concat` è¿æ¥ä»»æ„æ•°é‡çš„ string å­—ç¬¦ä¸²ã€‚ è¯¥å‡½æ•°è¿”å›ä¸€ä¸ª `string memory` ï¼ŒåŒ…å«æ‰€æœ‰å‚æ•°çš„å†…å®¹ï¼Œæ— å¡«å……æ–¹å¼æ‹¼æ¥åœ¨ä¸€èµ·ã€‚ å¦‚æœä½ æƒ³ä½¿ç”¨ä¸èƒ½éšå¼è½¬æ¢ä¸º string çš„å…¶ä»–ç±»å‹ä½œä¸ºå‚æ•°ï¼Œä½ éœ€è¦å…ˆæŠŠå®ƒä»¬è½¬æ¢ä¸º stringã€‚

**string.concat ä¾‹å­**

è¾“å…¥å­—ç¬¦ä¸²ï¼Œè¾“å‡ºæ‹¼æ¥åçš„å­—ç¬¦ä¸²

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    string public welcome = "Welcome";

    // å†™ä¸€ä¸ª welcome username çš„å°æ–¹æ³•
    // Welcome Anbang!
    function test(string memory name_)
        public
        view
        returns(string memory concatString){
            bytes memory bs = bytes("!");
            // welcome + name_ + bs
            // å†…éƒ¨æ˜¯ä½¿ç”¨å­—ç¬¦ä¸²ï¼Œå¦‚æœæ˜¯bytesï¼Œéœ€è¦è½¬æ¢ä¸º string ç±»å‹
            concatString = string.concat(
                welcome,
                name_,
                string(bs)
            );
        }
}
```

å¦‚æœä½ ä¸ä½¿ç”¨å‚æ•°è°ƒç”¨ `string.concat` æˆ– `bytes.concat` å°†è¿”å›ç©ºæ•°ç»„ã€‚

æ¨èäº†è§£ï¼š

```
// è¿™æ˜¯ä¸€ç§ string.concat æ–¹æ³•çš„å®ç°
function strConcat(string memory _a, string memory _b)
    internal
    pure
    returns (string memory)
{
    bytes memory _ba = bytes(_a);
    bytes memory _bb = bytes(_b);
    string memory ret = new string(_ba.length + _bb.length);
    bytes memory bret = bytes(ret);
    uint256 k = 0;
    for (uint256 i = 0; i < _ba.length; i++) bret[k++] = _ba[i];
    for (uint256 i = 0; i < _bb.length; i++) bret[k++] = _bb[i];
    return string(ret);
}
```

####  bytes å’Œ å­—ç¬¦ä¸² ä¹‹é—´è½¬æ¢

è§ bytes ç« èŠ‚ä¸­çš„å†…å®¹ï¼Œè¿™é‡Œä¸å†é‡å¤ä»‹ç»ã€‚

####  æ¯”è¾ƒä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ç›¸ç­‰

æ¯”è¾ƒä¸¤ä¸ªå­—ç¬¦ä¸²å€ŸåŠ© keccak256 æ¥ä½¿ç”¨:

- `keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))`
- `keccak256(bytes(s1)) == keccak256(bytes(s2))` : æ›´æ¨èè¿™ä¸ªï¼Œçœ gas

æ³¨æ„ï¼šä¸Šé¢ `abi.encodePacked` çš„è¿”å›å€¼æ˜¯ `bytes` ç±»å‹ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    string public hello = "Hello";

    // string è½¬æˆ bytes
    function test1() public view
        returns (bytes memory,bytes memory) {
        return (abi.encodePacked(hello),bytes(hello));
    }

    function test2(string calldata hello_) public view returns (bool) {
        // è¿™é‡Œåªè¦èƒ½å¤Ÿè½¬æ¢æˆ bytesçš„éƒ½å¯ä»¥ã€‚
        // æ›´å¤šæ–¹æ³•å¯ä»¥å‚è€ƒåé¢ä»‹ç»çš„ å…¨å±€ ABI ç¼–ç å‡½æ•°
        return
            keccak256(abi.encodePacked(hello)) ==
            keccak256(abi.encodePacked(hello_));
    }

    function test3(string calldata hello_) public view returns (bool) {
        return keccak256(bytes(hello)) == keccak256(bytes(hello_));
    }

}
```

å‡ ä¸ªå¸¸ç”¨çš„å…¨å±€ ABI ç¼–ç å‡½æ•°çš„ç®€å•ç”¨æ³•ä»‹ç»ï¼š

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    string public hello = "Hello Anbang";
    bytes public temp1 = abi.encodePacked(hello);
    bytes public temp2 = abi.encode(hello);

    bytes public temp3 = abi.encodeWithSignature(hello);
    bytes public temp4 = abi.encodeWithSignature("Hello Anbang1");
}
```

å¦‚æœæ¯”è¾ƒå¤šä¸ªå‚æ•°çš„æ‹¼æ¥å­—ç¬¦ä¸²æ˜¯å¦ç›¸ç­‰ï¼Œè°¨æ…ä½¿ç”¨ `abi.encodePacked`äº†ï¼Œå› ä¸ºç´§å‹ç¼©æœºåˆ¶çš„é—®é¢˜ã€‚è¯¦ç»†å¯ä»¥åœ¨ `abi.encodePacked` ä¸­äº†è§£

### mapping æ˜ å°„

mapping å¯ä»¥çœ‹ä½œä¸€ä¸ªå“ˆå¸Œè¡¨ï¼Œä¼šæ‰§è¡Œè™šæ‹ŸåŒ–åˆå§‹åŒ–ï¼Œä½¿æ‰€æœ‰å¯èƒ½çš„å€¼éƒ½æ˜¯è¯¥ç±»å‹çš„é»˜è®¤å€¼ã€‚å…¶å® mapping å¹¶ä¸æ˜¯ä¸€ä¸ªå“ˆå¸Œè¡¨ï¼Œæ²¡æœ‰ key é›†åˆï¼Œä¹Ÿæ²¡æœ‰ value é›†åˆï¼Œæ‰€ä»¥ mapping æ²¡åŠæ³•éå†/è¿­ä»£ã€‚

æ•°ç»„ä¸­æ‰¾æŸä¸€ä¸ªå€¼ï¼Œéœ€è¦å¾ªç¯éå†ï¼Œè¿™æ˜¯å¾ˆæ¶ˆè€— Gas çš„ï¼Œè€Œä½¿ç”¨ mapping å°±å¯ä»¥å¾ˆå¥½çš„è§£å†³è¿™ä¸ªé—®é¢˜ã€‚æ˜ å°„å¯ä»¥å¾ˆæ–¹ä¾¿çš„è·å–æŸä¸ªå€¼ã€‚æ˜ å°„å¹¶æ²¡æœ‰åšè¿­ä»£çš„æ–¹æ³•ã€‚

- æ˜ å°„å£°æ˜
- æ˜ å°„çš„è®¾ç½®ï¼Œè·å–ï¼Œåˆ é™¤

####  æœ¬èŠ‚é‡ç‚¹

å£°æ˜æ˜ å°„ç±»å‹çš„è¯­æ³•ï¼š`mapping(_KeyType => _ValueType)`

- `_KeyType`ï¼šå¯ä»¥æ˜¯ä»»ä½•å†…ç½®ç±»å‹ï¼Œæˆ–è€… bytes å’Œ å­—ç¬¦ä¸²ã€‚
  - é”®æ˜¯å”¯ä¸€çš„ï¼Œå…¶èµ‹å€¼æ–¹å¼ä¸ºï¼š`map[a]=test`; æ„æ€æ˜¯é”®ä¸º a,å€¼ä¸º testï¼›ã€‚
- `_ValueType`ï¼š å¯ä»¥æ˜¯ä»»ä½•ç±»å‹ï¼Œç”¨æˆ·è‡ªå®šä¹‰ç±»å‹ä¹Ÿå¯ä»¥ã€‚
- mapping æ”¯æŒåµŒå¥—ã€‚
- æ˜ å°„çš„æ•°æ®ä½ç½®(data location)åªèƒ½æ˜¯ `storage`ï¼Œé€šå¸¸ç”¨äºçŠ¶æ€å˜é‡ã€‚
- `mapping` ä¸èƒ½ç”¨äº `public` å‡½æ•°çš„å‚æ•°æˆ–è¿”å›ç»“æœ
  - æ˜ å°„åªèƒ½æ˜¯ storage çš„æ•°æ®ä½ç½®ï¼Œå› æ­¤åªå…è®¸ä½œä¸ºçŠ¶æ€å˜é‡ æˆ– ä½œä¸ºå‡½æ•°å†…çš„ storage å¼•ç”¨ æˆ– ä½œä¸ºåº“å‡½æ•°çš„å‚æ•°ã€‚å®ƒä»¬ä¸èƒ½ç”¨åˆçº¦å…¬æœ‰å‡½æ•°çš„å‚æ•°æˆ–è¿”å›å€¼ã€‚
  - è¿™äº›é™åˆ¶åŒæ ·é€‚ç”¨äºåŒ…å«æ˜ å°„çš„æ•°ç»„å’Œç»“æ„ä½“ã€‚
- æ˜ å°„å¯ä»¥æ ‡è®°ä¸º `public`ï¼ŒSolidity è‡ªåŠ¨ä¸ºå®ƒåˆ›å»º getter å‡½æ•°ã€‚
  - `_KeyType` å°†æˆä¸º `getter` çš„å¿…é¡»å‚æ•°ï¼Œå¹¶ä¸” getter ä¼šè¿”å› `_ValueType`ã€‚
  - å¦‚æœ `ValueType` æ˜¯ä¸€ä¸ªæ˜ å°„ã€‚è¿™æ—¶åœ¨ä½¿ç”¨ `getter` æ—¶å°†éœ€è¦é€’å½’åœ°ä¼ å…¥æ¯ä¸ª `KeyType` å‚æ•°ï¼Œ

é—®ç­”é¢˜ï¼šä¸ºä»€ä¹ˆæ˜ å°„ä¸èƒ½åƒå“ˆå¸Œè¡¨ä¸€æ ·éå†ï¼Ÿ

æ˜ å°„ä¸å“ˆå¸Œè¡¨ä¸åŒçš„åœ°æ–¹ï¼š**åœ¨æ˜ å°„ä¸­,å¹¶ä¸å­˜å‚¨ keyï¼Œè€Œæ˜¯å­˜å‚¨å®ƒçš„ `keccak256` å“ˆå¸Œå€¼ï¼Œä»è€Œä¾¿äºæŸ¥è¯¢å®é™…çš„å€¼**ã€‚æ­£å› ä¸ºå¦‚æ­¤ï¼Œæ˜ å°„æ˜¯æ²¡æœ‰é•¿åº¦çš„ï¼Œä¹Ÿæ²¡æœ‰ `key çš„é›†åˆ`æˆ– `value çš„é›†åˆ`çš„æ¦‚å¿µã€‚æ˜ å°„åªèƒ½æ˜¯å­˜å‚¨çš„æ•°æ®ä½ç½®ï¼Œå› æ­¤åªå…è®¸ä½œä¸ºçŠ¶æ€å˜é‡æˆ–ä½œä¸ºå‡½æ•°å†…çš„å­˜å‚¨å¼•ç”¨ æˆ– ä½œä¸ºåº“å‡½æ•°çš„å‚æ•°ã€‚

####  åˆ›å»ºæ ¼å¼

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Mapping {
    // æ™®é€š
    mapping(address => uint256) public balances;

    // åµŒå¥—
    mapping(address => mapping(address => bool)) public friends;
}
```

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

// ä¸èƒ½åƒ array ä¸€æ ·è¿”å›æ‰€æœ‰
contract Demo {
    mapping(address => uint256) public balances;

    function getAllBalance() public view
        returns(mapping(address => uint256) memory){
        return balances;
    }

}
```

####  å¦‚ä½•è·å–-è®¾ç½®-åˆ é™¤

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Mapping {
    // æ™®é€š
    mapping(address => uint256) public balances;

    // åµŒå¥—
    mapping(address => mapping(address => bool)) public friends;

    constructor() {
        balances[msg.sender] = 100;
    }

    function blanceGet() external view returns (uint256) {
        // è·å–
        return balances[msg.sender];
    }

    function blanceSet(uint256 amount) external {
        // è®¾ç½®
        balances[msg.sender] += amount;
    }

    function blanceDelete() external {
        // åˆ é™¤
        delete balances[msg.sender];
    }

    function friendGet() external view returns (bool) {
        // è·å–
        return friends[msg.sender][address(0)];
    }

    function friendSet() external {
        // è®¾ç½®
        friends[msg.sender][address(0)] = true;
    }

    function friendDelete() external {
        // åˆ é™¤
        delete friends[msg.sender][address(0)];
        // delete friends[msg.sender];
    }
}
```

####  ä½œä¸ºå±€éƒ¨å˜é‡çš„ä½¿ç”¨

`mapping` ç±»å‹å¯ä»¥ç”¨åšå±€éƒ¨å˜é‡ï¼Œä½†åªèƒ½å¼•ç”¨çŠ¶æ€å˜é‡ï¼Œè€Œä¸”å­˜å‚¨ä½ç½®ä¸º storageã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

// ä½œä¸ºå±€éƒ¨å˜é‡çš„ä½¿ç”¨
contract Demo {
    // æ™®é€š mapping
    mapping(address => uint256) public balances; // æ™®é€šmapping

    // storage: æ”¹å˜å†…éƒ¨ refï¼Œä¼šå½±å“ balances çš„å€¼
    // ä¸èƒ½å£°æ˜ä¸º memory
    function updataBalance() public returns(uint256){
        // mapping(address=>uint256) memory ref = balances; // âŒ
        mapping(address=>uint256) storage ref = balances;
        ref[msg.sender] += 3;
        return ref[msg.sender];
    }

}
```

####  åœ¨ ERC20 token ä¸­çš„ç”¨æ³•

ä¸‹é¢çš„ä¾‹å­æ˜¯ã€€ ERC20 token ã€€çš„ç®€å•ç‰ˆæœ¬ï¼ `_allowances` æ˜¯ä¸€ä¸ªåµŒå¥— mapping çš„ä¾‹å­ï¼ `_allowances` ç”¨æ¥è®°å½•å…¶ä»–çš„è´¦å·ï¼Œå¯ä»¥å…è®¸ä»å…¶è´¦å·ä½¿ç”¨å¤šå°‘æ•°é‡çš„å¸ï¼

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

// mapping åœ¨ ERC20 token ä¸­çš„ç”¨æ³•
contract MappingExample {
    // ä½™é¢
    mapping(address => uint256) private _balances;
    // æˆæƒ:
    // æˆæƒäºº - ä»£ç†äºº - æˆæƒé‡‘é¢
    mapping(address => mapping(address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );

    // è·å–ï¼šæˆæƒé‡‘é¢
    function allowance(address owner, address spender)
        public
        view
        returns (uint256)
    {
        return _allowances[owner][spender];
    }

    // æ£€æŸ¥ï¼šæˆæƒé‡‘é¢å¤§äºç­‰äºéœ€è¦æ“ä½œçš„é‡‘é¢
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public returns (bool) {
        require(
            _allowances[sender][msg.sender] >= amount,
            "ERC20: Allowance not high enough."
        );
        _allowances[sender][msg.sender] -= amount; // è®¾ç½®é¢åº¦
        _transfer(sender, recipient, amount);
        return true;
    }
    // è®¾ç½®ï¼š
    function approve(address spender, uint256 amount) public returns (bool) {
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");
        require(_balances[sender] >= amount, "ERC20: Not enough funds.");

        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }
}
```

####  å¯è¿­ä»£æ˜ å°„

éå†æ‰€æœ‰ Mapping å†…çš„æ•°æ®ï¼Œï¼ˆMapping é…åˆ array ï¼‰

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    mapping(address => uint256) public balances;
    // ç”¨äºæ£€æŸ¥:åœ°å€æ˜¯å¦å·²ç»å­˜åœ¨äº balancesKey
    mapping(address => bool) public balancesInserted;
    address[] public balancesKey; // æ‰€æœ‰åœ°å€

    // è®¾ç½®
    function set(address ads_,uint256 amount_) external{
        balances[ads_] = amount_;
        // 1.æ£€æŸ¥
        if(!balancesInserted[ads_]){
            // 2.ä¿®æ”¹æ£€æŸ¥æ¡ä»¶
            balancesInserted[ads_] = true;
            // 3.æ­£åœ¨çš„æ“ä½œ
            balancesKey.push(ads_);
        }
    }
    // è·å–
    function get(uint256 index_) external view returns(uint256){
        require(index_<balancesKey.length,"index_ error");
        return balances[balancesKey[index_]];
    }
    // è·å–æ‰€æœ‰
    function totalAddress() external view returns(uint256){
        return balancesKey.length;
    }

    // è·å–ç¬¬ä¸€ä¸ªå€¼
    function first() external view returns(uint256){
        return balances[balancesKey[0]];
    }
    // æœ€åä¸€ä¸ªå€¼
    function latest() external view returns(uint256){
        return balances[balancesKey[balancesKey.length-1]];
    }
}
```

- æ›´å®Œå–„çš„å®ç°: https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol

- æ›´æ–°çš„å®ç°: https://learnblockchain.cn/docs/solidity/types.html#iterable-mappings

### struct ç»“æ„ä½“

####  åˆ›å»ºè¯­æ³•

è¦å®šä¹‰ç»“æ„ä½“ï¼Œä½¿ç”¨ `struct` å…³é”®å­—ã€‚`struct` å…³é”®å­—å®šä¹‰äº†ä¸€ä¸ªæ–°çš„æ•°æ®ç±»å‹ï¼ŒåŒ…å«å¤šä¸ªæˆå‘˜ã€‚ç»“æ„ä½“æ˜¯å¯ä»¥å°†å¤šä¸ªå˜é‡è¿›è¡Œç¼–ç»„çš„è‡ªå®šä¹‰ç±»å‹

struct è¯­å¥çš„æ ¼å¼å¦‚ä¸‹

```
struct StructName {
   type1 typeName1;
   type2 typeName2;
   type3 typeName3;
}
```

ä¾‹å­:

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    struct Book {
        string title;
        string author;
        uint256 book_id;
    }
    Book public book = Book("Solidity", "Anbang", 1);
}
```

####  ä¸‰ç§åˆ›å»ºæ–¹æ³•

åŸºç¡€æ–¹å¼ï¼š`Test t = Test(1,2);`

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Structs {
    struct Book {
        string title;
        string author;
        uint256 book_id;
    }

    uint256 private bookId;
    Book[] public bookcase; // ä¹¦æŸœ:æ•°ç»„ç±»å‹

    function setA1Bookcase() external {
        // ç¬¬1ç§ç”Ÿæˆæ–¹æ³•ï¼šé¡ºåºä¸€å®šè¦å’Œç»“æ„ä¸€è‡´
        Book memory temp = Book(
            unicode"Solidity é«˜çº§ç¨‹åºè®¾è®¡",
            "Anbang",
            ++bookId
        );
        bookcase.push(temp);
    }

    // âœ… æœ€ä¼˜æ–¹æ¡ˆï¼Œæ¨è: å…ˆå†™å…¥å†…å­˜ï¼Œç„¶åpush
    function setB1Bookcase() external {
        // ç¬¬ 2 ç§ç”Ÿæˆ
        Book memory temp = Book({
            title: unicode"Solidity é«˜çº§ç¨‹åºè®¾è®¡",
            author: "Anbang",
            book_id: ++bookId
        });
        bookcase.push(temp);
    }

    function setB2Bookcase() external {
        // ç¬¬ 2 ç§ç”Ÿæˆ: ç›´æ¥ pushï¼Œæ— å˜é‡
        bookcase.push(
            Book({
                title: unicode"Solidity é«˜çº§ç¨‹åºè®¾è®¡",
                author: "Anbang",
                book_id: ++bookId
            })
        );
    }

    function setC1Bookcase() external {
        // ç¬¬ 3 ç§ç”Ÿæˆ: æ¨è
        Book memory temp;
        temp.title = unicode"Solidity é«˜çº§ç¨‹åºè®¾è®¡";
        temp.author = "Anbang";
        temp.book_id = ++bookId;
        bookcase.push(temp);
    }
}
```

æ€»ç»“ï¼š

```
// ç¬¬ 1 ç§ç”Ÿæˆ
Book memory solidity1 = Book(unicode"Solidity é«˜çº§ç¨‹åºè®¾è®¡", "Anbang", ++bookId);

// ç¬¬ 2 ç§ç”Ÿæˆ
Book memory solidity2 = Book({
    title: unicode"Solidity é«˜çº§ç¨‹åºè®¾è®¡",
    author: "Anbang",
    book_id: ++bookId,
});

// ç¬¬ 3 ç§ç”Ÿæˆ
Book memory temp;
temp.title = unicode"Solidity é«˜çº§ç¨‹åºè®¾è®¡";
temp.author = "Anbang";
temp.book_id = ++bookId;
```

####  è¯»å–

å‡½æ•°å†…ä»…è¯»å–ç»“æ„ä½“ï¼Œä½¿ç”¨ memory å’Œ storage åŒºåˆ«:

1. å‡½æ•°å†…è¯»å–å¹¶è¿”å›,å¦‚æœä½¿ç”¨ memory å˜é‡æ¥æ”¶:
   1. ä»çŠ¶æ€å˜é‡æ‹·è´åˆ°å†…å­˜ä¸­ï¼Œç„¶åå†…å­˜ä¸­çš„å˜é‡æ‹·è´åˆ°è¿”å›å€¼ã€‚ä¸¤æ¬¡æ‹·è´ï¼Œæ¶ˆè€— gas å¤š
   2. `Book memory _book = book;`
2. å‡½æ•°å†…è¯»å–å¹¶è¿”å›ï¼Œå¦‚æœä½¿ç”¨ storage å˜é‡æ¥æ”¶:
   1. ç›´æ¥ä»çŠ¶æ€å˜é‡è¯»å–ï¼ŒçŠ¶æ€å˜é‡æ‹·è´åˆ°è¿”å›å€¼ã€‚1 æ¬¡æ‹·è´ï¼Œæ¶ˆè€— gas å°
3. æ€»ç»“: è¯»å–æ—¶å€™æ¨èä½¿ç”¨ `storage`

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

// è¯»å–
contract Demo {
    struct Book {
        string title;
        string author;
        uint256 book_id;
    }
    Book public book = Book("Solidity", "Anbang", 1);

    // memory  30029 gas
    // å‡½æ•°å†…è¯»å–å¹¶è¿”å›ï¼šä½¿ç”¨ memory å˜é‡æ¥æ”¶
    //  ä¸¤æ¬¡æ‹·è´ï¼Œæ‰€ä»¥æ¶ˆè€—çš„ gas å¤š
    function get1() external view
        returns(
            string memory,
            string memory,
            uint256
        )
    {
         // ä»çŠ¶æ€å˜é‡æ‹·è´åˆ°å†…å­˜ä¸­
        Book memory _book = book;
        // å†…å­˜ä¸­çš„å˜é‡æ‹·è´åˆ°è¿”å›å€¼ï¼›2æ¬¡æ‹·è´
        return (_book.title,_book.author,_book.book_id);
    }

    // storage 29983 gas
    // å‡½æ•°å†…è¯»å–å¹¶è¿”å›ï¼šä½¿ç”¨ storage å˜é‡æ¥æ”¶
    function get2() external view
        returns(
            string memory,
            string memory,
            uint256
        )
    {
        // ä»çŠ¶æ€å˜é‡è¯»å–ï¼Œæ²¡æœ‰æ‹·è´çš„è¡Œä¸º
        Book storage _book = book;

        // çŠ¶æ€å˜é‡æ‹·è´åˆ°è¿”å›å€¼ã€‚1æ¬¡æ‹·è´
        return (_book.title,_book.author,_book.book_id);
    }

}
```

####  ä¿®æ”¹

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

// ä¿®æ”¹
contract Demo {
    struct Book {
        string title;
        string author;
        uint256 book_id;
    }
    Book public book = Book("Solidity", "Anbang", 1);

    function modi() external {
        book.title = "Solidity 666";
    }
}
```

å‡½æ•°å†…è¯»å–æ—¶ï¼Œæ ‡è®° `memory` / `storage`,ä¼šäº§ç”Ÿå®Œå…¨ä¸åŒçš„ç»“æœï¼›

ç‰¹åˆ«æ³¨æ„ï¼š**å¦‚æœç»“æ„ä½“å†…åŒ…å« `mapping` ç±»å‹ï¼Œåˆ™å¿…é¡»ä½¿ç”¨ `storage`ï¼Œä¸å¯ä»¥ä½¿ç”¨ memeory.**ï¼Œå¦åˆ™æŠ¥é”™ `Type struct ContractName.StructName memory is only valid in storage because it contains a (nested) mapping.`

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    struct Book {
        string title;
        string author;
        uint256 book_id;
    }
    Book public book = Book("Solidity", "Anbang", 1);

    // view
    function test1() external view {
        Book memory bookLocal = book;
        bookLocal.author = "Anbang666";
    }
    // ä¸èƒ½ç”¨viewï¼šå› ä¸ºå†™çŠ¶æ€å˜é‡äº†
    function test2() external {
        Book storage bookLocal = book;
        bookLocal.author = "Anbang777";
    }
}
```

å‡½æ•°å†…è·å–å¹¶ä¿®æ”¹ç»“æ„ä½“ï¼š

- å› ä¸ºè¦ä¿®æ”¹çŠ¶æ€å˜é‡ï¼Œæ‰€ä»¥ä½¿ç”¨ storage
- å‡½æ•°å†…ç›´æ¥ä¿®æ”¹å˜é‡; åœ¨ä¿®æ”¹ä¸€ä¸ªå±æ€§æ—¶æ¯”è¾ƒçœ Gas è´¹ç”¨
- å‡½æ•°å†…å…ˆè·å–å­˜å‚¨åˆ° storage å†ä¿®æ”¹:ä¿®æ”¹å¤šä¸ªå±æ€§çš„æ—¶å€™æ¯”è¾ƒçœ Gas è´¹ç”¨

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Structs {
    struct Book {
        string title;
        string author;
        uint256 book_id;
    }
    uint256 private bookId;
    Book public book1; // Bookç±»å‹
    Book public book2; // Bookç±»å‹

    mapping(address => Book) public students; // mapping ç±»å‹

    // è®¾ç½® book1
    function setBook1() external {
        Book memory temp;
        temp.title = unicode"Solidity é«˜çº§ç¨‹åºè®¾è®¡";
        temp.author = "Anbang";
        temp.book_id = ++bookId;
        book1 = temp;
    }

    // è®¾ç½® book2
    // âœ… æœ€ä¼˜æ–¹æ¡ˆï¼Œæ¨è:ç›´æ¥ä¿®æ”¹
    function setBook2() external {
        book2.title = unicode"Solidity é«˜çº§ç¨‹åºè®¾è®¡";
        book2.author = "Anbang";
        book2.book_id = ++bookId;
    }

    // âœ… æœ€ä¼˜æ–¹æ¡ˆï¼Œæ¨è:ç›´æ¥ä¿®æ”¹
    function set1Student() external {
        Book storage temp = students[msg.sender];
        temp.title = unicode"Solidity é«˜çº§ç¨‹åºè®¾è®¡";
        temp.author = "Anbang";
        temp.book_id = ++bookId;
    }

    function set2Student() external {
        Book memory temp;
        temp.title = unicode"Solidity é«˜çº§ç¨‹åºè®¾è®¡";
        temp.author = "Anbang";
        temp.book_id = ++bookId;
        students[msg.sender] = temp;
    }
}
```

####  åˆ é™¤

åˆ é™¤ç»“æ„ä½“çš„å˜é‡ï¼Œä»…ä»…æ˜¯é‡ç½®æ•°æ®ï¼Œå¹¶ä¸æ˜¯å®Œå…¨çš„åˆ é™¤ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    struct Book {
        string title;
        string author;
        uint256 book_id;
    }
    Book public book = Book("Solidity", "Anbang", 1);

    function del() external
    {
        delete book;
    }
}
```

## ç±»å‹è½¬æ¢

Solidity å…è®¸ç±»å‹ä¹‹é—´è¿›è¡Œéšå¼è½¬æ¢å’Œæ˜¾å¼è½¬æ¢ã€‚

**å‰æ–‡å›é¡¾**: `bytes1` å¯¹åº” `uint8`ï¼Œå¯¹åº”ä¸¤ä½è¿ç»­çš„åå…­è¿›åˆ¶æ•°å­— `0xXX`ã€‚

### éšå¼è½¬æ¢

####  å‘ç”Ÿåœºæ™¯

åœ¨**èµ‹å€¼**, **å‡½æ•°å‚æ•°ä¼ é€’**ä»¥åŠåº”ç”¨è¿ç®—ç¬¦æ—¶ï¼Œä¼šå‘ç”Ÿéšå¼è½¬æ¢ã€‚

####  è½¬æ¢çš„æ ‡å‡†

1. å€¼ç±»å‹
2. æºç±»å‹å¿…é¡»æ˜¯ç›®æ ‡ç±»å‹çš„å­é›†ã€‚

ä¾‹å¦‚ï¼Œ`uint8` å¯ä»¥è½¬æ¢ä¸º `uint16`/`uint24`../`uint256`ï¼Œå› ä¸º`uint8`æ˜¯`uint16`è¿™äº›ç±»å‹çš„å­é›†ã€‚ä½†æ˜¯ `int8` ä¸å¯ä»¥è½¬æ¢ä¸º `uint256`ï¼Œå› ä¸º `int8` å¯ä»¥åŒ…å« `uint256` ä¸­ä¸å…è®¸çš„è´Ÿå€¼ï¼Œæ¯”å¦‚ `-1`ã€‚

####  ç›¸äº¤é›†åˆçš„ç±»å‹ï¼Œä¸èƒ½éšå¼è½¬æ¢ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    int8 public a1 = 3;

    // Type int8 is not implicitly convertible to expected type uint16.
    // uint16 public a2 = a1;

    uint8 public b1 = 3;
    uint16 public b2 = b1;
}
```

####  æŠŠæ•´æ•°å­—é¢é‡èµ‹å€¼ç»™æ•´å‹æ—¶ï¼Œä¸èƒ½è¶…å‡ºèŒƒå›´è€Œå‘ç”Ÿæˆªæ–­ï¼Œå¦åˆ™ä¼šæŠ¥é”™ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo1 {
    uint8 public a = 12; // no error
    uint32 public b = 1234; // no error
    uint16 public c = 0x01;

    // Type int_const 123456 is not implicitly convertible
    // to expected type uint8. Literal is too large to fit in uint8.
    // uint8 d = 123456;
}
```

####  å‡½æ•°å‚æ•°ä¼ é€’

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

// å‡½æ•°çš„ä¼ å‚
contract Demo {
    uint256 public a;

    function test1(uint256 u_) public {
        a = u_;
    }

    function test2() external {
        uint8 temp = 3;
        test1(temp); //
    }
}
```

æ•°ç»„ï¼š

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

// å‡½æ•°çš„ä¼ å‚
contract Demo {
    uint256 public a;

    function test1(uint256[3] memory u_) public {
        a = u_[0];
    }

    // ç¦æ­¢çš„ï¼š
    function test2() external {
        // function call. Invalid implicit conversion from uint8[3]
        // memory to uint256[3] memory requested.
        // test1([1,2,3]);
        test1([uint256(1),uint256(2),uint256(3)]);
    }
}
```

####  è¿ç®—ç¬¦åº”ç”¨

åˆ™ç¼–è¯‘å™¨å°†å°è¯•å°†**å…¶ä¸­ä¸€ä¸ªæ“ä½œæ•°**éšå¼è½¬æ¢ä¸º**å¦ä¸€ä¸ªæ“ä½œæ•°çš„ç±»å‹**ï¼ˆèµ‹å€¼ä¹Ÿæ˜¯å¦‚æ­¤ï¼‰ã€‚ è¿™æ„å‘³ç€æ“ä½œå§‹ç»ˆä»¥æ“ä½œæ•°ä¹‹ä¸€çš„ç±»å‹æ‰§è¡Œã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

// è¿ç®—ç¬¦
contract Demo {
    uint8 public  x = 1;
    uint16 public  y = 2;

    // uint8 + uint16 => uint16 + uint16 = uint16
    // uint16 => uint32
    uint32 public  z = x + y;
}
```

åœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­ï¼ŒåŠ æ³•çš„æ“ä½œæ•° x å’Œ y æ²¡æœ‰ç›¸åŒçš„ç±»å‹ï¼Œuint8 å¯ä»¥è¢«éšå¼è½¬æ¢ä¸º uint16ï¼Œç›¸åå´ä¸å¯ä»¥ã€‚ å› æ­¤åœ¨æ‰§è¡ŒåŠ æ³•ä¹‹å‰ï¼Œå°† uint8 è½¬æ¢ä¸º uint16 çš„ç±»å‹ï¼Œç»“æœç±»å‹æ˜¯ uint16ã€‚å› ä¸ºå®ƒè¢«èµ‹å€¼ç»™ uint32 ç±»å‹çš„å˜é‡ï¼Œåˆè¿›è¡Œäº†å¦ä¸€ä¸ªç±»ä¼¼é€»è¾‘çš„éšå¼è½¬æ¢.

### æ˜¾å¼è½¬æ¢

å¯ä»¥ä½¿ç”¨ç±»å‹å…³é”®å­—ï¼Œæ˜¾å¼åœ°å°†æ•°æ®ç±»å‹è½¬æ¢ä¸ºå¦ä¸€ç§ç±»å‹ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    // uint8 => uint16
    uint8 public a1 = 3;
    uint16 public a2 = uint16(a1);

    int8 public b1 = 3;
    //Explicit type conversion not allowed from "int8" to "uint256".
    // uint256 b2 = uint256(b1);
}
```

####  int/uint æ•´å‹è½¬æ¢

æ•´å‹åŠ å¤§æ•°æ®ä½ç½®æ˜¯ä»å·¦ä¾§å¢åŠ ï¼Œå‡å°æ•°æ®ä½ç½®ä¹Ÿæ˜¯ä»å·¦ä¾§ç§»é™¤ï¼›ï¼ˆ**æ•´å‹æ˜¯å³å¯¹é½**ï¼‰

- æ•´å‹è½¬æ¢æˆæ›´å¤§çš„ç±»å‹ï¼Œä»å·¦ä¾§æ·»åŠ å¡«å……ä½ã€‚
- æ•´å‹è½¬æ¢æˆæ›´å°çš„ç±»å‹ï¼Œä¼šä¸¢å¤±å·¦ä¾§æ•°æ®ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    // æ•´å‹è½¬æ¢æˆæ›´å¤§çš„ç±»å‹ï¼Œä»å·¦ä¾§æ·»åŠ å¡«å……ä½ã€‚
    // uint16 => uint32
    uint16 public a1 = 22136;       // ç­‰äº 0x5678
    uint32 public a2 = uint32(a1); // a2 = 22136

    // uint16 => uint8
    uint8 public a3 = uint8(a1); // b4 = 0x78
    uint8 public a4 = 0x78;

    // æ•´å‹è½¬æ¢æˆæ›´å°çš„ç±»å‹ï¼Œä¼šä¸¢å¤±å·¦ä¾§æ•°æ®ã€‚
    // uint32 => uint16
    uint32 public b1 = 0x12345678; // 0x12345678
    uint16 public b2 = uint16(b1); // 0x5678 | b2 = 22136
}
```

**æ•´æ•°æ˜¾å¼è½¬æ¢ä¸ºæ›´å¤§çš„ç±»å‹**

```
uint16 a = 0x1234;
uint32 b = uint32(a); // b ä¸º 0x00001234 now
```

**æ•´æ•°æ˜¾å¼è½¬æ¢æˆæ›´å°çš„ç±»å‹**

```
uint32 a = 0x12345678;
uint16 b = uint16(a); // æ­¤æ—¶ b çš„å€¼æ˜¯ 0x5678
```

####  bytes å­—èŠ‚ç±»å‹è½¬æ¢

å­—èŠ‚åŠ å¤§æ•°æ®ä½ç½®æ˜¯ä»å³ä¾§å¢åŠ ï¼Œå‡å°æ•°æ®ä½ç½®ä¹Ÿæ˜¯ä»å³ä¾§ç§»é™¤ï¼›ï¼ˆ**å­—èŠ‚æ˜¯å·¦å¯¹é½**ï¼‰

- å­—èŠ‚è½¬æ¢ä¸ºæ›´å¤§çš„ç±»å‹æ—¶ï¼Œä»å³ä¾§æ·»åŠ å¡«å……ä½ã€‚
- å­—èŠ‚è½¬æ¢åˆ°æ›´å°çš„ç±»å‹æ—¶ï¼Œä¸¢å¤±å³ä¾§æ•°æ®ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    // å­—èŠ‚è½¬æ¢ä¸ºæ›´å¤§çš„ç±»å‹æ—¶ï¼Œä»å³ä¾§æ·»åŠ å¡«å……ä½ã€‚
    // bytes2 =>bytes4
    bytes2 public a1 = 0x5678;
    bytes4 public a2 = bytes4(a1); // a2 = 0x56780000

    // å­—èŠ‚è½¬æ¢åˆ°æ›´å°çš„ç±»å‹æ—¶ï¼Œä¸¢å¤±å³ä¾§æ•°æ®ã€‚
    // bytes4 => bytes2
    bytes4 public b1 = 0x12345678;
    bytes2 public b2 = bytes2(b1); // b2 = 0x1234
}
```

**bytes æ˜¾å¼è½¬æ¢æˆæ›´å°çš„ç±»å‹**

```
bytes2 a = 0x1234;
bytes1 b = bytes1(a); // b ä¸º 0x12
```

**bytes æ˜¾å¼è½¬æ¢æˆæ›´å¤§çš„ç±»å‹**

```
bytes2 a = 0x1234;
bytes4 b = bytes4(a); // b ä¸º 0x12340000
```

####  bytes ä¸ uint è½¬æ¢

åªæœ‰å½“å­—èŠ‚ç±»å‹å’Œæ•´æ•°ç±»å‹å¤§å°ç›¸åŒæ—¶ï¼Œæ‰å¯ä»¥è¿›è¡Œè½¬æ¢ã€‚

å› ä¸ºæ•´æ•°å’Œå®šé•¿å­—èŠ‚æ•°ç»„åœ¨æˆªæ–­ï¼ˆæˆ–å¡«å……ï¼‰æ—¶è¡Œä¸ºæ˜¯ä¸åŒçš„ï¼Œå¦‚æœè¦åœ¨ä¸åŒçš„å¤§å°çš„æ•´æ•°å’Œå®šé•¿å­—èŠ‚æ•°ç»„ä¹‹é—´è¿›è¡Œè½¬æ¢ï¼Œ**å¿…é¡»ä½¿ç”¨ä¸€ä¸ªä¸­é—´ç±»å‹æ¥æ˜ç¡®è¿›è¡Œæ‰€éœ€æˆªæ–­å’Œå¡«å……çš„è§„åˆ™**

```
bytes2 a = 0x1234;
uint32 b = uint16(a);           // b ä¸º 0x00001234
uint32 c = uint32(bytes4(a));   // c ä¸º 0x12340000

uint8  d = uint8(uint16(a));    // d ä¸º 0x34
uint8  e = uint8(bytes1(a));    // e ä¸º 0x12
```

**1.bytes è½¬æ¢æˆ uint**: **å…ˆè½¬ç±»å‹ï¼Œå†è½¬å¤§å°**

- æ¨èå…ˆæŠŠ bytes æ˜¾ç¤ºè½¬æ¢æˆæ•°å­—ç±»å‹åï¼Œå†è½¬æ¢æˆæ›´å¤§æˆ–æ›´å°çš„æ•°å­—

```code-block:: solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

// - `uint8`  ç­‰äºä¸¤ä½è¿ç»­çš„åå…­è¿›åˆ¶æ•°å­— `0xXX`
// - `bytes1` ç­‰äºä¸¤ä½è¿ç»­çš„åå…­è¿›åˆ¶æ•°å­— `0xXX`
// - `bytes1` ç­‰äº `uint8`
contract Demo1 {
    // bytes => uint
    bytes2 public a1 = 0x5678; // : åè¿›åˆ¶æ•°å­— = 22136
    bytes4 public a2 = bytes4(a1); // a2 = 0x56780000 : åè¿›åˆ¶æ•°å­— = 1450704896
    bytes1 public a3 = bytes1(a1); // a3 = 0x56 : åè¿›åˆ¶æ•°å­— = 86

    // -- å¢å¤§
    // bytes æ˜¾ç¤ºè½¬æ¢æˆæ•°å­—åï¼Œæ˜¾ç¤ºè½¬æ¢æ›´å¤§çš„æ•°å­— (è¿™é‡Œä¹Ÿå¯ä»¥éšå¼å®Œæˆ)
    uint32 public a4 = uint32(uint16(a1)); // âœ… a4 = 0x00005678 : åè¿›åˆ¶ = 22136
    // bytes æ˜¾ç¤ºè½¬æ¢æˆæ›´å¤§æ•°å­—å¯¹åº”çš„çš„bytesï¼Œç„¶åbytesæ˜¾ç¤ºè½¬æ¢æˆåŒ¹é…çš„æ•°å­—
    uint32 public a5 = uint32(bytes4(a1)); // âŒ a5 = 0x56780000 : åè¿›åˆ¶ = 1450704896

    // -- å‡å°
    // bytes æ˜¾ç¤ºè½¬æ¢æˆæ•°å­—åï¼Œæ˜¾ç¤ºè½¬æ¢æˆæ›´å°çš„æ•°å­—
    uint8 public a6 = uint8(uint16(a1)); // âœ… a6 = 0x78 : åè¿›åˆ¶ = 120
    // bytes æ˜¾ç¤ºè½¬æ¢æˆæ›´å°æ•°å­—å¯¹åº”çš„çš„bytesï¼Œç„¶åbytesæ˜¾ç¤ºè½¬æ¢æˆåŒ¹é…çš„æ•°å­—
    uint8 public a7 = uint8(bytes1(a1)); // âŒ a7 = 0x56 : åè¿›åˆ¶ = 86
}
```

**2.uint è½¬æ¢æˆ bytes**: **å…ˆè½¬å¤§å°ï¼Œå†è½¬ç±»å‹**

- æ¨èå…ˆæŠŠ uint æ˜¾ç¤ºè½¬æ¢æˆæ›´å¤§ bytes å¯¹åº”çš„ uintï¼Œç„¶å uint å†æ˜¾ç¤ºè½¬æ¢æˆåŒ¹é…çš„ bytes

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo2 {
    // uint => bytes
    uint16 public b1 = 0x5678; // 0x5678 : åè¿›åˆ¶ = 22136
    uint32 public b2 = uint32(b1); // b2 = 0x00005678 : åè¿›åˆ¶ = 22136
    uint8 public b3 = uint8(b1); // b3 = 0x78 : åè¿›åˆ¶ = 120
    // -- å¢å¤§
    // uint æ˜¾ç¤ºè½¬æ¢æˆbytesç±»å‹åï¼Œå†æ˜¾ç¤ºè½¬æ¢æˆæ›´å¤§æˆ–æ›´å°çš„bytes
    bytes4 public b4 = bytes4(bytes2(b1)); // âŒ b4 = 0x56780000
    // uint æ˜¾ç¤ºè½¬æ¢æˆæ›´å¤§byteså¯¹åº”çš„uintï¼Œç„¶åuintå†æ˜¾ç¤ºè½¬æ¢æˆåŒ¹é…çš„bytes
    bytes4 public b5 = bytes4(uint32(b1)); //  âœ… b5 = 0x00005678

    // -- å‡å°
    // uint æ˜¾ç¤ºè½¬æ¢æˆbytesç±»å‹åï¼Œå†æ˜¾ç¤ºè½¬æ¢æˆæ›´å¤§æˆ–æ›´å°çš„bytes
    bytes1 public b6 = bytes1(bytes2(b1)); // âŒ b4 = 0x56
    // uint æ˜¾ç¤ºè½¬æ¢æˆæ›´å¤§byteså¯¹åº”çš„uintï¼Œç„¶åuintå†æ˜¾ç¤ºè½¬æ¢æˆåŒ¹é…çš„bytes
    bytes1 public b7 = bytes1(uint8(b1)); // âœ… b4 = 0x78
}
```

####  bytes å’Œ bytesN ä¹‹é—´è½¬æ¢

`bytes` æ•°ç»„å’Œ `bytes calldata` åˆ‡ç‰‡å¯ä»¥æ˜¾ç¤ºè½¬æ¢ä¸ºå›ºå®šé•¿åº¦çš„ bytes ç±»å‹(`bytes1...bytes32`).

- å¦‚æœæ•°ç»„æ¯”å›ºå®šé•¿åº¦çš„ bytes ç±»å‹é•¿ï¼Œåˆ™åœ¨æœ«å°¾å¤„ä¼šå‘ç”Ÿæˆªæ–­ã€‚
- å¦‚æœæ•°ç»„æ¯”ç›®æ ‡ç±»å‹çŸ­ï¼Œå®ƒå°†åœ¨æœ«å°¾ç”¨é›¶å¡«å……ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract C {
    // 0x6162636465666768
    bytes public bts = "abcdefgh";
    bytes3 public b1 = bytes3(bts);
    bytes8 public b2 = bytes8(bts);
    bytes16 public b3 = bytes16(bts);
    bytes32 public b4 = bytes32(bts);
}
```

**è¡¥å……**ï¼šä½¿ç”¨åˆ‡ç‰‡ä¹Ÿå¯ä»¥æŠŠæ•°æ®ä» bytes è½¬ä¸º bytesNã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract C {
    // 0x6162636465666768
    bytes public bts = "abcdefgh";

    function f(bytes calldata bts_)
        public
        pure
        returns (bytes3,bytes16)
    {

        bytes3 b1 = bytes3(bts_);
        bytes16 b2 = bytes16(bts_[:8]);
        return (b1, b2);
    }
}
```

####  bytes ä¸ address è½¬æ¢

address çš„æ ¼å¼æ˜¯ `0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac`ï¼Œæ˜¯ä¸€ä¸ª **bytes20** çš„æ•°æ®ã€‚

åœ°å€æ˜¯å– `bytes32` æ•°æ®ä¸­çš„å 20 ä½ã€‚å¦‚æœæƒ³åˆ é™¤å‰é¢çš„ 12 ä½æ•°æ®ï¼Œå¯ä»¥ä½¿ç”¨ solidity assembly (å†…è”æ±‡ç¼–) æ¥æˆªå–ï¼Œä¹Ÿå¯ä»¥å€ŸåŠ© `uint` è½¬æ¢æˆæ›´å°çš„ç±»å‹ï¼Œä¼šä¸¢å¤±å·¦ä¾§æ•°æ®çš„ç‰¹æ€§æ¥å®Œæˆã€‚

ä»£ç å¦‚ä¸‹:

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    // è·å–å³å°†éƒ¨ç½²çš„åœ°å€
    function getAddress(bytes memory bytecode, uint256 _salt)
        external
        view
        returns (address)
    {
        bytes32 hash = keccak256(
            abi.encodePacked(
                bytes1(0xff), // å›ºå®šå­—ç¬¦ä¸²
                address(this), // å½“å‰å·¥å‚åˆçº¦åœ°å€
                _salt, // salt
                keccak256(bytecode) //éƒ¨ç½²åˆçº¦çš„ bytecode
            )
        );
        // bytes è½¬æ¢æˆ uint: å…ˆè½¬ç±»å‹ï¼Œå†è½¬å¤§å°
        //      bytes32 => uint256 => uint160
        // uint160 è½¬ address
        //      uint160 => address
        return address(uint160(uint256(hash)));
    }
}
```

å‰æ–‡ä»‹ç»è¿‡ç¼–ç çš„æ–¹å¼: `keccak256(abi.encodePacked())`ï¼Œè¿”å›çš„æ˜¯ `bytes32` ç±»å‹ã€‚

è¿™ä¸ªå°ä¾‹å­æ˜¯**åˆçº¦éƒ¨ç½²åˆçº¦**é‚£ç« èŠ‚ä¸­ create2 ä»£ç çš„ä¸€éƒ¨åˆ†ï¼Œç›¸å…³çš„æ›´å¤šæ¼”ç¤ºè¯·æŸ¥çœ‹ create2 åˆ›å»ºã€‚

### æ•°å­—è½¬æ¢æˆå­—ç¬¦ä¸²

####  ç›´æ¥å€ŸåŠ© bytes å’Œ stringï¼ˆæœªå®Œæˆï¼‰

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    // `å›ºå®šå¤§å°å­—èŠ‚æ•°ç»„` â€”> `åŠ¨æ€å¤§å°å­—èŠ‚æ•°ç»„` â€”> `string`
    function test(uint8 num_) public pure returns (bytes1 ab,string memory data) {
        // å›ºå®šå¤§å°å­—èŠ‚æ•°ç»„
        ab = bytes1(num_);

        // `å›ºå®šå¤§å°å­—èŠ‚æ•°ç»„` â€”> `åŠ¨æ€å¤§å°å­—èŠ‚æ•°ç»„`
        bytes memory temp = new bytes(ab.length); // å¯å˜å­—èŠ‚æ•°ç»„åˆ›å»ºæ–¹å¼
        for (uint8 i = 0; i < ab.length; i++) {
            temp[i] = ab[i];
        }

        // `åŠ¨æ€å¤§å°å­—èŠ‚æ•°ç»„` â€”> `string`
        data = string(temp);
    }
}
```

####  å€ŸåŠ©å•ä¸ªæ•°å­—è½¬æ¢ï¼ˆæ¨èï¼‰

è¿™ç§æ–¹æ³•æ˜¯å€ŸåŠ©å°† 0-9 çš„æ•°å­—è¿›è¡Œè½¬æ¢ï¼Œç„¶åè¶…è¿‡åä½çš„æ•°å­—ï¼Œé€šè¿‡ `%` æ¥å¾—åˆ°ï¼Œå¹¶ä¸”æ‹¼æ¥åœ¨ä¸€èµ·ã€‚
æ¨èæ–¹æ³•ï¼š

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    function uintToString(uint256 _uint)
        public
        pure
        returns (string memory str)
    {
        if (_uint == 0) return "0";
        while (_uint != 0) {
            //å–æ¨¡
            uint256 remainder = _uint % 10;
            //æ¯å–ä¸€ä½å°±ç§»åŠ¨ä¸€ä½ï¼Œä¸ªä½ã€åä½ã€ç™¾ä½ã€åƒä½â€¦â€¦
            _uint = _uint / 10;
            //å°†å­—ç¬¦æ‹¼æ¥ï¼Œæ³¨æ„å­—ç¬¦ä½ç½®
            str =  string.concat(toStr(remainder), str);
        }
    }

    function toStr(uint256 num_) internal pure returns (string memory) {
        require(num_ < 10,"error");
        bytes memory alphabet = "0123456789";
        bytes memory str = new bytes(1);
        str[0] = alphabet[num_];
        return string(str);
    }
}
```

ä¸Šé¢ä»£ç çš„ toStr åƒä¸‡ä¸è¦å†™ä¸‹é¢çš„è¿™ç§åƒåœ¾ä»£ç ï¼Œå†™ä¸‹é¢è¿™ç§åƒåœ¾æ˜¯å¯¹è‡ªå·±èŒä¸šçš„ä¸å°Šé‡ï¼š

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    function toStr(uint8 step) external pure returns (string memory str) {
        string memory str;
        if (step == 0) {
            str = "0";
        } else if (step == 1) {
            str = "1";
        } else if (step == 2) {
            str = "2";
        } else if (step == 3) {
            str = "3";
        } else if (step == 4) {
            str = "4";
        } else {
            str = "?";
        }
    }
}
```

toStr çš„å¦å¤–ä¸€ç§å®ç°ï¼Œæ¨èäº†è§£ä¸€ä¸‹ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    //è¿™ä¸ªå‡½æ•°æœ€å…³é”®ï¼Œæ¯”è¾ƒå–å·§ï¼Œç”¨æ¥å°†uint256ç±»å‹çš„ 0-9 æ•°å­—è½¬æˆå­—ç¬¦
    function toStr2(uint256 value) public pure returns (string memory) {
        bytes memory alphabet = "0123456789abcdef";
        //è¿™é‡ŒæŠŠæ•°å­—è½¬æˆäº†bytes32ç±»å‹ï¼Œä½†æ˜¯å› ä¸ºæˆ‘ä»¬çŸ¥é“æ•°å­—æ˜¯ 0-9 ï¼Œæ‰€ä»¥å‰é¢å…¶å®éƒ½æ˜¯å¡«å……äº†0
        bytes memory data = abi.encodePacked(value);
        bytes memory str = new bytes(1);
        //æ‰€ä»¥æœ€åä¸€ä½æ‰æ˜¯çœŸæ­£çš„æ•°å­—
        uint256 i = data.length - 1;
        str[0] = alphabet[uint256(uint8(data[i] & 0x0f))];
        return string(str);
    }
}
```

## å­—é¢å¸¸é‡ä¸åŸºæœ¬ç±»å‹çš„è½¬æ¢

### åè¿›åˆ¶å’Œåå…­è¿›åˆ¶å­—é¢å¸¸é‡

åè¿›åˆ¶å’Œåå…­è¿›åˆ¶å­—é¢å¸¸é‡å¯ä»¥éšå¼è½¬æ¢ä¸ºä»»ä½•è¶³ä»¥è¡¨ç¤ºå®ƒè€Œä¸ä¼šæˆªæ–­çš„æ•´æ•°ç±»å‹ï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    uint8 public a = 12; //  å¯è¡Œ
    uint32 public b = 1234; // å¯è¡Œ
    uint16 public c = 0x01;
    // uint16 d = 0x123456; // å¤±è´¥, ä¼šæˆªæ–­ä¸º 0x3456
}
```

âš ï¸ï¼šåœ¨ 0.8.0 ä¹‹å‰,ä»»ä½•åè¿›åˆ¶å’Œåå…­è¿›åˆ¶å¸¸é‡éƒ½å¯ä»¥æ˜¾ç¤ºè½¬åŒ–ä¸ºæ•´å‹ï¼Œä¸è¿‡ä» 0.8.0 å¼€å§‹ï¼Œåªæœ‰åœ¨åŒ¹é…æ•°æ®èŒƒå›´æ—¶ï¼Œæ‰èƒ½è¿›è¡Œè¿™ä¸ªè½¬æ¢ï¼Œå°±åƒéšå¼è½¬æ¢é‚£æ ·ã€‚

### æ•´å‹å­—é¢å¸¸é‡ä¸ bytesN

- åè¿›åˆ¶å­—é¢å¸¸é‡ä¸èƒ½éšå¼è½¬æ¢ä¸ºå®šé•¿å­—èŠ‚æ•°ç»„ã€‚
- åå…­è¿›åˆ¶å­—é¢å¸¸é‡å¯ä»¥è½¬æ¢ä¸ºå®šé•¿å­—èŠ‚æ•°ç»„ï¼Œä½†ä»…å½“åå…­è¿›åˆ¶æ•°å­—å¤§å°å®Œå…¨ç¬¦åˆå®šé•¿å­—èŠ‚æ•°ç»„é•¿åº¦çš„æ—¶å€™ã€‚
- é›¶çš„**åè¿›åˆ¶**å’Œ**åå…­è¿›åˆ¶å­—é¢å¸¸é‡**éƒ½å¯ä»¥è½¬æ¢ä¸ºä»»ä½•å®šé•¿å­—èŠ‚æ•°ç»„ç±»å‹ï¼Œé›¶å€¼æ˜¯ä¾‹å¤–ï¼Œæ¯”è¾ƒç‰¹æ®Š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    // åå…­è¿›åˆ¶
    bytes2 public a = 0x1234; // å¯è¡Œ
    bytes2 public b = 0x0012; // å¯è¡Œ
    // bytes2 public c = 0x12; // 0x12ä¸å¯è¡Œ ,0x1200 å¯è¡Œï¼Œéœ€è¦å®Œå…¨ç¬¦åˆé•¿åº¦

    // åè¿›åˆ¶
    // bytes4 public x = 1; // ä¸å¯è¡Œ
    // bytes2 public y = 2; // ä¸å¯è¡Œ

    // 0 å’Œ 0x0
    bytes4 public d = 0x0; // å¯è¡Œ
    bytes4 public e = 0; // å¯è¡Œ
}
```

### å­—ç¬¦ä¸²å­—é¢å¸¸é‡ä¸ bytesN

å­—ç¬¦ä¸²å­—é¢å¸¸é‡å’Œåå…­è¿›åˆ¶å­—ç¬¦ä¸²å­—é¢å¸¸é‡å¯ä»¥éšå¼è½¬æ¢ä¸ºå®šé•¿å­—èŠ‚æ•°ç»„ï¼ˆéœ€è¦å®ƒä»¬çš„å­—ç¬¦æ•°ä¸å­—èŠ‚ç±»å‹çš„å¤§å°ç›¸åŒ¹é…ï¼‰

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    bytes2 public a = hex"1234"; // å¯è¡Œ
    bytes2 public b = hex"12"; // å¯è¡Œ
    bytes2 public c = "xy"; // å¯è¡Œ
    bytes2 public d = "x"; // å¯è¡Œ
    // bytes2 public e = hex"123"; // ä¸å¯è¡Œ
    // bytes2 public f = "xyz"; // ä¸å¯è¡Œ
}
```

### åå…­è¿›åˆ¶å­—é¢å¸¸é‡ä¸åœ°å€ç±»å‹

é€šè¿‡æ ¡éªŒå’Œæµ‹è¯•çš„æ­£ç¡®å¤§å°çš„åå…­è¿›åˆ¶å­—é¢å¸¸é‡ä¼šä½œä¸º `address`ç±»å‹ã€‚æ²¡æœ‰å…¶ä»–å­—é¢å¸¸é‡å¯ä»¥éšå¼è½¬æ¢ä¸º `address` ç±»å‹ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    address public ads1 = 0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac;
    // address public ads2 = 0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ab; // âŒ
}
```

## å®æˆ˜ 1: Todo List

TodoList: æ˜¯ç±»ä¼¼ä¾¿ç­¾ä¸€æ ·åŠŸèƒ½çš„ä¸œè¥¿ï¼Œè®°å½•æˆ‘ä»¬éœ€è¦åšçš„äº‹æƒ…ï¼Œä»¥åŠå®ŒæˆçŠ¶æ€ã€‚

### éœ€è¦å®Œæˆçš„åŠŸèƒ½

- åˆ›å»ºä»»åŠ¡
- ä¿®æ”¹ä»»åŠ¡åç§°
  - ä»»åŠ¡åå†™é”™çš„æ—¶å€™
- ä¿®æ”¹å®ŒæˆçŠ¶æ€ï¼š
  - æ‰‹åŠ¨æŒ‡å®šå®Œæˆæˆ–è€…æœªå®Œæˆ
  - è‡ªåŠ¨åˆ‡æ¢
    - å¦‚æœæœªå®ŒæˆçŠ¶æ€ä¸‹ï¼Œæ”¹ä¸ºå®Œæˆ
    - å¦‚æœå®ŒæˆçŠ¶æ€ï¼Œæ”¹ä¸ºæœªå®Œæˆ
- è·å–ä»»åŠ¡

### æ€è€ƒä»£ç å†…çŠ¶æ€å˜é‡æ€ä¹ˆå®‰æ’ï¼Ÿ

æ€è€ƒ 1ï¼šæ€è€ƒä»»åŠ¡ ID çš„æ¥æºï¼Ÿ

æˆ‘ä»¬åœ¨ä¼ ç»Ÿä¸šåŠ¡é‡Œï¼Œè¿™é‡Œçš„ä»»åŠ¡éƒ½ä¼šæœ‰ä¸€ä¸ªä»»åŠ¡ IDï¼Œåœ¨åŒºå—é“¾é‡Œæ€ä¹ˆå®ç°ï¼Ÿï¼Ÿ

ç­”ï¼šä¼ ç»Ÿä¸šåŠ¡é‡Œï¼ŒID å¯ä»¥æ˜¯æ•°æ®åº“è‡ªåŠ¨ç”Ÿæˆçš„ï¼Œä¹Ÿå¯ä»¥ç”¨ç®—æ³•æ¥è®¡ç®—å‡ºæ¥çš„ï¼Œæ¯”å¦‚ä½¿ç”¨é›ªèŠ±ç®—æ³•è®¡ç®—å‡º ID ç­‰ã€‚åœ¨åŒºå—é“¾é‡Œæˆ‘ä»¬ä½¿ç”¨æ•°ç»„çš„ index ç´¢å¼•ä½œä¸ºä»»åŠ¡çš„ IDï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨è‡ªå¢çš„æ•´å‹æ•°æ®æ¥è¡¨ç¤ºã€‚

æ€è€ƒ 2: æˆ‘ä»¬ä½¿ç”¨ä»€ä¹ˆæ•°æ®ç±»å‹æ¯”è¾ƒå¥½ï¼Ÿ

ç­”ï¼šå› ä¸ºéœ€è¦ä»»åŠ¡ IDï¼Œå¦‚æœä½¿ç”¨æ•°ç»„ index ä½œä¸ºä»»åŠ¡ IDã€‚åˆ™æ•°æ®çš„å…ƒç´ å†…éœ€è¦è®°å½•ä»»åŠ¡åç§°ï¼Œä»»åŠ¡å®ŒæˆçŠ¶æ€ï¼Œæ‰€ä»¥å…ƒç´ ä½¿ç”¨ struct æ¯”è¾ƒå¥½ã€‚

å¦‚æœä½¿ç”¨è‡ªå¢çš„æ•´å‹ä½œä¸ºä»»åŠ¡ IDï¼Œåˆ™æ•´å‹ ID å¯¹åº”ä»»åŠ¡ï¼Œä½¿ç”¨ mapping ç±»å‹æ¯”è¾ƒç¬¦åˆã€‚

### æ¼”ç¤ºä»£ç 

```
contract Demo {
    struct Todo {
        string name;
        bool isCompleted;
    }
    Todo[] public list; // 29414

    // åˆ›å»ºä»»åŠ¡
    function create(string memory name_) external {
        list.push(
            Todo({
                name:name_, // ,
                isCompleted:false
            })
        );
    }

    // ä¿®æ”¹ä»»åŠ¡åç§°
    function modiName1(uint256 index_,string memory name_) external {
        // æ–¹æ³•1: ç›´æ¥ä¿®æ”¹ï¼Œä¿®æ”¹ä¸€ä¸ªå±æ€§æ—¶å€™æ¯”è¾ƒçœ gas
        list[index_].name = name_;
    }

    function modiName2(uint256 index_,string memory name_) external {
        // æ–¹æ³•2: å…ˆè·å–å‚¨å­˜åˆ° storageï¼Œåœ¨ä¿®æ”¹ï¼Œåœ¨ä¿®æ”¹å¤šä¸ªå±æ€§çš„æ—¶å€™æ¯”è¾ƒçœ gas
        Todo storage temp = list[index_];
        temp.name = name_;
    }

    // ä¿®æ”¹å®ŒæˆçŠ¶æ€1:æ‰‹åŠ¨æŒ‡å®šå®Œæˆæˆ–è€…æœªå®Œæˆ
    function modiStatus1(uint256 index_,bool status_) external {
        list[index_].isCompleted = status_;
    }

    // ä¿®æ”¹å®ŒæˆçŠ¶æ€2:è‡ªåŠ¨åˆ‡æ¢ toggle
    function modiStatus2(uint256 index_) external {
        list[index_].isCompleted = !list[index_].isCompleted;
    }

    // è·å–ä»»åŠ¡1: memory : 2æ¬¡æ‹·è´
    // 29448 gas
    function get1(uint256 index_) external view
        returns(string memory name_,bool status_){
        Todo memory temp = list[index_];
        return (temp.name,temp.isCompleted);
    }

    // è·å–ä»»åŠ¡2: storage : 1æ¬¡æ‹·è´
    // é¢„æœŸï¼šget2 çš„ gas è´¹ç”¨æ¯”è¾ƒä½ï¼ˆç›¸å¯¹ get1ï¼‰
    // 29388 gas
    function get2(uint256 index_) external view
        returns(string memory name_,bool status_){
        Todo storage temp = list[index_];
        return (temp.name,temp.isCompleted);
    }

}
```

###  è‡ªå·±åŠ¨æ‰‹

è‡ªåŠ¨åŠ¨æ‰‹å†™ä¸€ä¸‹ï¼ŒæŒ‰ç…§ä½¿ç”¨è‡ªå¢æ•´å‹ä½œä¸ºä»»åŠ¡ IDï¼Œé…åˆ mapping å®ç°ä¸Šé¢é€»è¾‘ã€‚çŠ¶æ€æŒ‰ç…§ã€æœªå®Œæˆï¼Œè¿›è¡Œä¸­ï¼Œå·²å®Œæˆï¼Œå·²å–æ¶ˆã€‘å››ç§çŠ¶æ€æ¥åšã€‚

## å®æˆ˜ 2: ä¼—ç­¹åˆçº¦

ä¼—ç­¹åˆçº¦æ˜¯ä¸€ä¸ªå‹Ÿé›†èµ„é‡‘çš„åˆçº¦ï¼Œåœ¨åŒºå—é“¾ä¸Šï¼Œæˆ‘ä»¬æ˜¯å‹Ÿé›†ä»¥å¤ªå¸ï¼Œç±»ä¼¼äº’è”ç½‘ä¸šåŠ¡çš„æ°´æ»´ç­¹ã€‚åŒºå—é“¾æ—©èµ·çš„ ICO å°±æ˜¯ç±»ä¼¼ä¸šåŠ¡ã€‚

### éœ€æ±‚åˆ†æ

ä¼—ç­¹åˆçº¦åˆ†ä¸ºä¸¤ç§è§’è‰²ï¼šä¸€ä¸ªæ˜¯å—ç›Šäººï¼Œä¸€ä¸ªæ˜¯èµ„åŠ©è€…ã€‚

```
// ä¸¤ç§è§’è‰²:
//      å—ç›Šäºº   beneficiary => address         => address ç±»å‹
//      èµ„åŠ©è€…   funders     => address:amount  => mapping ç±»å‹ æˆ–è€… struct ç±»å‹
```

çŠ¶æ€å˜é‡æŒ‰ç…§ä¼—ç­¹çš„ä¸šåŠ¡ï¼š

```
// çŠ¶æ€å˜é‡
//      ç­¹èµ„ç›®æ ‡æ•°é‡    fundingGoal
//      å½“å‰å‹Ÿé›†æ•°é‡    fundingAmount
//      èµ„åŠ©è€…åˆ—è¡¨      funders
//      èµ„åŠ©è€…äººæ•°      fundersKey
```

éœ€è¦éƒ¨ç½²æ—¶å€™ä¼ å…¥çš„æ•°æ®:

```
//      å—ç›Šäºº
//      ç­¹èµ„ç›®æ ‡æ•°é‡
```

### æ¼”ç¤ºä»£ç 

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract CrowdFunding {
    address public immutable beneficiary;   // å—ç›Šäºº
    uint256 public immutable fundingGoal;   // ç­¹èµ„ç›®æ ‡æ•°é‡

    uint256 public fundingAmount;       // å½“å‰çš„ é‡‘é¢
    mapping(address=>uint256) public funders;

    // å¯è¿­ä»£çš„æ˜ å°„
    mapping(address=>bool) private fundersInserted;
    address[] public fundersKey; // length

    // ä¸ç”¨è‡ªé”€æ¯æ–¹æ³•ï¼Œä½¿ç”¨å˜é‡æ¥æ§åˆ¶
    bool public AVAILABLED = true; // çŠ¶æ€

    // éƒ¨ç½²çš„æ—¶å€™ï¼Œå†™å…¥å—ç›Šäºº+ç­¹èµ„ç›®æ ‡æ•°é‡
    constructor(address beneficiary_,uint256 goal_){
        beneficiary = beneficiary_;
        fundingGoal = goal_;
    }

    // èµ„åŠ©
    //      å¯ç”¨çš„æ—¶å€™æ‰å¯ä»¥æ
    //      åˆçº¦å…³é—­ä¹‹åï¼Œå°±ä¸èƒ½åœ¨æ“ä½œäº†
    function contribute() external payable{
        require(AVAILABLED,"CrowdFunding is closed");
        funders[msg.sender] += msg.value;
        fundingAmount += msg.value;
        // 1.æ£€æŸ¥
        if(!fundersInserted[msg.sender]){
            // 2.ä¿®æ”¹
            fundersInserted[msg.sender] = true;
            // 3.æ“ä½œ
            fundersKey.push(msg.sender);
        }
    }

    // å…³é—­
    function close() external returns(bool){
        // 1.æ£€æŸ¥
        if(fundingAmount<fundingGoal){
            return false;
        }
        uint256 amount = fundingAmount;

        // 2.ä¿®æ”¹
        fundingAmount = 0;
        AVAILABLED = false;

        // 3. æ“ä½œ
        payable(beneficiary).transfer(amount);
        return true;
    }

    function fundersLenght() public view returns(uint256){
        return fundersKey.length;
    }

}
```

ä¸Šé¢çš„åˆçº¦åªæ˜¯ä¸€ä¸ªç®€åŒ–ç‰ˆçš„ ä¼—ç­¹åˆçº¦ï¼Œä½†å®ƒå·²ç»è¶³ä»¥è®©æˆ‘ä»¬ç†è§£æœ¬èŠ‚ä»‹ç»çš„ç±»å‹æ¦‚å¿µã€‚

### è‡ªå·±åŠ¨æ‰‹

ä¸Šé¢å†™çš„æ˜¯é¡¹ç›®æ–¹è§’åº¦çš„å‹Ÿé›†è‡ªå·±ã€‚å¦‚æœæ˜¯å‹Ÿé›†å¹³å°ï¼Œè‚¯å®šæ˜¯ä¼šå‘ Todo List é‚£ä¸ªç»ƒä¹ ä¸­ä¸€æ ·ï¼Œæ˜¯æœ‰ä¼—ç­¹ ID çš„ï¼›è¯·æŒ‰ç…§ä¼—ç­¹å¹³å°çš„è§’åº¦æ¥å†™ä¸€ä¸ªä¼—ç­¹åè®®ã€‚

- ä½¿ç”¨å¹³å°è§’åº¦å†™åˆçº¦
- ä½¿ç”¨ stuct æ ¼å¼ã€‚
- ã€é€‰åšã€‘ï¼šå¢åŠ ä¼—ç­¹æ—¶é—´çš„é™åˆ¶
  - å¦‚æœè§„å®šæ—¶é—´å†…å®Œæˆï¼Œåˆ™ç»“æŸåè½¬é’±ç»™å—ç›Šäºº
  - å¦‚æœè§„å®šæ—¶é—´å†…æ²¡æœ‰å®Œæˆï¼Œåˆ™èµ„é‡‘é‡Šæ”¾ï¼Œæèµ è€…è‡ªå·±å–å›æèµ èµ„é‡‘ã€‚

## å®æˆ˜ 3: åŒå¿—ä»¬å¥½å¢åŠ æç¤º

### éœ€æ±‚åˆ†æ

éœ€è¦ç‚¹å‡»ä¸€ä¸ªæ–¹æ³•ï¼ŒæŸ¥çœ‹å½“å‰çš„ step åˆ°å“ªé‡Œäº†ï¼Ÿç„¶åæç¤ºä¸‹ä¸€æ­¥è¯¥å¹²ä»€ä¹ˆã€‚

æ¯”å¦‚ï¼š**å½“å‰çš„ step æ˜¯:0 å¯ä»¥æ‰§è¡Œ hello ,é¢†å¯¼è¯´:åŒå¿—ä»¬å¥½**ã€‚

**éš¾ç‚¹ï¼šæ•°å­—æ€ä¹ˆè½¬æ¢æˆ string**ï¼Ÿ

### ä»£ç å¦‚ä¸‹

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    uint8 public step = 0;

    /// @notice ç”¨äºè¾…åŠ©è·å–ä¸‹ä¸€æ­¥è¯¥åšä»€ä¹ˆçš„æ–¹æ³•
    /// @dev æ•´ç†stepå¯¹åº”çš„é”™è¯¯ï¼Œæ³¨æ„æ•°å­—è½¬ä¸ºå­—ç¬¦ä¸²æ—¶å€™çš„é€”å¾„
    /// @return å½“å‰çš„æç¤ºä¿¡æ¯
    function helperInfo() external view returns (string memory) {
        string memory stepDes = unicode"å½“å‰çš„stepæ˜¯:";
        string memory info;

        if (step == 0) {
            info = unicode"å¯ä»¥æ‰§è¡Œ hello ,é¢†å¯¼è¯´:åŒå¿—ä»¬å¥½";
        } else if (step == 1) {
            info = unicode"å¯ä»¥æ‰§è¡Œ helloRes ,åŒå¿—ä»¬è¯´:é¢†å¯¼å¥½";
        } else if (step == 2) {
            info = unicode"å¯ä»¥æ‰§è¡Œ comfort ,é¢†å¯¼å¿…é¡»ç»™é’±ï¼Œå¹¶ä¸”è¯´:åŒå¿—ä»¬è¾›è‹¦äº†";
        } else if (step == 3) {
            info = unicode"å¯ä»¥æ‰§è¡Œ comfortRes ,åŒå¿—ä»¬è¯´:ä¸ºäººæ°‘æœåŠ¡";
        } else if (step == 4) {
            info = unicode"å¯ä»¥æ‰§è¡Œ selfdestruct";
        } else {
            info = unicode"æœªçŸ¥";
        }

        return string.concat(stepDes, uintToString(step), " ", info);
    }

    // å¦å¤–ä¸€ç§è½¬æ¢æ–¹æ³•
    //è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œé€šè¿‡å–æ¨¡çš„æ–¹å¼ï¼Œä¸€ä½ä¸€ä½è½¬æ¢
    function uintToString(uint256 _uint)
        internal
        pure
        returns (string memory str)
    {
        if (_uint == 0) return "0";
        while (_uint != 0) {
            //å–æ¨¡
            uint256 remainder = _uint % 10;
            //æ¯å–ä¸€ä½å°±ç§»åŠ¨ä¸€ä½ï¼Œä¸ªä½ã€åä½ã€ç™¾ä½ã€åƒä½â€¦â€¦
            _uint = _uint / 10;
            //å°†å­—ç¬¦æ‹¼æ¥ï¼Œæ³¨æ„å­—ç¬¦ä½ç½®
            str =  string.concat(toStr(remainder), str);
        }
    }

    function toStr(uint256 num_) internal pure returns (string memory) {
        require(num_ < 10,"error");
        bytes memory alphabet = "0123456789";
        bytes memory str = new bytes(1);
        str[0] = alphabet[num_];
        return string(str);
    }
}
```

## å®æˆ˜ 4: ETH é’±åŒ…

### å†…å®¹

è¿™ä¸€ä¸ªå®æˆ˜ä¸»è¦æ˜¯åŠ æ·±å¤§å®¶å¯¹ 3 ä¸ªå–é’±æ–¹æ³•çš„ä½¿ç”¨ã€‚

- ä»»ä½•äººéƒ½å¯ä»¥å‘é€é‡‘é¢åˆ°åˆçº¦
- åªæœ‰ owner å¯ä»¥å–æ¬¾
- 3 ç§å–é’±æ–¹å¼

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract EtherWallet {
    address payable public immutable owner;
    event Log(string funName, address from, uint256 value, bytes data);

    constructor() {
        owner = payable(msg.sender);
    }

    receive() external payable {
        emit Log("receive", msg.sender, msg.value, "");
    }

    function withdraw1() external {
        require(msg.sender == owner, "Not owner");
        // owner.transfer ç›¸æ¯” msg.sender æ›´æ¶ˆè€—Gas
        // owner.transfer(address(this).balance);
        payable(msg.sender).transfer(100);
    }

    function withdraw2() external {
        require(msg.sender == owner, "Not owner");
        bool success = payable(msg.sender).send(200);
        require(success, "Send Failed");
    }

    function withdraw3() external {
        require(msg.sender == owner, "Not owner");
        (bool success, ) = msg.sender.call{value: address(this).balance}("");
        require(success, "Call Failed");
    }

    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}
```

## å®æˆ˜ 5: å¤šç­¾é’±åŒ…

å¤šç­¾é’±åŒ…çš„åŠŸèƒ½: åˆçº¦æœ‰å¤šä¸ª ownerï¼Œä¸€ç¬”äº¤æ˜“å‘å‡ºåï¼Œéœ€è¦å¤šä¸ª owner ç¡®è®¤ï¼Œç¡®è®¤æ•°è¾¾åˆ°æœ€ä½è¦æ±‚æ•°ä¹‹åï¼Œæ‰å¯ä»¥çœŸæ­£çš„æ‰§è¡Œã€‚

### åŸç†

- éƒ¨ç½²æ—¶å€™ä¼ å…¥åœ°å€å‚æ•°å’Œéœ€è¦çš„ç­¾åæ•°
  - å¤šä¸ª owner åœ°å€
  - å‘èµ·äº¤æ˜“çš„æœ€ä½ç­¾åæ•°
- æœ‰æ¥å— ETH ä¸»å¸çš„æ–¹æ³•ï¼Œ
- é™¤äº†å­˜æ¬¾å¤–ï¼Œå…¶ä»–æ‰€æœ‰æ–¹æ³•éƒ½éœ€è¦ owner åœ°å€æ‰å¯ä»¥è§¦å‘
- å‘é€å‰éœ€è¦æ£€æµ‹æ˜¯å¦è·å¾—äº†è¶³å¤Ÿçš„ç­¾åæ•°
- ä½¿ç”¨å‘å‡ºçš„äº¤æ˜“æ•°é‡å€¼ä½œä¸ºç­¾åçš„å‡­æ® IDï¼ˆç±»ä¼¼ä¸Šä¹ˆï¼‰
- æ¯æ¬¡ä¿®æ”¹çŠ¶æ€å˜é‡éƒ½éœ€è¦æŠ›å‡ºäº‹ä»¶
- å…è®¸æ‰¹å‡†çš„äº¤æ˜“ï¼Œåœ¨æ²¡æœ‰çœŸæ­£æ‰§è¡Œå‰å–æ¶ˆã€‚
- è¶³å¤Ÿæ•°é‡çš„ approve åï¼Œæ‰å…è®¸çœŸæ­£æ‰§è¡Œã€‚

### ä»£ç 

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract MultiSigWallet {
    // çŠ¶æ€å˜é‡
    address[] public owners;
    mapping(address => bool) public isOwner;
    uint256 public required;

    struct Transaction {
        address to;
        uint256 value;
        bytes data;
        bool exected;
    }
    Transaction[] public transactions;
    mapping(uint256 => mapping(address => bool)) public approved;

    // äº‹ä»¶
    event Deposit(address indexed sender, uint256 amount);
    event Submit(uint256 indexed txId);
    event Approve(address indexed owner, uint256 indexed txId);
    event Revoke(address indexed owner, uint256 indexed txId);
    event Execute(uint256 indexed txId);

    // receive
    receive() external payable {
        emit Deposit(msg.sender, msg.value);
    }

    // å‡½æ•°ä¿®æ”¹å™¨
    modifier onlyOwner() {
        require(isOwner[msg.sender], "not owner");
        _;
    }
    modifier txExists(uint256 _txId) {
        require(_txId < transactions.length, "tx doesn't exist");
        _;
    }
    modifier notApproved(uint256 _txId) {
        require(!approved[_txId][msg.sender], "tx already approved");
        _;
    }
    modifier notExecuted(uint256 _txId) {
        require(!transactions[_txId].exected, "tx is exected");
        _;
    }

    // æ„é€ å‡½æ•°
    constructor(address[] memory _owners, uint256 _required) {
        require(_owners.length > 0, "owner required");
        require(
            _required > 0 && _required <= _owners.length,
            "invalid required number of owners"
        );

        for (uint256 index = 0; index < _owners.length; index++) {
            address owner = _owners[index];
            require(owner != address(0), "invalid owner");
            require(!isOwner[owner], "owner is not unique"); // å¦‚æœé‡å¤ä¼šæŠ›å‡ºé”™è¯¯
            isOwner[owner] = true;
            owners.push(owner);
        }
        required = _required;
    }

    // å‡½æ•°
    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }

    function submit(
        address _to,
        uint256 _value,
        bytes calldata _data
    ) external onlyOwner returns(uint256){
        transactions.push(
            Transaction({to: _to, value: _value, data: _data, exected: false})
        );
        emit Submit(transactions.length - 1);
        return transactions.length - 1;
    }

    function approv(uint256 _txId)
        external
        onlyOwner
        txExists(_txId)
        notApproved(_txId)
        notExecuted(_txId)
    {
        approved[_txId][msg.sender] = true;
        emit Approve(msg.sender, _txId);
    }

    function execute(uint256 _txId)
        external
        onlyOwner
        txExists(_txId)
        notExecuted(_txId)
    {
        require(getApprovalCount(_txId) >= required, "approvals < required");

        Transaction storage transaction = transactions[_txId];
        transaction.exected = true;

        (bool sucess, ) = transaction.to.call{value: transaction.value}(
            transaction.data
        );
        require(sucess, "tx failed");
        emit Execute(_txId);
    }

    function getApprovalCount(uint256 _txId)
        public
        view
        returns (uint256 count)
    {
        for (uint256 index = 0; index < owners.length; index++) {
            if (approved[_txId][owners[index]]) {
                count += 1;
            }
        }
    }

    function revoke(uint256 _txId)
        external
        onlyOwner
        txExists(_txId)
        notExecuted(_txId)
    {
        require(approved[_txId][msg.sender], "tx not approved");
        approved[_txId][msg.sender] = false;
        emit Revoke(msg.sender, _txId);
    }
}
```

### æµ‹è¯•æµç¨‹

1. éƒ¨ç½²åˆçº¦
   1. ä¼ å…¥æ‰€æœ‰ owner åœ°å€
   2. ä¼ å…¥éœ€è¦çš„æ‰¹å‡†æ•°: ä¾‹å­æ˜¯ 3
2. è°ƒç”¨ `required` æŸ¥è¯¢éœ€è¦çš„æ•°é‡
3. è·å– `getBalance` æŸ¥è¯¢å½“å‰åœ°å€çš„ ETH ä¸»å¸ä½™é¢
4. ä½¿ç”¨ `isOwner` æŸ¥è¯¢å¤šä¸ªåœ°å€çš„æƒé™ï¼Œçœ‹æ˜¯å¦ç¬¦åˆé¢„æœŸ
5. ä½¿ç”¨ `owners` æŸ¥è¯¢ä¸åŒçš„ç´¢å¼•æ˜¯å¦ç¬¦åˆé¢„æœŸ
6. ä½¿ç”¨ `transactions` æŸ¥è¯¢åˆå§‹æ˜¯å¦ä¸ºæ²¡æœ‰å€¼
7. **ä½¿ç”¨å…¶ä»–åœ°å€å‘åˆçº¦å†…è½¬å…¥ ETH ä¸»å¸**
8. ä½¿ç”¨ `getBalance` æŸ¥è¯¢å½“å‰åœ°å€çš„ ETH ä½™é¢æ˜¯å¦ç¬¦åˆé¢„æœŸ
9. è°ƒç”¨ `submit`ï¼Œç”³è¯·è½¬å‡ºä¸€ç¬”é’±åˆ°æŒ‡å®šåœ°å€
   1. `_to` åœ°å€
   2. `_value` éœ€è¦çš„é‡‘é¢
   3. `_data`: å¦‚æœæ²¡æœ‰éœ€è¦çš„æ‰§è¡Œçš„ä»£ç ï¼Œä¼ å…¥é»˜è®¤çš„ `0x`å³å¯
   4. è¿”å›å€¼ä¸ºæœ¬æ¬¡äº¤æ˜“çš„ `txId`
   5. è®°å½• `_to` çš„å½“å‰ä½™é¢
   6. è®°å½• åˆçº¦çš„å½“å‰ä½™é¢ï¼Œä½¿ç”¨ `getBalance` è·å–
10. ä½¿ç”¨ `transactions` æŸ¥è¯¢ `txId` æ˜¯å¦ä¸ºé¢„æœŸ
11. ä½¿ç”¨ `getApprovalCount` æŸ¥è¯¢æ‰¹å‡†æ•°é‡æ˜¯å¦ä¸º 0
12. ä½¿ç”¨ `getBalance` æŸ¥è¯¢å½“å‰åœ°å€çš„ ETH ï¼Œç¡®è®¤é’±æ²¡æœ‰è¢«è½¬å‡º
13. ä½¿ç”¨ `approved` æŸ¥è¯¢å½“å‰ `txId` æ˜¯å¦è¢« owner1 æ‰¹å‡†
14. **ä½¿ç”¨ owner1 è°ƒç”¨ `approv` å¯¹ `txId` è¿›è¡Œæ‰¹å‡†**
15. ä½¿ç”¨ `getApprovalCount` æŸ¥è¯¢æ‰¹å‡†æ•°é‡æ˜¯å¦ä¸º 1
16. ä½¿ç”¨ owner1 è°ƒç”¨ `approv` å¯¹ `txId` è¿›è¡Œå†æ¬¡æ‰¹å‡†
    1. æŸ¥çœ‹æ˜¯å¦æŠ¥é”™ `tx already approved`
17. ä½¿ç”¨ `approved` æŸ¥è¯¢å½“å‰ `txId` æ˜¯å¦è¢«æŸä¸ª owner1 æ‰¹å‡†
18. ä½¿ç”¨ `getBalance` å’Œ `transactions` æŸ¥è¯¢ `txId` æ˜¯å¦ä¸ºé¢„æœŸ
19. **ä½¿ç”¨ `owner2` `owner3` åœ°å€è°ƒç”¨ `approv` å¯¹ `txId` è¿›è¡Œæ‰¹å‡†**
    1. ä½¿ç”¨ `approved` æŸ¥è¯¢å½“å‰ `txId` æ˜¯å¦è¢« owner1 æ‰¹å‡†
20. ç”¨ `getApprovalCount` æŸ¥è¯¢æ‰¹å‡†æ•°é‡æ˜¯å¦ä¸º 3
21. **ä½¿ç”¨ owner1 è°ƒç”¨ `revoke` å¯¹ `txId` è¿›è¡Œæ‰¹å‡†æ’¤é”€**
22. ç”¨ `getApprovalCount` æŸ¥è¯¢æ‰¹å‡†æ•°é‡æ˜¯å¦ä¸º 2
23. ä½¿ç”¨ owner1 è°ƒç”¨ `execute` è¿›è¡Œæ­£å¼æ‰§è¡Œ
    1. æŸ¥çœ‹æ˜¯å¦æŠ¥é”™ `"approvals < required"`.
24. **ä½¿ç”¨ owner1 è°ƒç”¨ `revoke` å¯¹ `txId` è¿›è¡Œå†æ¬¡æ‰¹å‡†**
    1. ä½¿ç”¨ `approved` æŸ¥è¯¢å½“å‰ `txId` æ˜¯å¦è¢« owner1 æ‰¹å‡†
25. ç”¨ `getApprovalCount` æŸ¥è¯¢æ‰¹å‡†æ•°é‡æ˜¯å¦ä¸º 3
26. **ä½¿ç”¨ owner1 å†æ¬¡è°ƒç”¨ `execute` è¿›è¡Œæ­£å¼æ‰§è¡Œ**
    1. æŸ¥è¯¢å½“å‰äº¤æ˜“æ˜¯å¦æ­£ç¡®æ‰§è¡Œ
27. ç¡®è®¤æ‰§è¡Œçš„ç»“æœæ˜¯å¦ç¬¦åˆé¢„æœŸ
    1. ä½¿ç”¨ `transactions` æŸ¥è¯¢ `txId` çš„ `exected` æ˜¯å¦ä¸º true
    2. `_to` åœ°å€æ˜¯å¦æ”¶åˆ°é‡‘é¢ï¼Œ
    3. ä½¿ç”¨ `getBalance` æŸ¥è¯¢å½“å‰åœ°å€çš„ ETH ä½™é¢æ˜¯å¦æ­£ç¡®

## é—®ç­”é¢˜

- ä¸ºä»€ä¹ˆ `uint8/int8`è‡³ `uint256/uint256` éƒ½æ˜¯ä»¥ 8 çš„å€æ•°é€’å¢ï¼Œä¸”æœ€å¤§å€¼æ˜¯ 256ã€‚
  - 1 å­—èŠ‚æ˜¯ 8 ä½ï¼Œæ‰€ä»¥åé¢ 8,16,éƒ½éœ€è¦æ˜¯ 8 çš„æ•´æ•°å€ï¼Œint8 æ˜¯ 8 ä½ã€‚EVM ä¸ºåœ°å€è®¾ç½®çš„æœ€å¤§é•¿åº¦æ˜¯ 256 ä½ï¼Œæ‰€ä»¥æœ€å¤§å€¼æ˜¯`uint256/uint256`ã€‚
- ä¸ºä»€ä¹ˆ `uint256` çš„æœ€å¤§å€¼æ˜¯ `2**256 -1`ï¼Œè€Œä¸æ˜¯ `2**256` å‘¢ï¼Ÿ
  - 1 å­—èŠ‚æ˜¯ 8 ä½ï¼Œint8 æ˜¯ 8 ä½ï¼ŒäºŒè¿›åˆ¶è¡¨ç¤ºä¸º`0000 0000`è‡³`1000 0000`ï¼Œç¬¬ä¸€ä½æ˜¯ç¬¦å·ä½;ç¬¬ä¸€ä½ä¸º 0 æ˜¯æ­£å€¼ï¼Œç¬¬ä¸€ä½ä¸º 1 æ˜¯è´Ÿå€¼ï¼›å› ä¸º int8 æ€»å…±èƒ½å¤Ÿè¡¨ç¤º 2 çš„ 8 æ¬¡æ–¹ï¼Œæ‰€ä»¥å¸¦ç¬¦å·çš„æ­£å€¼ä¸º 128 ä¸ªæ•°ï¼Œè´Ÿå€¼ä¸º 128 ä¸ªæ•°ï¼›
  - è®¡ç®—æœºé‡Œæ˜¯å°† 0 ç®—åœ¨æ­£å€¼å†…ï¼Œè´Ÿå€¼çš„èŒƒå›´è¿˜æ˜¯-128ï¼›ä½†æ˜¯ **0 ä¸æ˜¯æ­£æ•°ä¹Ÿä¸æ˜¯è´Ÿæ•°**ï¼Œæ‰€ä»¥æ­£å€¼èŒƒå›´å°‘äº†ä¸€ä¸ªä½ç½®ï¼Œå°±å‰© 127 ä¸ªä½ç½®äº†ã€‚
- è®¡ç®—æœºä¸­ å­—èŠ‚ & bit & åå…­è¿›åˆ¶æ•°å­—çš„å…³ç³»
  - bytes1 æ˜¯æŒ‡ 1 ä¸ªå­—èŠ‚ï¼Œ1 ä¸ªå­—èŠ‚å¯ä»¥è¡¨ç¤ºæˆ 2 ä¸ªè¿ç»­çš„ 16 è¿›åˆ¶æ•°å­—ã€‚æœ€å¤§å€¼æ˜¯ `0xff`
  - bytes1 æ˜¯æŒ‡ 1 ä¸ªå­—èŠ‚ï¼Œ1 ä¸ªå­—èŠ‚å¯ä»¥è¡¨ç¤ºæˆ 8 ä¸ªè¿ç»­çš„ bit æ•°å­—ã€‚æœ€å¤§å€¼æ˜¯ `11111111`
    - `bytes1` ç­‰äºä¸¤ä½è¿ç»­çš„åå…­è¿›åˆ¶æ•°å­— `0xXX`
  - 8 ä¸ª bit æœ€å¤§å€¼æ˜¯ `11111111`,8 ä¸ª bit å¯¹åº” 2 ä¸ªè¿ç»­çš„åå…­è¿›åˆ¶æ•°å­—ï¼Œæœ€å¤§æ˜¯ `0xff`;
    - `uint8` ç­‰äºä¸¤ä½è¿ç»­çš„åå…­è¿›åˆ¶æ•°å­— `0xXX`
- Solidity çš„å€¼ç±»å‹å’Œå¼•ç”¨ç±»å‹åˆ†åˆ«æœ‰å“ªäº›ï¼Ÿ
  - å€¼ç±»å‹
    - boolean
    - integer æ•´å‹
    - integer æ•´å‹å­—é¢é‡`123_456_789`/`uint8 public a = (2**800 + 1) - 2**800;`
    - Fixed å®šé•¿æµ®ç‚¹å‹,å¯ä»¥å£°æ˜å®šé•¿æµ®ç‚¹å‹çš„å˜é‡ï¼Œä½†ä¸èƒ½ç»™å®ƒä»¬èµ‹å€¼æˆ–æŠŠå®ƒä»¬èµ‹å€¼ç»™å…¶ä»–å˜é‡ã€‚
    - BytesN å®šé•¿å­—èŠ‚æ•°ç»„
    - å­—ç¬¦ä¸²å­—é¢é‡ï¼Œæ¯”å¦‚ `bytes1 public a8 = "a";`,ä¹ŸåŒ…æ‹¬ unicode å­—é¢å¸¸é‡ã€‚
    - åå…­è¿›åˆ¶å­—é¢å¸¸é‡
      ```
      contract Test {
          string public a1 = "a";
          bytes1 public a2 = "a";
          bytes1 public a3 = 0x61;
          bytes1 public a4 = hex"61";
      }
      ```
    - Enum:æšä¸¾
    - ç”¨æˆ·å®šä¹‰çš„å€¼ç±»å‹;ç”¨æˆ·å®šä¹‰å€¼ç±»å‹ä½¿ç”¨ type UserType is DefaultType æ¥å®šä¹‰ï¼Œå…¶ä¸­ UserType æ˜¯æ–°å¼•å…¥çš„ç±»å‹çš„åç§°ï¼Œ DefaultType å¿…é¡»æ˜¯å†…ç½®çš„å€¼ç±»å‹ï¼ˆâ€åº•å±‚ç±»å‹â€ï¼‰ã€‚
    - åœ°å€ç±»å‹/åˆç±»å‹çº¦
    - å‡½æ•°ç±»å‹
  - å¼•ç”¨ç±»å‹
    - array
    - bytesï¼ˆbytes å’Œ bytes32[] åŒºåˆ«ï¼‰
    - string
    - mapping
    - struct

**int/uint**

- å¦‚ä½•è·å–æ•´å‹çš„æœ€å¤§å€¼å’Œæœ€å°å€¼
  - å¯ä»¥ä½¿ç”¨ `type(int8).max` è·å–è¯¥ç±»å‹çš„æœ€å¤§å€¼
  - å¯ä»¥ä½¿ç”¨ `type(int8).min` è·å–è¯¥ç±»å‹çš„æœ€å°å€¼
- èŠä¸€èŠ `checked` å’Œ `unchecked`
  - 0.8.0 å¼€å§‹ï¼Œç®—æœ¯è¿ç®—æœ‰ä¸¤ç§è®¡ç®—æ¨¡å¼ï¼šä¸€ç§æ˜¯`checked`ï¼ˆæ£€æŸ¥ï¼‰æ¨¡å¼ï¼Œå¦ä¸€ç§æ˜¯ `unchecked`ï¼ˆä¸æ£€æŸ¥ï¼‰æ¨¡å¼ã€‚ é»˜è®¤æƒ…å†µä¸‹ï¼Œç®—æœ¯è¿ç®—åœ¨ `checked` æ¨¡å¼ä¸‹ï¼Œå³éƒ½ä¼šè¿›è¡Œæº¢å‡ºæ£€æŸ¥ï¼Œå¦‚æœç»“æœè½åœ¨å–å€¼èŒƒå›´ä¹‹å¤–ï¼Œè°ƒç”¨ä¼šé€šè¿‡ å¤±è´¥å¼‚å¸¸ å›é€€ã€‚ ä½ ä¹Ÿå¯ä»¥é€šè¿‡ `unchecked{ ... }` åˆ‡æ¢åˆ° â€œuncheckedâ€æ¨¡å¼ï¼Œæ›´å¤šå¯å‚è€ƒ `unchecked` .
  - ç°åœ¨ä¸éœ€è¦å› ä¸º safeMath åº“äº†ã€‚
- ä¸‹é¢ä»£ç ä¼šæŠ¥é”™ä¹ˆï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ

  ```
  uint8 public a = (2**800 + 1) - 2**800; // 1
  uint8 public b = 0.5 * 8; // 4
  uint8 public c = 2.5 + b + 0.5;
  ```

  - `(2**800 + 1) - 2**800` çš„ç»“æœæ˜¯å­—é¢å¸¸é‡ 1 ï¼ˆå±äº uint8 ç±»å‹ï¼‰ï¼Œå°½ç®¡è®¡ç®—çš„ä¸­é—´ç»“æœå·²ç»è¶…è¿‡äº† ä»¥å¤ªåŠè™šæ‹Ÿæœºçš„æœºå™¨å­—é•¿åº¦ã€‚ æ­¤å¤–ï¼Œ `.5 * 8` çš„ç»“æœæ˜¯æ•´å‹ `4` ï¼ˆå°½ç®¡æœ‰éæ•´å‹å‚ä¸äº†è®¡ç®—ï¼‰ã€‚
  - å°½ç®¡æˆ‘ä»¬çŸ¥é“ b çš„å€¼æ˜¯ä¸€ä¸ªæ•´æ•°ï¼Œä½† `2.5 + a` è¿™éƒ¨åˆ†è¡¨è¾¾å¼å¹¶ä¸è¿›è¡Œç±»å‹æ£€æŸ¥ï¼Œå› æ­¤ç¼–è¯‘ä¸èƒ½é€šè¿‡ã€‚

- ä¸‹é¢ä»£ç ä¸­çš„`c1`/`c2`ç»“æœæ˜¯ä»€ä¹ˆï¼Ÿ
  ```
  uint256 a = 1;
  uint256 b = 4;
  uint256 c1 = (1 / 4) * 4; // 1 => æœªæˆªæ–­
  uint256 c2 = (a / b) * b; // 0 => æˆªæ–­
  ```
  - æ•´æ•°çš„é™¤æ³•ä¼šè¢«æˆªæ–­ï¼ˆä¾‹å¦‚ï¼š`1/4` ç»“æœä¸º 0ï¼‰,ä½†æ˜¯ä½¿ç”¨å­—é¢é‡çš„æ–¹å¼ä¸ä¼šè¢«æˆªæ–­
- ä¸‹é¢ä¸¤ä¸ªå‡½æ•°éƒ½ä¼šè¿è¡ŒæˆåŠŸä¹ˆï¼Ÿ

  ```
  function test1() public pure returns (int256 a) {
      a = type(int256).min / (-2);
  }

  // VM error: revert.
  function test2() public pure returns (int256 a) {
      a = type(int256).min / (-1);
  }
  ```

  - è¡¨è¾¾å¼ `type(int).min / (-1)` æ˜¯ä»…æœ‰çš„æ•´é™¤ä¼šå‘ç”Ÿå‘ä¸Šæº¢å‡ºçš„æƒ…å†µã€‚ åœ¨ç®—æœ¯æ£€æŸ¥æ¨¡å¼ä¸‹ï¼Œè¿™ä¼šè§¦å‘ä¸€ä¸ªå¤±è´¥å¼‚å¸¸ï¼Œåœ¨æˆªæ–­æ¨¡å¼ä¸‹ï¼Œè¡¨è¾¾å¼çš„å€¼å°†æ˜¯ `type(int).min` ã€‚

- ä¸‹é¢ä¾‹å­è¾“å‡ºä»€ä¹ˆï¼Ÿ

  - ä½ å¯èƒ½è®¤ä¸ºåƒ` 255 + (true ? 1 : 0)` æˆ– `255 + [1, 2, 3][0]` è¿™æ ·çš„è¡¨è¾¾å¼ç­‰åŒäºç›´æ¥ä½¿ç”¨ 256 å­—é¢å¸¸é‡ã€‚ ä½†äº‹å®ä¸Šï¼Œå®ƒä»¬æ˜¯åœ¨ `uint8` ç±»å‹ä¸­è®¡ç®—çš„ï¼Œä¼šæº¢å‡ºã€‚

  ```
  // VM error: revert.
  function testA1() public pure returns (uint256 a) {
      a = 255 + (true ? 1 : 0);
  }

  function testA2() public pure returns (uint256 a) {
      a = (true ? 1 : 0) + 255;
  }

  // VM error: revert.
  function testB1() public pure returns (uint256 a) {
      a = 255 + [1, 2, 3][0];
  }

  function testB2() public pure returns (uint256 a) {
      a = [1, 2, 3][0] + 255;
  }

  function testA3() public pure returns (uint256 a) {
      a = 255 + uint256(true ? 1 : 0);
  }

  function testB3() public pure returns (uint256 a) {
      a = 255 + uint256([1, 2, 3][0]);
  }
  ```

**BytesN å®šé•¿å­—èŠ‚æ•°ç»„**

- `bytesN` æœ‰å“ªäº›å±æ€§ï¼Œåˆ†åˆ«æ€ä¹ˆä½¿ç”¨ã€‚
  - å®šä¹‰æ–¹å¼ `bytesN`ï¼Œå…¶ä¸­ N å¯å– `1~32` ä¸­çš„ä»»æ„æ•´æ•°;bytes1 ä»£è¡¨åªèƒ½å­˜å‚¨ä¸€ä¸ªå­—èŠ‚ã€‚ä¸€æ—¦å£°æ˜ï¼Œå…¶å†…éƒ¨çš„å­—èŠ‚é•¿åº¦ä¸å¯ä¿®æ”¹ï¼Œå†…éƒ¨å­—èŠ‚ä¸å¯ä¿®æ”¹ã€‚æ³¨æ„è¿™é‡Œ `bytes32` å’Œ `bytes` æ˜¯ä¸åŒçš„ã€‚`bytes` æ˜¯å˜é•¿å­—èŠ‚æ•°ç»„ï¼Œæ˜¯å¼•ç”¨ç±»å‹ã€‚`byte` æ˜¯ `bytes1` çš„åˆ«åï¼Œä¸æ¨èä½¿ç”¨ã€‚
  - `length` ï¼ˆåªè¯»ï¼‰
    - è¿”å›å­—èŠ‚ä¸ªæ•°ï¼Œå¯ä»¥é€šè¿‡ç´¢å¼•è¯»å–å¯¹åº”ç´¢å¼•çš„å­—èŠ‚ã€‚
  - ç´¢å¼•è®¿é—®: `bytesN[index]`
    - index å–å€¼èŒƒå›´`[0, N]`ï¼Œå…¶ä¸­ N è¡¨ç¤ºé•¿åº¦ã€‚
    - å¦‚æœ `x` æ˜¯ `bytesI` ç±»å‹ï¼Œé‚£ä¹ˆ `x[k]` ï¼ˆå…¶ä¸­ 0 <= k < Iï¼‰è¿”å›ç¬¬ k ä¸ªå­—èŠ‚ï¼ˆåªè¯»ï¼‰ã€‚
- `bytesN` æœ‰ä»€ä¹ˆæ–¹æ³•ï¼Ÿ
  - è‡ªå·±æ²¡æœ‰æ–¹æ³•ï¼Œå¯ä»¥å…¨å±€çš„ï¼Œæ¯”å¦‚ deleteã€‚
- `"a"` æ˜¯å€¼ç±»å‹è¿˜æ˜¯å¼•ç”¨ç±»å‹ï¼Ÿ
  - æ³¨ï¼šå­—ç¬¦ä¸²å­—é¢å¸¸é‡æ˜¯å€¼ç±»å‹,è¿™ä¸æ˜¯å­—ç¬¦ä¸²ç±»å‹ã€‚æ¯”å¦‚`bytes1 public b1 = "a";`

**Unicode**

- æ€ä¹ˆæ ·è¾“å‡ºä¸­æ–‡å­—ç¬¦ä¸²ï¼Ÿï¼ˆ`unicode"åŒå¿—ä»¬å¥½"`ï¼‰

**åå…­è¿›åˆ¶å­—é¢å¸¸é‡**

- `bytes1 public a4 = hex"61";` çš„å€¼æ˜¯ä»€ä¹ˆï¼Ÿï¼ˆ`0x61`ï¼‰

**Enum:æšä¸¾**

- æšä¸¾ç±»å‹çš„ä½¿ç”¨åœºæ™¯
  - `enum` æ˜¯ä¸€ç§ç”¨æˆ·è‡ªå®šä¹‰ç±»å‹ï¼Œç”¨äºè¡¨ç¤ºå¤šç§çŠ¶æ€ï¼Œæšä¸¾å¯ç”¨æ¥åˆ›å»ºç”±ä¸€å®šæ•°é‡çš„â€œå¸¸é‡å€¼â€æ„æˆçš„è‡ªå®šä¹‰ç±»å‹ã€‚ä¸»è¦ä½œç”¨æ˜¯ç”¨äºé™åˆ¶æŸä¸ªäº‹åŠ¡çš„æœ‰é™é€‰æ‹©ã€‚æ¯”å¦‚å°†å’–å•¡çš„å®¹é‡å¤§å°é™åˆ¶ä¸ºï¼šå¤§ã€ä¸­ã€å°ï¼Œè¿™å°†ç¡®ä¿ä»»ä½•äººä¸èƒ½è´­ä¹°å…¶ä»–å®¹é‡çš„å’–å•¡ï¼Œåªèƒ½åœ¨è¿™é‡Œé€‰æ‹©ã€‚
- Enum çš„å±æ€§å’Œæ–¹æ³•
  - é€‰é¡¹ä» 0 å¼€å§‹çš„æ— ç¬¦å·æ•´æ•°å€¼è¡¨ç¤ºã€‚
  - `type(NameOfEnum).min/max`
  - delete æ¢å¤é»˜è®¤
- èŠä¸€èŠæšä¸¾ç±»å‹
  - æšä¸¾ç±»å‹ï¼Œè¿”å›å€¼æ˜¯ç´¢å¼•ï¼Œé»˜è®¤å€¼æ˜¯ 0;
  - æšä¸¾ç±»å‹çš„é»˜è®¤å€¼æ˜¯ç¬¬ä¸€ä¸ªå€¼ã€‚
    - æšä¸¾ç±»å‹ enum è‡³å°‘åº”è¯¥æœ‰ä¸€åæˆå‘˜ã€‚
  - è®¾ç½®çš„æ—¶å€™ï¼Œå¯ä»¥è®¾ç½®ä¸ºç´¢å¼•ï¼Œä¹Ÿå¯ä»¥å¯¹åº”çš„æšä¸¾åç§°;
  - æšä¸¾ç±»å‹ enum å¯ä»¥ä¸æ•´æ•°è¿›è¡Œæ˜¾å¼è½¬æ¢ï¼Œä½†ä¸èƒ½è¿›è¡Œéšå¼è½¬æ¢ã€‚
    - æ˜¾ç¤ºè½¬æ¢ä¼šåœ¨è¿è¡Œæ—¶æ£€æŸ¥æ•°å€¼èŒƒå›´ï¼Œå¦‚æœä¸åŒ¹é…ï¼Œå°†ä¼šå¼•èµ·å¼‚å¸¸ã€‚
  - å¾ˆå¤šäººæ„Ÿè§‰ enum å¾ˆå°‘ç”¨ï¼Œä¸€æ˜¯å› ä¸ºåº”ç”¨åœºæ™¯ç¡®å®æ¯”è¾ƒçª„ï¼ŒäºŒæ˜¯å› ä¸ºå¯ä»¥è¢«å…¶ä»–æ•°æ®ç±»å‹æ‰€ä»£æ›¿ï¼›ä½†æŒ‰ç…§ç¼–ç è§„èŒƒï¼Œé™åˆ¶é€‰æ‹©èŒƒå›´åœºæ™¯ï¼Œé™¤äº† bool ä»¥å¤–çš„ï¼Œæ¨èä½¿ç”¨ enum ç±»å‹æ¥å®šä¹‰ã€‚

**UserType ç”¨æˆ·å®šä¹‰çš„å€¼ç±»å‹**

- èŠä¸€èŠ UserTypeã€‚
  - ç”¨æˆ·å®šä¹‰å€¼ç±»å‹ä½¿ç”¨ `type UserType is DefaultType` æ¥å®šä¹‰ï¼Œå…¶ä¸­ `UserType` æ˜¯æ–°å¼•å…¥çš„ç±»å‹çš„åç§°ï¼Œ `DefaultType` å¿…é¡»æ˜¯å†…ç½®çš„å€¼ç±»å‹ï¼ˆâ€åº•å±‚ç±»å‹â€ï¼‰ã€‚è‡ªå®šä¹‰ç±»å‹çš„å€¼çš„æ•°æ®è¡¨ç¤ºåˆ™ç»§æ‰¿è‡ªåº•å±‚ç±»å‹ï¼Œå¹¶ä¸” ABI ä¸­ä¹Ÿä½¿ç”¨åº•å±‚ç±»å‹ã€‚
  - âš ï¸: ç”¨æˆ·å®šä¹‰çš„ç±»å‹ `UserType` æ²¡æœ‰ä»»ä½•è¿ç®—ç¬¦æˆ–ç»‘å®šæˆå‘˜å‡½æ•°ã€‚å³ä½¿æ˜¯æ“ä½œç¬¦ `==` ä¹Ÿæ²¡æœ‰å®šä¹‰ã€‚ä¹Ÿä¸å…è®¸ä¸å…¶ä»–ç±»å‹è¿›è¡Œæ˜¾å¼å’Œéšå¼è½¬æ¢ã€‚
- UserType æœ‰å±æ€§ä¹ˆï¼Ÿæœ‰æ–¹æ³•ä¹ˆï¼Ÿ
  - `UserType.wrap()`
  - `UserType.unwrap()`

**address**

- `address` å’Œ `address payable` æœ‰ä»€ä¹ˆåŒºåˆ«
  - `address`ï¼šä¿å­˜ä¸€ä¸ª 20 å­—èŠ‚çš„å€¼ï¼ˆä»¥å¤ªåŠåœ°å€çš„å¤§å°ï¼‰ã€‚
  - `address payable` ï¼šå¯æ”¯ä»˜åœ°å€ï¼Œä¸ `address` ç›¸åŒï¼Œä¸è¿‡æœ‰æˆå‘˜å‡½æ•° `transfer` å’Œ `send` ã€‚
  - å¦‚æœä½ éœ€è¦ `address` ç±»å‹çš„å˜é‡ï¼Œå¹¶è®¡åˆ’å‘é€ä»¥å¤ªå¸ç»™è¿™ä¸ªåœ°å€ï¼Œé‚£ä¹ˆå£°æ˜ç±»å‹ä¸º `address payable` å¯ä»¥æ˜ç¡®è¡¨è¾¾å‡ºä½ çš„éœ€æ±‚ã€‚ åŒæ ·ï¼Œå°½é‡æ›´æ—©å¯¹ä»–ä»¬è¿›è¡ŒåŒºåˆ†æˆ–è½¬æ¢ã€‚
  - è¿™ç§åŒºåˆ«èƒŒåçš„æ€æƒ³æ˜¯ `address payable` å¯ä»¥å‘å…¶å‘é€ä»¥å¤ªå¸ï¼Œè€Œä¸èƒ½å‘ä¸€ä¸ªæ™®é€šçš„ `address` å‘é€ä»¥å¤ªå¸ã€‚æ¯”å¦‚ï¼Œå®ƒå¯èƒ½æ˜¯ä¸€ä¸ªæ™ºèƒ½åˆçº¦åœ°å€ï¼Œå¹¶ä¸”ä¸æ”¯æŒæ¥æ”¶ä»¥å¤ªå¸ã€‚
- address ç±»å‹åˆ†åˆ«æœ‰ä»€ä¹ˆå±æ€§ï¼Ÿä»‹ç»ä¸€ä¸‹ç”¨é€”
  1. .balance : ä»¥ Wei ä¸ºå•ä½çš„ä½™é¢ã€‚
     ```
     <address>.balance    returns(uint256)
     ```
  2. .code : åœ°å€ä¸Šçš„ä»£ç (å¯ä»¥ä¸ºç©º)
     ```
     <address>.code        returns(bytes memory)
     ```
  3. .codehash : åœ°å€çš„ codehash
     ```
     <address>.codehash    returns(bytes32)
     ```
- address ç±»å‹æœ‰å“ªäº›æ–¹æ³•ä»¥åŠå„è‡ªçš„ä½œç”¨ã€‚
  1. `address()`: å¯ä»¥å°†åœ°å€è½¬æ¢åˆ°åœ°å€ç±»å‹ã€‚
  2. `payable()`: å°†æ™®é€šåœ°å€è½¬ä¸ºå¯æ”¯ä»˜åœ°å€ã€‚
     1. ä» `address` åˆ° `address payable` çš„è½¬æ¢ã€‚å¯ä»¥é€šè¿‡ `payable(x)` è¿›è¡Œ ï¼Œå…¶ä¸­ `x` å¿…é¡»æ˜¯ `address` ç±»å‹ã€‚
  3. `.transfer(uint256 amount)`: å°†ä½™é¢è½¬åˆ°å½“å‰åœ°å€ï¼ˆåˆçº¦åœ°å€è½¬è´¦ï¼‰
     ```
     <address payable>.transfer(uint256 amount)
     ```
     1. å¤±è´¥æ—¶æŠ›å‡ºå¼‚å¸¸, ç­‰ä»·äº`require(send())` ä½¿ç”¨å›ºå®šï¼ˆä¸å¯è°ƒèŠ‚ï¼‰çš„ 2300 gas çš„çŸ¿å·¥è´¹ï¼Œé”™è¯¯ä¼š reverts
     2. éœ€è¦ payable address
  4. `.send(uint256 amount)`: å°†ä½™é¢è½¬åˆ°å½“å‰åœ°å€ï¼Œå¹¶**è¿”å›äº¤æ˜“æˆåŠŸçŠ¶æ€**ï¼ˆåˆçº¦åœ°å€è½¬è´¦ï¼‰
     ```
     <address payable>.send(uint256 amount) returns (bool)
     ```
     1. å¤±è´¥æ—¶ä»…ä¼šè¿”å› `false`ï¼Œä¸ä¼šç»ˆæ­¢æ‰§è¡Œï¼ˆåˆçº¦åœ°å€è½¬è´¦ï¼‰;ä½¿ç”¨å›ºå®šï¼ˆä¸å¯è°ƒèŠ‚ï¼‰çš„ 2300 gas çš„çŸ¿å·¥è´¹ã€‚
     2. éœ€è¦ payable address
     3. è¡¥å……ï¼šsend ä¸ transfer å¯¹åº”ï¼Œä½† **send æ›´åº•å±‚**ã€‚å¦‚æœæ‰§è¡Œå¤±è´¥ï¼Œtransfer ä¸ä¼šå› å¼‚å¸¸åœæ­¢ï¼Œè€Œ send ä¼šè¿”å› falseã€‚transfer ç›¸å¯¹ send è¾ƒå®‰å…¨
     4. send() æ‰§è¡Œæœ‰ä¸€äº›é£é™©ï¼šå¦‚æœè°ƒç”¨æ ˆçš„æ·±åº¦è¶…è¿‡ 1024 æˆ– gas è€—å…‰ï¼Œäº¤æ˜“éƒ½ä¼šå¤±è´¥ã€‚å› æ­¤ï¼Œä¸ºäº†ä¿è¯å®‰å…¨ï¼Œå¿…é¡»æ£€æŸ¥ send çš„è¿”å›å€¼ï¼Œå¦‚æœäº¤æ˜“å¤±è´¥ï¼Œä¼šå›é€€ä»¥å¤ªå¸ã€‚
  5. `.call(bytes memory)`: ç”¨ç»™å®šçš„æœ‰æ•ˆè½½è·ï¼ˆpayloadï¼‰å‘å‡ºä½çº§ `CALL` è°ƒç”¨ï¼Œå¹¶**è¿”å›äº¤æ˜“æˆåŠŸçŠ¶æ€å’Œè¿”å›æ•°æ®**ï¼ˆè°ƒç”¨åˆçº¦çš„æ–¹æ³•å¹¶è½¬è´¦ï¼‰
     ```
     <address>.call(bytes memory) returns (bool, bytes memory)
     ```
     1. å‘é€æ‰€æœ‰å¯ç”¨ gasï¼Œä¹Ÿå¯ä»¥è‡ªå·±è°ƒèŠ‚ gasã€‚
     2. è¿”å›ä¸¤ä¸ªå‚æ•°ï¼Œä¸€ä¸ª `bool` å€¼ä»£è¡¨æˆåŠŸæˆ–è€…å¤±è´¥ï¼Œå¦å¤–ä¸€ä¸ªæ˜¯å¯èƒ½å­˜åœ¨çš„ `data`
     3. ä½çº§ `CALL` è°ƒç”¨ï¼šä¸éœ€è¦ payable address, æ™®é€šåœ°å€å³å¯
  6. `.delegatecall(bytes memory)`: ç”¨ç»™å®šçš„æœ‰æ•ˆè½½è·ï¼ˆpayloadï¼‰å‘å‡ºä½çº§ `DELEGATECALL` è°ƒç”¨ï¼Œå¹¶**è¿”å›äº¤æ˜“æˆåŠŸçŠ¶æ€å’Œè¿”å›æ•°æ®**ï¼ˆè°ƒç”¨åˆçº¦çš„æ–¹æ³•å¹¶è½¬è´¦ï¼‰
     ```
     <address>.delegatecall(bytes memory) returns (bool, bytes memory)
     ```
     1. å‘å‡ºä½çº§å‡½æ•° `DELEGATECALL`ï¼Œå¤±è´¥æ—¶è¿”å› falseï¼Œå‘é€æ‰€æœ‰å¯ç”¨ gasï¼Œä¹Ÿå¯ä»¥è‡ªå·±è°ƒèŠ‚ gasã€‚
  7. `staticcall(bytes memory)`: ç”¨ç»™å®šçš„æœ‰æ•ˆè½½è·ï¼ˆpayloadï¼‰å‘å‡ºä½çº§ `STATICCALL` è°ƒç”¨ï¼Œå¹¶**è¿”å›äº¤æ˜“æˆåŠŸçŠ¶æ€å’Œè¿”å›æ•°æ®**ï¼ˆè°ƒç”¨åˆçº¦çš„æ–¹æ³•å¹¶è½¬è´¦ï¼‰
     ```
     <address>.staticcall(bytes memory) returns (bool, bytes memory)
     ```
     1. å‘é€æ‰€æœ‰å¯ç”¨ gasï¼Œä¹Ÿå¯ä»¥è‡ªå·±è°ƒèŠ‚ gasã€‚
- åœ°å€çš„ä¸‰ç§è½¬å¸æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿtransfer / send /call
  - ç›¸åŒç‚¹
    - ä¸‰ç§æ–¹æ³•éƒ½å¯ä»¥è¿›è¡Œè½¬è´¦
    - `_to.transfer(100)`ã€`_to.send(100)`ã€`_to.call{value: 100}("")` çš„æ¥æ”¶æ–¹éƒ½æ˜¯`_to`ã€‚
      - å¦‚æœ`_to`åˆçº¦ä¸­å¿…é¡»å¢åŠ  `fallback` æˆ–è€… `receive` å‡½æ•°ï¼
      - å¦åˆ™æŠ¥é”™`In order to receive Ether transfer the contract should have either 'receive' or payable 'fallback' function`
  - ä¸åŒç‚¹:
    - ä½çº§ `CALL` è°ƒç”¨ï¼šä¸éœ€è¦ `payable address`
      - transfer å’Œ send åªèƒ½æ˜¯ `payable address`
    - `call` çš„ gas å¯ä»¥åŠ¨æ€è°ƒæ•´
      - transfer å’Œ send åªèƒ½æ˜¯å›ºå®šåˆ¶ `2300`
    - `call` é™¤äº†å¯ä»¥è½¬è´¦å¤–ï¼Œå¯ä»¥è¿˜å¯ä»¥è°ƒç”¨ä¸çŸ¥é“ ABI çš„æ–¹æ³•ï¼Œè¿˜å¯ä»¥è°ƒç”¨çš„æ—¶å€™è½¬è´¦
      - å½“è°ƒç”¨ä¸å­˜åœ¨çš„åˆçº¦æ–¹æ³•æ—¶å€™ï¼Œä¼šè§¦å‘å¯¹æ–¹åˆçº¦å†…çš„ `fallback` æˆ–è€… `receive`ã€‚
      - å¦‚æœä½¿ç”¨ `_to.call{value: 100}(data)`ï¼Œé‚£ä¹ˆ`data`ä¸­è¢«è°ƒç”¨çš„æ–¹æ³•å¿…é¡»æ·»åŠ  `payable` ä¿®é¥°ç¬¦ï¼Œå¦åˆ™è½¬è´¦å¤±è´¥ï¼
      - å› ä¸ºå¯ä»¥è°ƒç”¨æ–¹æ³•ï¼Œæ‰€ä»¥ call æœ‰ä¸¤ä¸ªå‚æ•°ï¼Œé™¤äº†ä¸€ä¸ª `bool` å€¼ä»£è¡¨æˆåŠŸæˆ–è€…å¤±è´¥ï¼Œå¦å¤–ä¸€ä¸ªæ˜¯å¯èƒ½å­˜åœ¨çš„ `data`ï¼Œæ¯”å¦‚åˆ›å»ºåˆçº¦æ—¶å€™å¾—åˆ°éƒ¨ç½²çš„åœ°å€ï¼Œè°ƒç”¨å‡½æ•°æ—¶å€™å¾—åˆ°çš„å‡½æ•°æ”¾å›å€¼ã€‚
- delegatecall å’Œ call çš„åŒºåˆ«
  - `delegatecall` ä½¿ç”¨æ–¹æ³•å’Œ `call` å®Œå…¨ä¸€æ ·ã€‚åŒºåˆ«åœ¨äºï¼Œ`delegatecall` åªè°ƒç”¨ç»™å®šåœ°å€çš„ä»£ç ï¼ˆå‡½æ•°ï¼‰ï¼Œå…¶ä»–çŠ¶æ€å±æ€§å¦‚ï¼ˆå­˜å‚¨ï¼Œä½™é¢ â€¦ï¼‰éƒ½æ¥è‡ªå½“å‰åˆçº¦ã€‚`delegatecall` çš„ç›®çš„æ˜¯ä½¿ç”¨å¦ä¸€ä¸ªåˆçº¦ä¸­çš„åº“ä»£ç ã€‚
  - å§”æ‰˜è°ƒç”¨æ˜¯ï¼š**å§”æ‰˜å¯¹æ–¹è°ƒç”¨è‡ªå·±æ•°æ®çš„**ã€‚ç±»ä¼¼æˆæƒè½¬è´¦ï¼Œæ¯”å¦‚æˆ‘éƒ¨ç½²ä¸€ä¸ª Bank åˆçº¦ï¼Œ æˆæƒ ContractA ä½¿ç”¨ Bank åœ°å€å†…çš„èµ„é‡‘ï¼ŒContractA åªæ‹¥æœ‰æ§åˆ¶æƒï¼Œä½†æ˜¯æ²¡æœ‰æ‹¥æœ‰æƒã€‚
  - å§”æ‰˜è°ƒç”¨åï¼Œæ‰€æœ‰å˜é‡ä¿®æ”¹éƒ½æ˜¯å‘ç”Ÿåœ¨å§”æ‰˜åˆçº¦å†…éƒ¨ï¼Œå¹¶ä¸ä¼šä¿å­˜åœ¨è¢«å§”æ‰˜åˆçº¦ä¸­ã€‚
    - åˆ©ç”¨è¿™ä¸ªç‰¹æ€§ï¼Œå¯ä»¥é€šè¿‡æ›´æ¢è¢«å§”æ‰˜åˆçº¦ï¼Œæ¥å‡çº§å§”æ‰˜åˆçº¦ã€‚
  - å§”æ‰˜è°ƒç”¨åˆçº¦å†…éƒ¨ï¼Œéœ€è¦å’Œè¢«å§”æ‰˜åˆçº¦çš„å†…éƒ¨å‚æ•°å®Œå…¨ä¸€æ ·ï¼Œå¦åˆ™å®¹æ˜“å¯¼è‡´æ•°æ®æ··ä¹±
    - å¯ä»¥é€šè¿‡é¡ºåºæ¥é¿å…è¿™ä¸ªé—®é¢˜ï¼Œä½†æ˜¯æ¨èå®Œå…¨ä¸€æ ·
- èŠä¸€èŠä¸‰ç§ä½çº§ call
  1. `call` ï¼Œ `delegatecall` å’Œ `staticcall` éƒ½æ˜¯éå¸¸ä½çº§çš„å‡½æ•°ï¼Œåº”è¯¥åªæŠŠå®ƒä»¬å½“ä½œæœ€åä¸€æ‹›æ¥ä½¿ç”¨ï¼Œå®ƒä»¬ç ´åäº† Solidity çš„ç±»å‹å®‰å…¨æ€§ã€‚
  2. ä¸‰ç§æ–¹æ³•éƒ½æä¾› `gas` é€‰é¡¹ï¼Œè€Œ `value` é€‰é¡¹ä»… `call` æ”¯æŒ ã€‚æ‰€ä»¥ä¸‰ç§ call é‡Œåªæœ‰ `call` å¯ä»¥è¿›è¡Œ ETH è½¬è´¦ï¼Œå…¶ä»–ä¸¤ç§ä¸å¯ä»¥è¿›è¡Œè½¬è´¦ã€‚
  3. ä¸ç®¡æ˜¯è¯»å–çŠ¶æ€è¿˜æ˜¯å†™å…¥çŠ¶æ€ï¼Œæœ€å¥½é¿å…åœ¨åˆçº¦ä»£ç ä¸­ç¡¬ç¼–ç ä½¿ç”¨çš„ gas å€¼ã€‚è¿™å¯èƒ½ä¼šå¼•å…¥**é”™è¯¯**ï¼Œè€Œä¸” gas çš„æ¶ˆè€—ä¹Ÿæ˜¯åŠ¨æ€æ”¹å˜çš„ã€‚
  4. å¦‚æœåœ¨é€šè¿‡ä½çº§å‡½æ•° `delegatecall` å‘èµ·è°ƒç”¨æ—¶éœ€è¦è®¿é—®å­˜å‚¨ä¸­çš„å˜é‡ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªåˆçº¦çš„å­˜å‚¨å¸ƒå±€éœ€è¦ä¸€è‡´ï¼Œä»¥ä¾¿è¢«è°ƒç”¨çš„åˆçº¦ä»£ç å¯ä»¥æ­£ç¡®åœ°é€šè¿‡å˜é‡åè®¿é—®åˆçº¦çš„å­˜å‚¨å˜é‡ã€‚ è¿™ä¸æ˜¯æŒ‡åœ¨åº“å‡½æ•°è°ƒç”¨ï¼ˆé«˜çº§çš„è°ƒç”¨æ–¹å¼ï¼‰æ—¶æ‰€ä¼ é€’çš„å­˜å‚¨å˜é‡æŒ‡é’ˆéœ€è¦æ»¡è¶³é‚£æ ·æƒ…å†µã€‚
- ç¼–å†™åˆçº¦çš„æ—¶å€™ï¼Œå¦‚æœåœ°å€ä¸æ˜¯ checksum address ,è¯¥æ€ä¹ˆå¤„ç†ï¼Ÿ
  - é€šè¿‡æµè§ˆå™¨å†…è½¬
- èŠä¸€ä¸‹åˆçº¦ç±»å‹
  - æ¯ä¸€ä¸ªåˆçº¦å®šä¹‰éƒ½æœ‰ä»–è‡ªå·±çš„ç±»å‹ã€‚
  - å¯ä»¥éšå¼åœ°å°†åˆçº¦è½¬æ¢ä¸ºä»ä»–ä»¬ç»§æ‰¿çš„åˆçº¦ã€‚
  - åˆçº¦å¯ä»¥æ˜¾å¼è½¬æ¢ä¸º `address` ç±»å‹ã€‚
  - å¯ä»¥è½¬æ¢ä¸º `address payable` ç±»å‹
  - âš ï¸ æ³¨æ„ï¼šåˆçº¦ä¸æ”¯æŒä»»ä½•è¿ç®—ç¬¦ã€‚
- åˆçº¦çš„å±æ€§
  - `type(C).name`
    - è·å¾—åˆçº¦å
  - `type(C).creationCode`
    - è·å¾—åŒ…å«åˆ›å»ºåˆçº¦å­—èŠ‚ç çš„å†…å­˜å­—èŠ‚æ•°ç»„ã€‚
    - è¯¥å€¼å’Œåˆçº¦å†…ä½¿ç”¨ `address(this).code;` ç»“æœä¸€æ ·ã€‚
    - å®ƒå¯ä»¥åœ¨å†…è”æ±‡ç¼–ä¸­æ„å»ºè‡ªå®šä¹‰åˆ›å»ºä¾‹ç¨‹ï¼Œå°¤å…¶æ˜¯ä½¿ç”¨ `create2` æ“ä½œç ã€‚
    - ä¸èƒ½åœ¨åˆçº¦æœ¬èº«æˆ–æ´¾ç”Ÿçš„åˆçº¦è®¿é—®æ­¤å±æ€§ã€‚ å› ä¸ºä¼šå¼•èµ·å¾ªç¯å¼•ç”¨ã€‚
  - `type(C).runtimeCode`
    - è·å¾—åˆçº¦çš„è¿è¡Œæ—¶å­—èŠ‚ç çš„å†…å­˜å­—èŠ‚æ•°ç»„ã€‚è¿™æ˜¯é€šå¸¸ç”± `C` çš„æ„é€ å‡½æ•°éƒ¨ç½²çš„ä»£ç ã€‚
    - å¦‚æœ `C` æœ‰ä¸€ä¸ªä½¿ç”¨å†…è”æ±‡ç¼–çš„æ„é€ å‡½æ•°ï¼Œé‚£ä¹ˆå¯èƒ½ä¸å®é™…éƒ¨ç½²çš„å­—èŠ‚ç ä¸åŒã€‚
    - è¿˜è¦æ³¨æ„åº“åœ¨éƒ¨ç½²æ—¶ä¿®æ”¹å…¶è¿è¡Œæ—¶å­—èŠ‚ç ä»¥é˜²èŒƒå®šæœŸè°ƒç”¨ï¼ˆguard against regular callsï¼‰ã€‚ ä¸ `.creationCode` æœ‰ç›¸åŒçš„é™åˆ¶ï¼Œä¸èƒ½åœ¨åˆçº¦æœ¬èº«æˆ–æ´¾ç”Ÿçš„åˆçº¦è®¿é—®æ­¤å±æ€§ã€‚ å› ä¸ºä¼šå¼•èµ·å¾ªç¯å¼•ç”¨ã€‚
- å¦‚ä½•è·å–åˆçº¦æœ¬èº«çš„ bytecodeï¼Ÿ
  - `type(C).creationCode`

**æ•°æ®ä½ç½®**

- èŠä¸€èŠ storage/memory/calldata ä¸‰ç§æ•°æ®ä½ç½®

  - å­˜å‚¨ storage : çŠ¶æ€å˜é‡ä¿å­˜çš„ä½ç½®ï¼Œåªè¦åˆçº¦å­˜åœ¨å°±ä¸€ç›´å­˜å‚¨ï¼
  - å†…å­˜ memory : å³æ•°æ®åœ¨å†…å­˜ä¸­ï¼Œå› æ­¤æ•°æ®ä»…åœ¨å…¶ç”Ÿå‘½å‘¨æœŸå†…ï¼ˆå‡½æ•°è°ƒç”¨æœŸé—´ï¼‰æœ‰æ•ˆã€‚ä¸èƒ½ç”¨äºå¤–éƒ¨è°ƒç”¨ã€‚
  - è°ƒç”¨æ•°æ® calldata : ç”¨æ¥ä¿å­˜å‡½æ•°å‚æ•°çš„ç‰¹æ®Šæ•°æ®ä½ç½®ï¼Œæ˜¯ä¸€ä¸ªåªè¯»ä½ç½®ã€‚
    - è°ƒç”¨æ•°æ® calldata æ˜¯ä¸å¯ä¿®æ”¹çš„ã€éæŒä¹…çš„å‡½æ•°å‚æ•°å­˜å‚¨åŒºåŸŸï¼Œæ•ˆæœå¤§å¤šç±»ä¼¼ å†…å­˜ memory ã€‚
    - ä¸»è¦ç”¨äºå¤–éƒ¨å‡½æ•°çš„å‚æ•°ï¼Œä½†ä¹Ÿå¯ç”¨äºå…¶ä»–å˜é‡ï¼Œæ— è®ºå¤–éƒ¨å†…éƒ¨å‡½æ•°éƒ½å¯ä»¥ä½¿ç”¨ã€‚
  - æ ¸å¿ƒï¼šæ›´æ”¹æ•°æ®ä½ç½®æˆ–ç±»å‹è½¬æ¢å°†å§‹ç»ˆäº§ç”Ÿè‡ªåŠ¨è¿›è¡Œä¸€ä»½æ‹·è´ï¼Œè€Œåœ¨åŒä¸€æ•°æ®ä½ç½®å†…ï¼ˆå¯¹äº å­˜å‚¨ storage æ¥è¯´ï¼‰çš„å¤åˆ¶ä»…åœ¨æŸäº›æƒ…å†µä¸‹è¿›è¡Œæ‹·è´ã€‚

- ä¸‰ç§æ•°æ®ä½ç½®ç›¸äº’èµ‹å€¼ï¼Œä»¥åŠç›¸åŒæ•°æ®ä½ç½®ä¹‹é—´èµ‹å€¼éƒ½æ˜¯æ‹·è´ä¹ˆï¼Ÿè¯¦ç»†ä»‹ç»ä¸€ä¸‹ã€‚
  1. å°† <strong style="color:blue;">å­˜å‚¨å˜é‡</strong> èµ‹å€¼ç»™ **å­˜å‚¨å˜é‡** (åŒç±»å‹)
     - `å€¼ ç±» å‹`: åˆ›å»ºä¸€ä¸ªæ–°å‰¯æœ¬ã€‚
     - `å¼•ç”¨ç±»å‹`: åˆ›å»ºä¸€ä¸ªæ–°å‰¯æœ¬ã€‚
  2. å°† <strong style="color:red;">å†…å­˜å˜é‡</strong> èµ‹å€¼ç»™ **å­˜å‚¨å˜é‡**
     - `å€¼ ç±» å‹`: åˆ›å»ºä¸€ä¸ªæ–°å‰¯æœ¬ã€‚
     - `å¼•ç”¨ç±»å‹`: åˆ›å»ºä¸€ä¸ªæ–°å‰¯æœ¬ã€‚
  3. å°† <strong style="color:blue;">å­˜å‚¨å˜é‡</strong> èµ‹å€¼ç»™ å†…å­˜å˜é‡
     - `å€¼ ç±» å‹`: åˆ›å»ºä¸€ä¸ªæ–°å‰¯æœ¬ã€‚
     - `å¼•ç”¨ç±»å‹`: åˆ›å»ºä¸€ä¸ªæ–°å‰¯æœ¬ã€‚
  4. å°† <strong style="color:red;">å†…å­˜å˜é‡</strong> èµ‹å€¼ç»™ å†…å­˜å˜é‡ (åŒç±»å‹)
     - `å€¼ ç±» å‹`: åˆ›å»ºä¸€ä¸ªæ–°å‰¯æœ¬ã€‚
     - `å¼•ç”¨ç±»å‹`: ä¸ä¼šåˆ›å»ºå‰¯æœ¬ã€‚(**é‡è¦**)
- memory å’Œ calldata ä¹‹é—´çš„åŒºåˆ«
  - **å‡½æ•°è°ƒç”¨å‡½æ•°æ—¶çš„åŒºåˆ«**:`calldataå¯ä»¥éšå¼è½¬æ¢ä¸ºmemory`
  - calldata å¯ä»¥éšå¼è½¬æ¢ä¸º memory
  - memory ä¸å¯ä»¥éšå¼è½¬æ¢ä¸º calldata
  - ä½œä¸ºå‚æ•°ï¼š
    - memory å¯ä»¥ä¿®æ”¹å‚æ•°
    - calldata ç¦æ­¢ä¿®æ”¹å‚æ•°

**array**

- åˆ›å»ºæ•°ç»„çš„æ–¹æ³•æœ‰å“ªäº›ã€‚ï¼ˆå®šé•¿æ•°ç»„ï¼ŒåŠ¨æ€æ•°ç»„ï¼‰
  - å›ºå®šé•¿åº¦æ•°ç»„:åˆ›å»º
    ```
    uint256[5] public T1 = [1, 2, 3, 4, 5];
    address[5] public A =   [0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac];
    bytes1[5] public B = [bytes1(0x61)];
    ```
  - å¯å˜é•¿åº¦æ•°ç»„:åˆ›å»º
    - æ–¹å¼ 1: `uint256[] T1 = [1, 2, 3, 4, 5];`
      - è¯¥æ–¹å¼ä¸å¯ä»¥åœ¨å‡½æ•°å†…åˆ›å»º
    - æ–¹å¼ 2: `uint256[] T2 = new uint256[](5);`
      - ç”¨æ–¹å¼ 2 åˆ›å»ºæ•°ç»„æ—¶ï¼Œè‹¥æ•°ç»„ä¸ºæˆå‘˜å˜é‡, åˆ™é»˜è®¤ä¸º storage ç±»å‹ï¼›
      - è‹¥ä¸ºå±€éƒ¨å˜é‡é»˜è®¤ä¸º `memory` ç±»å‹ï¼Œ`memory` ç±»å‹çš„æ•°ç»„ï¼Œå¿…é¡»å£°æ˜é•¿åº¦ï¼Œå¹¶ä¸”é•¿åº¦åˆ›å»ºåä¸å¯å˜ã€‚
      - `push` æ–¹æ³•ä¸èƒ½ç”¨åœ¨ `memeory` çš„æ•°ç»„ä¸Š,åªèƒ½é€ä¸ªç´¢å¼•çš„èµ‹å€¼ã€‚
  - äºŒç»´æ•°ç»„:åˆ›å»º
    - ä¸¾ä¸ªä¾‹å­ï¼Œä¸€ä¸ªé•¿åº¦ä¸º `5`ï¼Œå…ƒç´ ç±»å‹ä¸º uint çš„åŠ¨æ€æ•°ç»„çš„æ•°ç»„ï¼ˆäºŒç»´æ•°ç»„ï¼‰ï¼Œåº”å£°æ˜ä¸º `uint[][5]` ï¼ˆæ³¨æ„è¿™é‡Œè·Ÿå…¶å®ƒè¯­è¨€æ¯”ï¼Œæ•°ç»„é•¿åº¦çš„å£°æ˜ä½ç½®æ˜¯åçš„ï¼‰ã€‚åœ¨ Solidity ä¸­ï¼Œ `X[3]` æ€»æ˜¯ä¸€ä¸ªåŒ…å«ä¸‰ä¸ª X ç±»å‹å…ƒç´ çš„æ•°ç»„ï¼Œå³ä½¿ X æœ¬èº«å°±æ˜¯ä¸€ä¸ªæ•°ç»„.
    - `uint256[2][3] public T = [[1, 2], [3, 4], [5, 6]];`
    - `T.length` ä¸º 3
  - å…¶å®ƒ
    - `uint256[2][] public T = new uint256[2][](10);`
- å†…å­˜ä¸­å¦‚ä½•åˆ›å»ºæ•°ç»„
  - å¯ä»¥ä½¿ç”¨ `new` å…³é”®å­—åœ¨å†…å­˜ä¸­åˆ›å»ºåŠ¨æ€æ•°ç»„ã€‚ä¸å­˜å‚¨æ•°ç»„ç›¸åï¼Œä¸èƒ½é€šè¿‡è®¾ç½® `.length` æˆå‘˜æ¥è°ƒæ•´å†…å­˜åŠ¨æ€æ•°ç»„çš„é•¿åº¦ã€‚ (**éœ€è¦ä¾‹å­æ¥æ¼”ç¤º**)ã€‚memory ç±»å‹çš„æ•°ç»„é•¿åº¦åˆ›å»ºåä¸å¯å˜ï¼Œä¸èƒ½é€šè¿‡ä¿®æ”¹æˆå‘˜å˜é‡ `.push` æ”¹å˜ memory æ•°ç»„çš„å¤§å°ã€‚å¿…é¡»æå‰è®¡ç®—æ•°ç»„å¤§å°ï¼Œæˆ–è€…åˆ›å»ºä¸€ä¸ªæ–°çš„å†…å­˜æ•°ç»„å¹¶å¤åˆ¶æ¯ä¸ªå…ƒç´ ã€‚
  - åˆ›å»ºæ ¼å¼: `uint256[] memory a = new uint256[](5);`
  - å†…å­˜ä¸­åˆ›å»ºçš„æ•°ç»„æ˜¯å±€éƒ¨å˜é‡ã€‚
  - å†…å­˜ä¸­ä¸èƒ½åˆ›å»ºåŠ¨æ€æ•°ç»„ï¼Œå¿…é¡»åˆ›å»ºå®šé•¿æ•°ç»„ã€‚
- ä¸‹é¢ä»£ç å¯ä»¥æ­£å¸¸è¿è¡Œä¹ˆï¼Ÿå¦‚æœå¯ä»¥ï¼Œå€¼åˆ†åˆ«æ˜¯ä»€ä¹ˆï¼Ÿ

  - ç›®å‰éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œ**å®šé•¿çš„ memory æ•°ç»„å¹¶ä¸èƒ½èµ‹å€¼ç»™å˜é•¿çš„ memory æ•°ç»„**ï¼Œä¸‹é¢çš„ä¾‹å­ f å‡½æ•°æ˜¯æ— æ³•è¿è¡Œçš„ï¼š
  - å¼•å‘äº†ä¸€ä¸ªç±»å‹é”™è¯¯ï¼Œå› ä¸º `unint[3] memory`ï¼Œä¸èƒ½è½¬æ¢æˆ `uint[] memory`ã€‚

  ```
  // SPDX-License-Identifier: MIT
  pragma solidity ^0.8.17;

  contract Demo {
      uint256[] public x = [1, 3, 4];
      uint256[] public y = [uint256(1), 3, 4];
      uint256[] public z = [uint8(1), 3, 4];

      function f() public pure returns(uint256[] memory x){
          x = [uint256(1), 3, 4];
      }
  }
  ```

- ä¸‹é¢ä»£ç å¯ä»¥æ­£å¸¸è¿è¡Œä¹ˆï¼Ÿ

  - ä¸å¯ä»¥ï¼Œéœ€è¦` s([uint256(1), uint256(2)])`

  ```
  contract T {
      function t() public {
          s([1, 2]);
      }

      function s(uint256[2] memory _arr) public {}
  }
  ```

- æœ‰å“ªäº›å¯ä»¥æ“ä½œæ•°ç»„çš„æ–¹æ³•ï¼Œåˆ†åˆ«åŠŸèƒ½æ˜¯ä»€ä¹ˆï¼Ÿ(`push` / `pop` / `delete`/`x[start:end]`)
  - push å¢åŠ ï¼Œæ”¹å˜é•¿åº¦
  - pop åˆ é™¤æœ€åä¸€ä½ï¼Œæ”¹å˜é•¿åº¦
  - delete: åˆ é™¤å¯¹åº”çš„ç´¢å¼•ï¼›åˆ é™¤å¹¶ä¸ä¼šæ”¹å˜é•¿åº¦ï¼Œç´¢å¼•ä½ç½®çš„å€¼ä¼šæ”¹ä¸ºé»˜è®¤å€¼ã€‚
  - `x[start:end]`: æ•°ç»„åˆ‡ç‰‡ï¼Œä»…å¯ä½¿ç”¨äº `calldata` æ•°ç»„.
- èƒ½å¦å®ç°ä¸€ä¸ªå®Œå…¨ delete æ•°ç»„çš„æ–¹æ³•ï¼ˆåˆ é™¤æ•°æ®ï¼Œé•¿åº¦æ”¹å˜ï¼‰ï¼Œè¯´ä¸‹å®ç°é€»è¾‘ä¹Ÿå¯ä»¥ã€‚

  ```
  // SPDX-License-Identifier: MIT
  pragma solidity ^0.8.17;

  contract FunctionOutputs {
      function deletePro(uint256[] memory arr, uint256 _index)
          internal
          pure
          returns (uint256[] memory temp)
      {
          require(_index < arr.length, "index out of bound");
          temp = new uint256[](arr.length - 1);
          for (uint256 index = 0; index <= temp.length - 1; index++) {
              if (index >= _index) {
                  temp[_index] = arr[_index + 1];
              } else {
                  temp[index] = arr[index];
              }
          }
      }

      function test()
          external
          pure
          returns (uint256[] memory arr, uint256[] memory temp)
      {
          arr = new uint256[](3);
          arr[0] = 1;
          arr[1] = 2;
          arr[2] = 3;
          assert(arr[0] == 1);
          assert(arr[1] == 2);
          assert(arr[2] == 3);
          assert(arr.length == 3);

          temp = deletePro(arr, 1);
          assert(temp[0] == 1);
          assert(temp[1] == 3);
          assert(temp.length == 2);
      }
  }
  ```

**bytes**

- bytes çš„åˆ›å»ºæ–¹æ³•æœ‰å“ªäº›ï¼Ÿ
  - çŠ¶æ€å˜é‡çš„åˆ›å»ºæ–¹å¼
    ```
    bytes public welcome = bytes("1.Welcome");
    ```
  - å‡½æ•°ä¸­å¯å˜å­—èŠ‚æ•°ç»„åˆ›å»ºæ–¹å¼ï¼š
    ```
    // å¯å˜å­—èŠ‚æ•°ç»„åˆ›å»ºæ–¹å¼
    bytes memory temp2 = new bytes(length);
    ```
- `bytes` `bytes32` ,å’Œ `bytes32[]` åŒºåˆ« æ˜¯ä»€ä¹ˆï¼Ÿ
  - `abcBytes` çš„å€¼æ˜¯: `0x616263`;
  - `abcArray` çš„å€¼æ˜¯ï¼š`[0x61..00,0x62..00,0x63..00]`
  ```
    bytes32[] public abcArray = [bytes1("a"), bytes1("b"), bytes1("c")];
    // 0x616263
    bytes public abcBytes = bytes("abc");
  ```
- ä¸‹é¢çš„å€¼åˆ†åˆ«æ˜¯ä»€ä¹ˆï¼Ÿ
  ```
  bytes32[] public abcArray = [bytes1("a"), bytes1("b"), bytes1("c")];
  bytes public abcBytes = bytes("abc");
  ```
- bytes çš„å€¼å¦‚ä½•ä¿®æ”¹ï¼Ÿï¼ˆ`bytesVar[7] = 'x'`ï¼‰
- æœ‰å“ªäº›æ–¹æ³•å¯ä»¥æ“ä½œ `bytes` ç±»å‹æ•°æ®ï¼Ÿåˆ†åˆ«æ˜¯ä»€ä¹ˆåŠŸèƒ½ï¼Ÿ
  - `concat`/ `push` / `x[start:end]` / `delete` / `bytes()`
- `bytes` å’Œ `string` ä¹‹é—´å¦‚ä½•è½¬æ¢ï¼Ÿ
  - å¯ä»¥ä½¿ç”¨ `bytes()` æ„é€ å‡½æ•°å°†å­—ç¬¦ä¸²è½¬æ¢ä¸º `bytes`ã€‚
  - å¯ä»¥ä½¿ç”¨ string() æ„é€ å‡½æ•°å°† bytes è½¬æ¢ä¸ºå­—ç¬¦ä¸²ã€‚
- å¦‚ä½•æ¯”è¾ƒä¸¤ä¸ª bytes æ•°æ®æ˜¯å¦ç›¸åŒï¼Ÿ
  - `keccak256(welcome2) == keccak256(welcome1);`

**string**

- å¦‚ä½•ä¿®æ”¹ string ç±»å‹çš„å­—ç¬¦ä¸²ï¼Ÿ
  - è·å–å­—ç¬¦ä¸²çš„é•¿åº¦
    - `bytes(str).length`:ä»¥å­—èŠ‚é•¿åº¦è¡¨ç¤ºå­—ç¬¦ä¸²çš„é•¿åº¦
  - æŸä¸ªå­—ç¬¦ä¸²ç´¢å¼•çš„å­—èŠ‚ç 
    - `bytes1 temp1 = bytes(str)[_index];`
      ```
      function getIndexValue(uint256 _index) public view return(string memory) {
          bytes1 temp1 = bytes(welcome)[_index]; // è¿”å›å›ºå®šé•¿åº¦çš„ bytes1
          bytes memory temp2 = new bytes(1); // å¯å˜å­—èŠ‚æ•°ç»„åˆ›å»ºæ–¹å¼
          temp2[0] = temp1;
          return string(temp2);
      }
      ```
  - ä¿®æ”¹å­—ç¬¦ä¸²
    - `bytes(s)[7] = 'x'`
- å¦‚ä½•æ¯”è¾ƒä¸¤ä¸ª string ç±»å‹çš„å­—ç¬¦ä¸²æ˜¯å¦ç›¸ç­‰ï¼Ÿ
  - `keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))`
  - `keccak256(bytes(s1)) == keccak256(bytes(s2))` : æ›´æ¨èè¿™ä¸ªï¼Œçœ gas

**mapping**

- mapping ä½¿ç”¨çš„æ—¶å€™æœ‰å“ªäº›éœ€è¦æ³¨æ„çš„ï¼Ÿ
  - `_KeyType`ï¼šå¯ä»¥æ˜¯ä»»ä½•å†…ç½®ç±»å‹ï¼Œæˆ–è€… bytes å’Œ å­—ç¬¦ä¸²ã€‚
    - ä¸å…è®¸ä½¿ç”¨å¼•ç”¨ç±»å‹æˆ–å¤æ‚å¯¹è±¡
    - é”®æ˜¯å”¯ä¸€çš„ï¼Œå…¶èµ‹å€¼æ–¹å¼ä¸ºï¼š`map[a]=test`; æ„æ€æ˜¯é”®ä¸º a,å€¼ä¸º testï¼›ã€‚
  - `_ValueType`ï¼š å¯ä»¥æ˜¯ä»»ä½•ç±»å‹ã€‚
  - mapping æ”¯æŒåµŒå¥—ã€‚
  - æ˜ å°„çš„æ•°æ®ä½ç½®(data location)åªèƒ½æ˜¯ `storage`ï¼Œé€šå¸¸ç”¨äºçŠ¶æ€å˜é‡ã€‚
  - `mapping` ä¸èƒ½ç”¨äº `public` å‡½æ•°çš„å‚æ•°æˆ–è¿”å›ç»“æœ
    - æ˜ å°„åªèƒ½æ˜¯ å­˜å‚¨ storage çš„æ•°æ®ä½ç½®ï¼Œå› æ­¤åªå…è®¸ä½œä¸ºçŠ¶æ€å˜é‡ æˆ– ä½œä¸ºå‡½æ•°å†…çš„ å­˜å‚¨ storage å¼•ç”¨ æˆ– ä½œä¸ºåº“å‡½æ•°çš„å‚æ•°ã€‚ å®ƒä»¬ä¸èƒ½ç”¨åˆçº¦å…¬æœ‰å‡½æ•°çš„å‚æ•°æˆ–è¿”å›å€¼ã€‚
    - è¿™äº›é™åˆ¶åŒæ ·é€‚ç”¨äºåŒ…å«æ˜ å°„çš„æ•°ç»„å’Œç»“æ„ä½“ã€‚
  - æ˜ å°„å¯ä»¥æ ‡è®°ä¸º `public`ï¼ŒSolidity è‡ªåŠ¨ä¸ºå®ƒåˆ›å»º getter å‡½æ•°ã€‚
    - `_KeyType` å°†æˆä¸º `getter` çš„å¿…é¡»å‚æ•°ï¼Œå¹¶ä¸” getter ä¼šè¿”å› `_ValueType`ã€‚
    - å¦‚æœ `ValueType` æ˜¯ä¸€ä¸ªæ˜ å°„ã€‚è¿™æ—¶åœ¨ä½¿ç”¨ `getter` æ—¶å°†éœ€è¦é€’å½’åœ°ä¼ å…¥æ¯ä¸ª `KeyType` å‚æ•°ï¼Œ
  - æ˜ å°„ä¸å“ˆå¸Œè¡¨ä¸åŒçš„åœ°æ–¹ï¼š**åœ¨æ˜ å°„ä¸­,å¹¶ä¸å­˜å‚¨ keyï¼Œè€Œæ˜¯å­˜å‚¨å®ƒçš„ `keccak256` å“ˆå¸Œå€¼ï¼Œä»è€Œä¾¿äºæŸ¥è¯¢å®é™…çš„å€¼**ã€‚æ­£å› ä¸ºå¦‚æ­¤ï¼Œæ˜ å°„æ˜¯æ²¡æœ‰é•¿åº¦çš„ï¼Œä¹Ÿæ²¡æœ‰ `key çš„é›†åˆ`æˆ– `value çš„é›†åˆ`çš„æ¦‚å¿µã€‚æ˜ å°„åªèƒ½æ˜¯å­˜å‚¨çš„æ•°æ®ä½ç½®ï¼Œå› æ­¤åªå…è®¸ä½œä¸ºçŠ¶æ€å˜é‡æˆ–ä½œä¸ºå‡½æ•°å†…çš„å­˜å‚¨å¼•ç”¨ æˆ– ä½œä¸ºåº“å‡½æ•°çš„å‚æ•°ã€‚
- mapping å¦‚ä½•è·å–-è®¾ç½®-åˆ é™¤ï¼Ÿ
  - `balances[msg.sender];`
  - `balances[msg.sender] += amount;`
  - `delete balances[msg.sender];`
- mapping æ€ä¹ˆåšå±€éƒ¨å˜é‡ï¼Ÿ

  - `mapping` ç±»å‹å¯ä»¥ç”¨åšå±€éƒ¨å˜é‡ï¼Œä½†åªèƒ½å¼•ç”¨çŠ¶æ€å˜é‡ï¼Œè€Œä¸”å­˜å‚¨ä½ç½®ä¸º storageã€‚

  ```
  contract Mapping {
    mapping(address => uint256) public balances;

    function updateBalance() public returns (uint256) {
        // mapping å±€éƒ¨å˜é‡ ref å¼•ç”¨çŠ¶æ€å˜é‡ balances
        mapping(address => uint256) storage ref = balances;
        ref[msg.sender] = 3;
        return ref[msg.sender];
    }
  }
  ```

- å¦‚ä½•å®ç°ä¸€ä¸ªå¯è¿­ä»£çš„ mappingï¼Ÿ

  - ï¼ˆMapping+arrayï¼‰

  ```
  contract Mapping {
    mapping(address => uint256) public balances;
    mapping(address => bool) public balancesInserted;
    address[] public balancesKey;

    function set(address _ads, uint256 amount) external {
        balances[_ads] = amount;
        if (!balancesInserted[_ads]) {
            balancesInserted[_ads] = true;
            balancesKey.push(_ads);
        }
    }

    function totalAddress() external view returns (uint256) {
        return balancesKey.length;
    }

    function first() external view returns (uint256) {
        return balances[balancesKey[0]];
    }

    function latest() external view returns (uint256) {
        return balances[balancesKey[balancesKey.length - 1]];
    }

    function get(uint256 i) external view returns (uint256) {
        require(i < balancesKey.length, "length error");
        return balances[balancesKey[i]];
    }
  }
  ```

**struct**

- struct ä½¿ç”¨çš„æ—¶å€™æœ‰å“ªäº›éœ€è¦æ³¨æ„çš„ï¼Ÿ
- struct çš„åˆ›å»ºæ–¹æ³•æœ‰å“ªäº›ï¼Ÿ(3 ç§)

  ```
  // ç¬¬ 1 ç§ç”Ÿæˆ
  Book memory solidity = Book("Solidity", "LiSi", ++bookId, false, 0);

  // ç¬¬ 2 ç§ç”Ÿæˆ
  Book memory rust = Book({
      title: "Solidity",
      author: "LiSi",
      book_id: ++bookId,
      is_lost: false,
      uv: 0
  });

  // ç¬¬ 3 ç§ç”Ÿæˆ
  Book memory temp;
  temp.title = "Solidity";
  temp.author = "LiSi";
  temp.book_id = ++bookId;
  ```

- struct å¦‚ä½•è·å–-è®¾ç½®-åˆ é™¤ï¼Ÿ
  1. å‡½æ•°å†…ä»…è¯»å–ç»“æ„ä½“ï¼Œå˜é‡ä½¿ç”¨ memory: `Book memory _book = bookcase[_index];`
     1. å‡½æ•°å†…è¯»å–å¹¶è¿”å›,å¦‚æœä½¿ç”¨ memory å˜é‡æ¥æ”¶:ä»çŠ¶æ€å˜é‡æ‹·è´åˆ°å†…å­˜ä¸­ï¼Œç„¶åå†…å­˜ä¸­çš„å˜é‡æ‹·è´åˆ°è¿”å›å€¼ã€‚ä¸¤æ¬¡æ‹·è´ï¼Œæ¶ˆè€— gas å¤š
        1. `Todo memory temp = list[_index];`
     2. å‡½æ•°å†…è¯»å–å¹¶è¿”å›,å¦‚æœä½¿ç”¨ storage å˜é‡æ¥æ”¶:ç›´æ¥ä»çŠ¶æ€å˜é‡è¯»å–ï¼ŒçŠ¶æ€å˜é‡æ‹·è´åˆ°è¿”å›å€¼ã€‚1 æ¬¡æ‹·è´ï¼Œæ¶ˆè€— gas å°
     3. æ€»ç»“: è¯»å–æ—¶å€™æ¨èä½¿ç”¨ `storage`
  2. å‡½æ•°å†…è·å–å¹¶ä¿®æ”¹ç»“æ„ä½“ï¼Œå˜é‡ä½¿ç”¨ storage
     ```
     Book storage _book = bookcase[_index]; // å› ä¸ºè¦ä¿®æ”¹çŠ¶æ€å˜é‡ï¼Œæ‰€ä»¥ä½¿ç”¨ storage
     _book.author = "Anbang";
     ```
     - å‡½æ•°å†…ç›´æ¥ä¿®æ”¹å˜é‡;åœ¨ä¿®æ”¹ä¸€ä¸ªå±æ€§æ—¶æ¯”è¾ƒçœ Gas è´¹ç”¨
     - å‡½æ•°å†…å…ˆè·å–å­˜å‚¨åˆ° storage å†ä¿®æ”¹:ä¿®æ”¹å¤šä¸ªå±æ€§çš„æ—¶å€™æ¯”è¾ƒçœ Gas è´¹ç”¨
  3. åˆ é™¤ç»“æ„ä½“çš„å˜é‡ï¼Œä»…ä»…æ˜¯é‡ç½®æ•°æ®ï¼Œå¹¶ä¸æ˜¯å®Œå…¨çš„åˆ é™¤ã€‚
- å‡½æ•°å†…ä½¿ç”¨ structï¼Œæ ‡è®° `memory` / `storage` æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ
  - å‡½æ•°å†…è¯»å–æ—¶ï¼Œæ ‡è®° `memory` / `storage`,ä¼šäº§ç”Ÿå®Œå…¨ä¸åŒçš„ç»“æœï¼›
  - ç‰¹åˆ«æ³¨æ„ï¼š**å¦‚æœç»“æ„ä½“å†…åŒ…å« `mapping` ç±»å‹ï¼Œåˆ™å¿…é¡»ä½¿ç”¨ `storage`ï¼Œä¸å¯ä»¥ä½¿ç”¨ memeory.**ï¼Œ
- èŠä¸€ä¸‹ä¼—ç­¹åˆçº¦çš„å®ç°é€»è¾‘

**ç±»å‹è½¬æ¢**

- éšå¼è½¬æ¢çš„æ–¹å¼æœ‰å“ªäº›ï¼Ÿ
  - éšå¼è½¬æ¢çš„åœºæ™¯: åœ¨èµ‹å€¼, å‚æ•°ä¼ é€’ç»™å‡½æ•°ä»¥åŠåº”ç”¨è¿ç®—ç¬¦æ—¶ã€‚
  - éšå¼è½¬æ¢çš„åœºæ™¯:
    - å¯ä»¥è¿›è¡Œå€¼ç±»å‹ä¹‹é—´çš„éšå¼è½¬æ¢
    - ä¸ä¼šä¸¢å¤±ä»»ä½•ä¿¡æ¯
  - ä¾‹å¦‚ï¼Œ`uint8` å¯ä»¥è½¬æ¢ä¸º `uint16`/`uint24`../`uint256`ï¼Œå› ä¸º`uint8`æ˜¯`uint16`è¿™äº›ç±»å‹çš„å­é›†ã€‚ä½†æ˜¯ `int8` ä¸å¯ä»¥è½¬æ¢ä¸º `uint256`ï¼Œå› ä¸º `int8` å¯ä»¥åŒ…å« `uint256` ä¸­ä¸å…è®¸çš„è´Ÿå€¼ï¼Œæ¯”å¦‚ `-1`ã€‚
- æ˜¾ç¤ºè½¬æ¢æœ‰å“ªäº›éœ€è¦æ³¨æ„çš„ï¼Ÿ
  - `uint8` - `uint256` ä¹‹é—´è½¬æ¢çš„åŸç†
  - `bytes1` - `bytes32` ä¹‹é—´è½¬æ¢çš„åŸç†
  - æ•´å‹åŠ å¤§æ•°æ®ä½ç½®æ˜¯ä»å·¦ä¾§å¢åŠ ï¼Œå‡å°æ•°æ®ä½ç½®ä¹Ÿæ˜¯ä»å·¦ä¾§ç§»é™¤ï¼›ï¼ˆæ•´å‹æ˜¯å³å¯¹é½ï¼‰
  - å­—èŠ‚åŠ å¤§æ•°æ®ä½ç½®æ˜¯ä»å³ä¾§å¢åŠ ï¼Œå‡å°æ•°æ®ä½ç½®ä¹Ÿæ˜¯ä»å³ä¾§ç§»é™¤ï¼›ï¼ˆå­—èŠ‚æ˜¯å·¦å¯¹é½ï¼‰
- èŠä¸€èŠ int/uint ç±»å‹ä¹‹é—´çš„è½¬æ¢
  - å› ä¸ºæ•´å‹åŠ å¤§æ•°æ®ä½ç½®æ˜¯ä»å·¦ä¾§å¢åŠ ï¼Œå‡å°æ•°æ®ä½ç½®ä¹Ÿæ˜¯ä»å·¦ä¾§ç§»é™¤ï¼›ï¼ˆ**æ•´å‹æ˜¯å³å¯¹é½**ï¼‰
  - æ•´å‹è½¬æ¢æˆæ›´å¤§çš„ç±»å‹ï¼Œä»å·¦ä¾§æ·»åŠ å¡«å……ä½ã€‚
  - æ•´å‹è½¬æ¢æˆæ›´å°çš„ç±»å‹ï¼Œä¼šä¸¢å¤±å·¦ä¾§æ•°æ®ã€‚
- èŠä¸€èŠ bytes å­—èŠ‚ç±»å‹ä¹‹é—´çš„è½¬æ¢
  - å› ä¸ºå­—èŠ‚åŠ å¤§æ•°æ®ä½ç½®æ˜¯ä»å³ä¾§å¢åŠ ï¼Œå‡å°æ•°æ®ä½ç½®ä¹Ÿæ˜¯ä»å³ä¾§ç§»é™¤ï¼›ï¼ˆ**å­—èŠ‚æ˜¯å·¦å¯¹é½**ï¼‰
  - å­—èŠ‚è½¬æ¢ä¸ºæ›´å¤§çš„ç±»å‹æ—¶ï¼Œä»å³ä¾§æ·»åŠ å¡«å……ä½ã€‚
  - å­—èŠ‚è½¬æ¢åˆ°æ›´å°çš„ç±»å‹æ—¶ï¼Œä¸¢å¤±å³ä¾§æ•°æ®ã€‚
- `bytes` ä¸ `uint` è½¬æ¢
  - bytes è½¬æ¢æˆ uint: å…ˆè½¬ç±»å‹ï¼Œå†è½¬å¤§å°
  - uint è½¬æ¢æˆ bytes: å…ˆè½¬å¤§å°ï¼Œå†è½¬ç±»å‹
- `bytes` ä¸ `address` è½¬æ¢
  - address çš„æ ¼å¼æ˜¯ `0xffD0d80c48F6C3C5387b7cfA7AA03970bdB926ac`ï¼Œæ˜¯ä¸€ä¸ª **bytes20** çš„æ•°æ®.
  - è€Œç”±å­—ç¬¦ä¸²ç”Ÿæˆ bytes çš„æ–¹å¼æ˜¯ `keccak256(abi.encodePacked())`ï¼Œè¿”å›çš„æ˜¯ `bytes32` ç±»å‹ã€‚åœ°å€æ˜¯å– `bytes32` æ•°æ®ä¸­çš„å 20 ä½ã€‚å¦‚æœåˆ é™¤å‰é¢çš„ 12 ä½æ•°æ®ï¼Œå¯ä»¥ä½¿ç”¨ solidity assembly (å†…è”æ±‡ç¼–) æ¥æˆªå–ï¼Œä¹Ÿå¯ä»¥å€ŸåŠ© `uint` è½¬æ¢æˆæ›´å°çš„ç±»å‹ï¼Œä¼šä¸¢å¤±å·¦ä¾§æ•°æ®çš„ç‰¹æ€§æ¥å®Œæˆã€‚
- `uint` ä¸ `address` è½¬æ¢
- `bytes` ä¸ `bytes32` ä¹‹é—´çš„è½¬æ¢
  - åˆ›å»ºé•¿åº¦ï¼Œfor å¾ªç¯

**å­—é¢å¸¸é‡ä¸åŸºæœ¬ç±»å‹çš„è½¬æ¢**

- åè¿›åˆ¶å’Œåå…­è¿›åˆ¶å­—é¢å¸¸é‡ä¹‹é—´çš„è½¬æ¢éœ€è¦æ³¨æ„ä»€ä¹ˆé—®é¢˜ï¼Ÿ
  - åªæœ‰åœ¨åŒ¹é…æ•°æ®èŒƒå›´æ—¶ï¼Œæ‰èƒ½è¿›è¡Œéšå½¢è½¬æ¢ï¼Œå¦‚æœè¶…å‡ºï¼Œä¸ä¼šæˆªæ–­ï¼Œè€Œæ˜¯æŠ¥é”™ã€‚
