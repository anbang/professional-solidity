# 12.åˆçº¦éƒ¨ç½²åˆçº¦

## 1ï¸âƒ£ é€šè¿‡ `new` åˆ›å»ºåˆçº¦ / `create`

ä½¿ç”¨å…³é”®å­— `new` å¯ä»¥åˆ›å»ºä¸€ä¸ªæ–°åˆçº¦ã€‚å¾…åˆ›å»ºåˆçº¦çš„å®Œæ•´ä»£ç å¿…é¡»äº‹å…ˆçŸ¥é“ï¼Œå› æ­¤é€’å½’çš„åˆ›å»ºä¾èµ–æ˜¯ä¸å¯èƒ½çš„ã€‚`create`ä¸»è¦æœ‰ä»¥ä¸‹ä¸‰ç§è¡¨ç°å½¢å¼ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract D {
    uint x;
    function D(uint a) payable {
        x = a;
    }
}

contract C {
    // 1.å°†ä½œä¸ºåˆçº¦çš„ä¸€éƒ¨åˆ†æ‰§è¡Œ
    D d = new D(4);

    // 2.æ–¹æ³•å†…åˆ›å»º
    function createD1(uint arg) public {
        D newD = new D(arg);
    }

    // 3.æ–¹æ³•å†…åˆ›å»ºï¼Œå¹¶è½¬è´¦
    function createD2(uint arg, uint amount) public payable {
        //éšåˆçº¦çš„åˆ›å»ºå‘é€ ether
        D newD = (new D){value:amount}(arg);
    }
}
```

å¦‚ç¤ºä¾‹ä¸­æ‰€ç¤ºï¼Œé€šè¿‡ä½¿ç”¨ `value` é€‰é¡¹åˆ›å»º `D` çš„å®ä¾‹æ—¶å¯ä»¥é™„å¸¦å‘é€ Etherï¼Œä½†æ˜¯ä¸èƒ½é™åˆ¶ gas çš„æ•°é‡ã€‚ å¦‚æœåˆ›å»ºå¤±è´¥ï¼ˆå¯èƒ½å› ä¸ºæ ˆæº¢å‡ºï¼Œæˆ–æ²¡æœ‰è¶³å¤Ÿçš„ä½™é¢æˆ–å…¶ä»–é—®é¢˜ï¼‰ï¼Œä¼šå¼•å‘å¼‚å¸¸ã€‚

è¿™ç§æ–¹å¼ä¹Ÿè¢«ç§°ä¸º Factory åˆ›å»ºã€‚å·¥å‚åˆçº¦éƒ¨ç½²ï¼Œä¹Ÿè¢«ç§°ä¸º `create`ï¼Œæ‰¹é‡åˆ›å»ºçš„æ—¶å€™ä½¿ç”¨ï¼Œæ¯”å¦‚æ‰¹é‡åˆ›å»ºäº¤æ˜“æ± ï¼ŒDeFi ç±»äº§å“ä¸­æ‰¹é‡åˆ›å»ºå€Ÿè´·æ± ç­‰ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Account {
    address public deployer;
    address public owner;

    constructor(address _owner) payable {
        owner = _owner;
        deployer = msg.sender;
    }

    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}

contract AccountFactory {
    Account[] public accounts;

    function deploy(address _owner) external payable {
        Account account = new Account{value: msg.value}(_owner);
        accounts.push(account);
    }
}
```

## 2ï¸âƒ£ é€šè¿‡ `salt` åˆ›å»ºåˆçº¦ / `create2`


åœ¨åˆ›å»ºåˆçº¦æ—¶ï¼Œå°†æ ¹æ®åˆ›å»ºåˆçº¦çš„åœ°å€å’Œæ¯æ¬¡åˆ›å»ºåˆçº¦äº¤æ˜“æ—¶çš„ `nonce` æ¥è®¡ç®—åˆçº¦çš„åœ°å€ã€‚å¦‚æœä½ æŒ‡å®šäº†ä¸€ä¸ªå¯é€‰çš„ `salt` ï¼ˆä¸€ä¸ª bytes32 å€¼ï¼‰ï¼Œé‚£ä¹ˆåˆçº¦åˆ›å»ºå°†ä½¿ç”¨å¦ä¸€ç§æœºåˆ¶(`create2`)æ¥ç”Ÿæˆæ–°åˆçº¦çš„åœ°å€ï¼šå®ƒå°†æ ¹æ®ç»™å®šçš„ `salt` ï¼Œåˆ›å»ºåˆçº¦çš„å­—èŠ‚ç å’Œæ„é€ å‡½æ•°å‚æ•°æ¥è®¡ç®—åˆ›å»ºåˆçº¦çš„åœ°å€ã€‚ç‰¹åˆ«æ³¨æ„ï¼Œè¿™é‡Œä¸å†ä½¿ç”¨ `nonce`ã€‚

create2 çš„æ„ä¹‰ï¼šå¯ä»¥åœ¨åˆ›å»ºåˆçº¦æ—¶æä¾›æ›´å¤§çš„çµæ´»æ€§ï¼šä½ å¯ä»¥åœ¨åˆ›å»ºæ–°åˆçº¦ä¹‹å‰å°±æ¨å¯¼å‡ºå°†è¦åˆ›å»ºçš„åˆçº¦åœ°å€ã€‚ ç”šè‡³æ˜¯è¿˜å¯ä»¥ä¾èµ–æ­¤åœ°å€ï¼ˆå³ä¾¿å®ƒè¿˜ä¸å­˜åœ¨ï¼‰æ¥åˆ›å»ºå…¶ä»–åˆçº¦ã€‚ä¸€ä¸ªä¸»è¦ç”¨ä¾‹åœºæ™¯æ˜¯**å……å½“é“¾ä¸‹äº¤äº’ä»²è£åˆçº¦ï¼Œä»…åœ¨æœ‰äº‰è®®æ—¶æ‰éœ€è¦åˆ›å»ºã€‚**

### æ¡ˆä¾‹æ¼”ç¤º1

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract D {
    uint public x;
    constructor(uint a) {
        x = a;
    }
}

contract C {
    function createDSalted(bytes32 salt, uint arg) public {
        /// è¿™ä¸ªå¤æ‚çš„è¡¨è¾¾å¼åªæ˜¯å‘Šè¯‰æˆ‘ä»¬ï¼Œå¦‚ä½•é¢„å…ˆè®¡ç®—åœ°å€ã€‚
        /// è¿™é‡Œä»…ä»…ç”¨æ¥è¯´æ˜ã€‚
        /// å®é™…ä¸Šï¼Œä½ ä»…ä»…éœ€è¦ ``new D{salt: salt}(arg)``.
        address predictedAddress = address(uint160(uint(keccak256(abi.encodePacked(
            bytes1(0xff),
            address(this),
            salt,
            keccak256(abi.encodePacked(
                type(D).creationCode,
                arg
            ))
        )))));

        D d = new D{salt: salt}(arg);
        require(address(d) == predictedAddress);
    }
}
```

ä½¿ç”¨ `create2` åˆ›å»ºåˆçº¦è¿˜æœ‰ä¸€äº›ç‰¹åˆ«ä¹‹å¤„ã€‚ åˆçº¦é”€æ¯åå¯ä»¥åœ¨åŒä¸€åœ°å€é‡æ–°åˆ›å»ºã€‚ä¸è¿‡ï¼Œå³ä½¿åˆ›å»ºå­—èŠ‚ç ï¼ˆcreation bytecodeï¼‰ç›¸åŒï¼ˆè¿™æ˜¯è¦æ±‚ï¼Œå› ä¸ºå¦åˆ™åœ°å€ä¼šå‘ç”Ÿå˜åŒ–ï¼‰ï¼Œè¯¥æ–°åˆ›å»ºçš„åˆçº¦ä¹Ÿå¯èƒ½æœ‰ä¸åŒçš„éƒ¨ç½²å­—èŠ‚ç ï¼ˆdeployed bytecodeï¼‰ã€‚ è¿™æ˜¯å› ä¸ºæ„é€ å‡½æ•°å¯ä»¥ä½¿ç”¨ä¸¤æ¬¡åˆ›å»ºåˆçº¦ä¹‹é—´å¯èƒ½å·²æ›´æ”¹çš„å¤–éƒ¨çŠ¶æ€ï¼Œå¹¶åœ¨å­˜å‚¨åˆçº¦æ—¶å°†å…¶åˆå¹¶åˆ°éƒ¨ç½²å­—èŠ‚ç ä¸­ã€‚

### å°ç»“

è¿™ç§ä¹Ÿè¢«ç§°ä¸ºæ“ä½œç éƒ¨ç½²ï¼Œ`create` å¯ä»¥é€šè¿‡åŠ å…¥ saltï¼Œæ¥é¢„æµ‹å³å°†ç”Ÿæˆçš„åœ°å€ã€‚è¿™ç§åˆ›å»ºå°±èƒ½é¢„æµ‹ç”Ÿæˆåœ°å€çš„æ–¹å¼ä¹Ÿè¢«ç§°ä¸º `create2` åˆ›å»ºã€‚

- åŠ  salt ,salt å†³å®šäº†åˆçº¦åœ°å€ï¼Œä¸èƒ½é‡å¤ä½¿ç”¨
  - é™¤éä¹‹å‰ salt ç”Ÿæˆçš„åˆçº¦è¢«é”€æ¯äº†ã€‚
- å³å°†éƒ¨ç½²çš„åˆçº¦åœ°å€è®¡ç®—
  - `uint160` æ ¼å¼å°±æ˜¯åœ°å€æ ¼å¼äº†

ä¸‹é¢æ˜¯ä¸¤è€…çš„ç®€çŸ­æ€»ç»“ï¼š

- **æ™®é€šåˆçº¦**çš„åœ°å€ç”Ÿæˆæ–¹å¼: éƒ¨ç½²è€…çš„`åœ°å€` + `åœ°å€ nonce`
- **é¢„æµ‹åˆçº¦åœ°å€çš„æ–¹å¼**:

```
bytes32 hash = keccak256(
    abi.encodePacked(
        bytes1(0xff), // å›ºå®šå­—ç¬¦ä¸²
        address(this), // å½“å‰å·¥å‚åˆçº¦åœ°å€ï¼Œå›ºå®šå†™æ³•
        _salt, // salt
        keccak256(bytecode) //éƒ¨ç½²åˆçº¦çš„ bytecode
    )
);
return address(uint160(uint256(hash)));
```

### æ¡ˆä¾‹ä»£ç 2

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract DeployWithCreate2 {
    address public deployer;
    address public owner;

    constructor(address _owner) payable {
        owner = _owner;
        deployer = msg.sender;
    }

    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}

contract AccountFactory {
    DeployWithCreate2[] public accounts;

    function deploy(uint256 _salt) external payable {
        DeployWithCreate2 account = new DeployWithCreate2{
            salt: bytes32(_salt), // uint256 éœ€è¦è½¬ä¸º bytes32
            value: msg.value
        }(msg.sender);
        accounts.push(account);
    }

    // è·å–å³å°†éƒ¨ç½²çš„åœ°å€
    function getAddress(bytes memory bytecode, uint256 _salt)
        external
        view
        returns (address)
    {
        bytes32 hash = keccak256(
            abi.encodePacked(
                bytes1(0xff), // å›ºå®šå­—ç¬¦ä¸²
                address(this), // å½“å‰å·¥å‚åˆçº¦åœ°å€
                _salt, // salt
                keccak256(bytecode) //éƒ¨ç½²åˆçº¦çš„ bytecode
            )
        );
        return address(uint160(uint256(hash)));
    }

    // è·å–åˆçº¦çš„ bytecode
    function getBytecode(address _owner) external pure returns (bytes memory) {
        bytes memory bytecode = type(DeployWithCreate2).creationCode;
        // è¿æ¥çš„å‚æ•°ä½¿ç”¨ abi.encode
        return abi.encodePacked(bytecode, abi.encode(_owner));
    }
}
```

### åˆçº¦æµ‹è¯•

- `address1` éƒ¨ç½²åˆçº¦
  - address1: `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4`
- ä½¿ç”¨ `address1` ä½œä¸ºå‚æ•°ï¼Œè·å– `getBytecode` è¿”å›å€¼ã€‚
- è°ƒç”¨ getAddress
  - bytecode å‚æ•°æ˜¯ `getBytecode` è¿”å›å€¼
  - salt å‚æ•°æ˜¯ 1
  - è®¡ç®—ç»“æœæ˜¯: `0x0022172A008CEdf60B1770dDD987888e5663D1Cc`
- è°ƒç”¨ deployï¼Œsalt å‚æ•°æ˜¯ 1
- è°ƒç”¨ accounts[0]
  - è¿”å›çš„åˆçº¦åœ°å€æ˜¯ `0x0022172A008CEdf60B1770dDD987888e5663D1Cc`ï¼Œå’Œè®¡ç®—çš„å®Œå…¨ä¸€æ ·ã€‚
- å†æ¬¡è°ƒç”¨ deployï¼Œsalt å‚æ•°æ˜¯ 1
  - è¿”å›å¤±è´¥ `transact to AccountFactory.deploy errored: VM error: revert.`
 

## 3ï¸âƒ£ åˆ›å»ºåˆçº¦çš„æ‰©å±•

å¯ä»¥é€šè¿‡ä»¥å¤ªåŠäº¤æ˜“**ä»å¤–éƒ¨**æˆ–ä» Solidity åˆçº¦å†…éƒ¨åˆ›å»ºåˆçº¦ã€‚

ä¸€äº›é›†æˆå¼€å‘ç¯å¢ƒï¼Œä¾‹å¦‚ Remix, é€šè¿‡ä½¿ç”¨ä¸€äº› UI ç”¨æˆ·ç•Œé¢ä½¿åˆ›å»ºåˆçº¦çš„è¿‡ç¨‹æ›´åŠ é¡ºç•…ã€‚ åœ¨ä»¥å¤ªåŠä¸Šé€šè¿‡ç¼–ç¨‹åˆ›å»ºåˆçº¦æœ€å¥½ä½¿ç”¨ JavaScript API web3.jsã€‚ ç°åœ¨ï¼Œæˆ‘ä»¬å·²ç»æœ‰äº†ä¸€ä¸ªå«åš `web3.eth.Contract` çš„æ–¹æ³•èƒ½å¤Ÿæ›´å®¹æ˜“çš„åˆ›å»ºåˆçº¦ã€‚

åˆ›å»ºåˆçº¦æ—¶ï¼Œ åˆçº¦çš„æ„é€ å‡½æ•° (ä¸€ä¸ªç”¨å…³é”®å­— constructor å£°æ˜çš„å‡½æ•°)ä¼šæ‰§è¡Œä¸€æ¬¡ã€‚ æ„é€ å‡½æ•°æ˜¯å¯é€‰çš„ã€‚åªå…è®¸æœ‰ä¸€ä¸ªæ„é€ å‡½æ•°ï¼Œè¿™æ„å‘³ç€ä¸æ”¯æŒé‡è½½ã€‚æ„é€ å‡½æ•°æ‰§è¡Œå®Œæ¯•åï¼Œåˆçº¦çš„æœ€ç»ˆä»£ç å°†éƒ¨ç½²åˆ°åŒºå—é“¾ä¸Šã€‚æ­¤ä»£ç åŒ…æ‹¬æ‰€æœ‰å…¬å…±å’Œå¤–éƒ¨å‡½æ•°ä»¥åŠæ‰€æœ‰å¯ä»¥é€šè¿‡å‡½æ•°è°ƒç”¨è®¿é—®çš„å‡½æ•°ã€‚ éƒ¨ç½²çš„ä»£ç æ²¡æœ‰ åŒ…æ‹¬æ„é€ å‡½æ•°ä»£ç æˆ–æ„é€ å‡½æ•°è°ƒç”¨çš„å†…éƒ¨å‡½æ•°ã€‚

åœ¨å†…éƒ¨ï¼Œæ„é€ å‡½æ•°å‚æ•°åœ¨åˆçº¦ä»£ç ä¹‹åé€šè¿‡ ABI ç¼–ç  ä¼ é€’ï¼Œä½†æ˜¯å¦‚æœä½ ä½¿ç”¨ web3.js åˆ™ä¸å¿…å…³å¿ƒè¿™ä¸ªé—®é¢˜ã€‚

## ğŸ†— å®æˆ˜åº”ç”¨ï¼šä½¿ç”¨ assembly åš create

### create éƒ¨ç½²

- Proxy: éƒ¨ç½²åˆçº¦çš„æ–¹æ³•ï¼Œå’Œä¿®æ”¹ owner
- Helper: ç”Ÿæˆéƒ¨ç½²ç”¨çš„ bytecode å’Œä¿®æ”¹ owner çš„ data

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Test1 {
    address public owner = msg.sender;

    function setOwner(address _owner) public {
        require(msg.sender == owner, "now owner");
        owner = _owner;
    }
}

contract Test2 {
    address public owner = msg.sender;
    uint256 public value = msg.value;
    uint256 public x;
    uint256 public y;

    constructor(uint256 _x, uint256 _y) {
        x = _x;
        y = _y;
    }
}

// contract Proxy {
//     function depolyTest1() external {
//         new Test1();
//     }

//     function depolyTest2() external payable {
//         new Test2(1, 2);
//     }
// }

// assembly éƒ¨ç½²
contract Proxy {
    event Depoly(address);

    // fallback() external payable {}

    function depoly(bytes memory _code)
        external
        payable
        returns (address adds)
    {
        assembly {
            // create(v,p,n);
            // v æ˜¯ å‘é€çš„ETHå€¼
            // p æ˜¯ å†…å­˜ä¸­æœºå™¨ç å¼€å§‹çš„ä½ç½®
            // n æ˜¯ å†…å­˜ä¸­æœºå™¨ç çš„å¤§å°
            // msg.value ä¸èƒ½ä½¿ç”¨ï¼Œéœ€è¦ç”¨ callvalue()
            adds := create(callvalue(), add(_code, 0x20), mload(_code))
        }

        require(adds != address(0), "Depoly Failed");
        emit Depoly(adds);
    }

    // è·³ç”¨
    function execute(address _target, bytes memory _data) external payable {
        (bool success, ) = _target.call{value: msg.value}(_data);
        require(success, "Failed");
    }
}

contract Helper {
    // ç”Ÿæˆ type(contract).creationCode
    function getBytescode1() external pure returns (bytes memory bytecode) {
        bytecode = type(Test1).creationCode;
    }

    // ç”Ÿæˆæ„é€ å‡½æ•°å¸¦æœ‰å‚æ•°çš„ bytecodeï¼Œå‚æ•°è¿æ¥åé¢å°±å¯ä»¥äº†
    function getBytescode2(uint256 _x, uint256 _y)
        external
        pure
        returns (bytes memory)
    {
        bytes memory bytecode = type(Test2).creationCode;
        // abi å…¨å±€å˜é‡
        return abi.encodePacked(bytecode, abi.encode(_x, _y));
    }

    // è°ƒç”¨åˆçº¦æ–¹æ³•çš„calldataï¼Œä½¿ç”¨ abi.encodeWithSignature
    function getCalldata(address _owner) external pure returns (bytes memory) {
        return abi.encodeWithSignature("setOwner(address)", _owner);
    }
}
```

### æµ‹è¯•éƒ¨ç½²

å‰ææ¡ä»¶ï¼šéƒ¨ç½² Helper å’Œ Proxy åˆçº¦ã€‚

0. é€šè¿‡ getBytescode1 ï¼Œè·å– Test1 éœ€è¦çš„ bytecode
1. éƒ¨ç½² Test1
2. è·å– Test1 åˆçº¦åœ°å€
3. At Test1 Address
4. è·å– Test1 owner åœ°å€
5. é€šè¿‡ getCalldata ï¼Œè·å– Test1 setOwner éœ€è¦çš„ bytecodeã€‚å‚æ•°æ˜¯æƒ³è¦è®¾ç½®çš„ Owner åœ°å€ã€‚
6. æ‰§è¡Œ execute(),å‚æ•°æ˜¯ Test1 åˆçº¦åœ°å€ å’Œ getCalldata è¿”å›å€¼ã€‚

åˆçº¦ 2

0. é€šè¿‡ getBytescode2 ï¼Œè·å– Test2 éœ€è¦çš„ bytecode
1. éƒ¨ç½² Test2ï¼Œéœ€è¦è®¾ç½® x, y çš„å€¼ï¼Œå¯ä»¥é€‰æ‹©æ”¯ä»˜ ETHã€‚
2. è·å– Test2 åˆçº¦åœ°å€
3. At Test2 Address
4. æŸ¥çœ‹ Test2 çš„å€¼


## ğŸ†— å®æˆ˜åº”ç”¨ï¼šä½¿ç”¨ assembly åš create2

UniswapV2Factory çš„åˆ›å»º pairä»£ç å¦‚ä¸‹

```
function createPair(address tokenA, address tokenB) external returns (address pair) {
    require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES');
    (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
    require(token0 != address(0), 'UniswapV2: ZERO_ADDRESS');
    require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS'); // single check is sufficient
    bytes memory bytecode = type(UniswapV2Pair).creationCode;
    bytes32 salt = keccak256(abi.encodePacked(token0, token1));
    assembly {
        pair := create2(0, add(bytecode, 32), mload(bytecode), salt)
    }
    IUniswapV2Pair(pair).initialize(token0, token1);
    getPair[token0][token1] = pair;
    getPair[token1][token0] = pair; // populate mapping in the reverse direction
    allPairs.push(pair);
    emit PairCreated(token0, token1, pair, allPairs.length);
}
```


## #ï¸âƒ£ é—®ç­”é¢˜

- é€šè¿‡ `new` åˆ›å»ºåˆçº¦ / `create`çš„æ–¹æ³•
  - 1 å°†ä½œä¸ºåˆçº¦çš„ä¸€éƒ¨åˆ†æ‰§è¡Œ `D d = new D(4);`
  - 2 æ–¹æ³•å†…åˆ›å»º
    ```
    function createD(uint arg) public {
        D newD = new D(arg);
    }
    ```
  - 2 æ–¹æ³•å†…åˆ›å»ºï¼Œå¹¶è½¬è´¦
    ```
    function createD2(uint arg, uint amount) public payable {
        //éšåˆçº¦çš„åˆ›å»ºå‘é€ ether
        D newD = (new D){value:amount}(arg);
    }
    ```
- create / create2 åŒºåˆ«
  - åœ¨åˆ›å»ºåˆçº¦æ—¶ï¼Œå°†æ ¹æ®åˆ›å»ºåˆçº¦çš„åœ°å€å’Œæ¯æ¬¡åˆ›å»ºåˆçº¦äº¤æ˜“æ—¶çš„ `nonce` æ¥è®¡ç®—åˆçº¦çš„åœ°å€ã€‚å¦‚æœä½ æŒ‡å®šäº†ä¸€ä¸ªå¯é€‰çš„ `salt` ï¼ˆä¸€ä¸ª bytes32 å€¼ï¼‰ï¼Œé‚£ä¹ˆåˆçº¦åˆ›å»ºå°†ä½¿ç”¨å¦ä¸€ç§æœºåˆ¶(`create2`)æ¥ç”Ÿæˆæ–°åˆçº¦çš„åœ°å€ï¼šå®ƒå°†æ ¹æ®ç»™å®šçš„ `salt` ï¼Œåˆ›å»ºåˆçº¦çš„å­—èŠ‚ç å’Œæ„é€ å‡½æ•°å‚æ•°æ¥è®¡ç®—åˆ›å»ºåˆçº¦çš„åœ°å€ã€‚ç‰¹åˆ«æ³¨æ„ï¼Œè¿™é‡Œä¸å†ä½¿ç”¨ `nonce`ã€‚
- create2 çš„æ„ä¹‰
  - å¯ä»¥åœ¨åˆ›å»ºåˆçº¦æ—¶æä¾›æ›´å¤§çš„çµæ´»æ€§ï¼šä½ å¯ä»¥åœ¨åˆ›å»ºæ–°åˆçº¦ä¹‹å‰å°±æ¨å¯¼å‡ºå°†è¦åˆ›å»ºçš„åˆçº¦åœ°å€ã€‚ç”šè‡³æ˜¯è¿˜å¯ä»¥ä¾èµ–æ­¤åœ°å€ï¼ˆå³ä¾¿å®ƒè¿˜ä¸å­˜åœ¨ï¼‰æ¥åˆ›å»ºå…¶ä»–åˆçº¦ã€‚ä¸€ä¸ªä¸»è¦ç”¨ä¾‹åœºæ™¯æ˜¯**å……å½“é“¾ä¸‹äº¤äº’ä»²è£åˆçº¦ï¼Œä»…åœ¨æœ‰äº‰è®®æ—¶æ‰éœ€è¦åˆ›å»ºã€‚**
- create2 æœ‰ä»€ä¹ˆéœ€è¦æ³¨æ„çš„ï¼Ÿ
  - ä¸èƒ½é‡å¤ä½¿ç”¨ salt
  - ä½¿ç”¨ `create2` åˆ›å»ºåˆçº¦è¿˜æœ‰ä¸€äº›ç‰¹åˆ«ä¹‹å¤„ã€‚ åˆçº¦é”€æ¯åå¯ä»¥åœ¨åŒä¸€åœ°å€é‡æ–°åˆ›å»ºã€‚ä¸è¿‡ï¼Œå³ä½¿åˆ›å»ºå­—èŠ‚ç ï¼ˆcreation bytecodeï¼‰ç›¸åŒï¼ˆè¿™æ˜¯è¦æ±‚ï¼Œå› ä¸ºå¦åˆ™åœ°å€ä¼šå‘ç”Ÿå˜åŒ–ï¼‰ï¼Œè¯¥æ–°åˆ›å»ºçš„åˆçº¦ä¹Ÿå¯èƒ½æœ‰ä¸åŒçš„éƒ¨ç½²å­—èŠ‚ç ï¼ˆdeployed bytecodeï¼‰ã€‚ è¿™æ˜¯å› ä¸ºæ„é€ å‡½æ•°å¯ä»¥ä½¿ç”¨ä¸¤æ¬¡åˆ›å»ºåˆçº¦ä¹‹é—´å¯èƒ½å·²æ›´æ”¹çš„å¤–éƒ¨çŠ¶æ€ï¼Œå¹¶åœ¨å­˜å‚¨åˆçº¦æ—¶å°†å…¶åˆå¹¶åˆ°éƒ¨ç½²å­—èŠ‚ç ä¸­ã€‚
- å¦‚ä½•é¢„æµ‹ create2 åˆçº¦åœ°å€
  - æ ¸å¿ƒå¦‚ä¸‹
    ```
    bytes32 hash = keccak256(
        abi.encodePacked(
            bytes1(0xff), // å›ºå®šå­—ç¬¦ä¸²
            address(this), // å½“å‰å·¥å‚åˆçº¦åœ°å€ï¼Œå›ºå®šå†™æ³•
            _salt, // salt
            keccak256(bytecode) //éƒ¨ç½²åˆçº¦çš„ bytecode
        )
    );
    return address(uint160(uint256(hash)));
    ```
  - ç²¾ç¡®å†™æ³•
    ```
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.17;

    contract D {
        uint public x;
        constructor(uint a) {
            x = a;
        }
    }

    contract C {
        function createDSalted(bytes32 salt, uint arg) public {
            /// è¿™ä¸ªå¤æ‚çš„è¡¨è¾¾å¼åªæ˜¯å‘Šè¯‰æˆ‘ä»¬ï¼Œå¦‚ä½•é¢„å…ˆè®¡ç®—åœ°å€ã€‚
            /// è¿™é‡Œä»…ä»…ç”¨æ¥è¯´æ˜ã€‚
            /// å®é™…ä¸Šï¼Œä½ ä»…ä»…éœ€è¦ ``new D{salt: salt}(arg)``.
            address predictedAddress = address(uint160(uint(keccak256(abi.encodePacked(
                bytes1(0xff), // å›ºå®šå­—ç¬¦ä¸²
                address(this), // å½“å‰å·¥å‚åˆçº¦åœ°å€ï¼Œå›ºå®šå†™æ³•
                salt, // salt
                //éƒ¨ç½²åˆçº¦çš„ bytecode
                keccak256(abi.encodePacked(
                    type(D).creationCode,
                    arg
                ))
            )))));

            D d = new D{salt: salt}(arg);
            require(address(d) == predictedAddress);
        }
    }
    ```

