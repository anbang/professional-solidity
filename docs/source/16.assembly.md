# 16.Assembly:å†…è”æ±‡ç¼–

ä½¿ç”¨å†…è”æ±‡ç¼–ï¼Œå¯ä»¥åœ¨ Solidity æºç¨‹åºä¸­åµŒå…¥æ±‡ç¼–ä»£ç ï¼Œå¯¹ EVM æœ‰æ›´ç»†ç²’åº¦çš„æ§åˆ¶ã€‚å†…è”æ±‡ç¼–ä¸»è¦ç”¨åœ¨ç¼–å†™åº“å‡½æ•°æ—¶å¾ˆæœ‰ç”¨ï¼Œä¸€èˆ¬ç”¨äºå†™å·¥å…·å‡½æ•°ï¼Œæ¯”å¦‚æ¤­åœ†ç­¾åè§£æç­‰ã€‚åœ¨é¡¹ç›®ä¸­ç”¨æ±‡ç¼–ç¼–ä¸»è¦æ˜¯ opensea çš„ [seaport](https://github.com/ProjectOpenSea/seaport) åˆçº¦.

åœ¨åˆçº¦çš„å†…éƒ¨ä½¿ç”¨æ±‡ç¼–ï¼Œæ˜¯åœ¨åˆçº¦å†…éƒ¨åŒ…å« `assembly` å…³é”®å­—è¿›è¡Œç¼–å†™çš„ï¼Œåœ¨ Solidity `inline assembly`(å†…è”æ±‡ç¼–) ä¸­çš„è¯­è¨€è¢«ç§°ä¸º Yulã€‚[Yul](https://docs.soliditylang.org/zh/latest/yul.html) é™¤äº†åœ¨ Solidity ä¹‹ä¸­ä½œä¸º inline assembly çš„ä¸€éƒ¨åˆ†ï¼Œä¹Ÿèƒ½å½“ä½œç‹¬ç«‹çš„ç›´è¯‘è¯­è¨€èƒ½å¤Ÿè¢«ç¼–è¯‘æˆ bytecode ç»™ä¸åŒçš„åç«¯ã€‚

æ³¨æ„ï¼šå†…è”æ±‡ç¼–æ˜¯ä¸€ç§åœ¨åº•å±‚è®¿é—®ä»¥å¤ªåŠè™šæ‹Ÿæœºçš„è¯­è¨€ï¼Œç”±äºç¼–è¯‘å™¨æ— æ³•å¯¹æ±‡ç¼–è¯­å¥è¿›è¡Œæ£€æŸ¥ï¼Œæ‰€ä»¥ Solidity æä¾›çš„å¾ˆå¤šé‡è¦å®‰å…¨ç‰¹æ€§éƒ½æ²¡åŠæ³•ä½œç”¨äºæ±‡ç¼–ã€‚å†™æ±‡ç¼–ä»£ç ç›¸å¯¹æ¯”è¾ƒå›°éš¾ï¼Œå¾ˆå¤šæ—¶å€™åªæœ‰åœ¨å¤„ç†ä¸€äº›ç›¸å¯¹å¤æ‚çš„é—®é¢˜æ—¶æ‰éœ€è¦ä½¿ç”¨å®ƒï¼Œå¹¶ä¸”å¼€å‘è€…éœ€è¦æ˜ç¡®çŸ¥é“è‡ªå·±è¦åšä»€ä¹ˆã€‚

## 1ï¸âƒ£ åŸºæœ¬æ ¼å¼

é€šè¿‡ `assembly {}` åŒ…è£¹ä»£ç ã€‚å¹¶ä¸”å†…éƒ¨æ¯ä¸€è¡Œè¯­å¥ä¸éœ€è¦ä½¿ç”¨`;`æ˜¾ç¤ºçš„æ ‡æ³¨ç»“æŸã€‚Assembly ä¹Ÿæ”¯æŒæ³¨é‡Šï¼Œå¯ä»¥ä½¿ç”¨ `//` å’Œ `/* */` æ¥è¿›è¡Œæ³¨é‡Šã€‚

âš ï¸ æ³¨æ„ï¼š Inline Assembly ä¸­ï¼Œä»£ç å—ä¹‹é—´æ˜¯ä¸èƒ½å½¼æ­¤æ²Ÿé€šçš„ï¼Œé‡Œé¢å£°æ˜çš„å˜é‡éƒ½æ˜¯æœ¬åœ°å˜é‡ã€‚

### ä¾‹å­: ä¸åŒä»£ç å—æ— æ³•äº’ç›¸è®¿é—®

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly() public view returns (uint256) {
        assembly {
            let x := 2
        }
        assembly {
            let y := x // DeclarationError: Identifier "x" not found.
        }
    }
}
```

let æŒ‡ä»¤æ‰§è¡Œå¦‚ä¸‹ä»»åŠ¡ï¼š

- åˆ›å»ºä¸€ä¸ªæ–°çš„å †æ ˆæ§½ä½
- ä¸ºå˜é‡ä¿ç•™è¯¥æ§½ä½
- å½“åˆ°è¾¾ä»£ç å—ç»“æŸæ—¶è‡ªåŠ¨é”€æ¯è¯¥æ§½ä½

å› æ­¤ï¼Œä½¿ç”¨ let æŒ‡ä»¤åœ¨æ±‡ç¼–ä»£ç å—ä¸­å®šä¹‰çš„å˜é‡ï¼Œåœ¨ä»£ç å—å¤–éƒ¨æ˜¯æ— æ³•è®¿é—®çš„ã€‚ä½†æ˜¯å†…éƒ¨ä»£ç å—å¯ä»¥è®¿é—®å¤–éƒ¨ä»£ç å—çš„å†…å®¹ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly() public pure {
        assembly {
            let x := 3

            {
                let y := x // success
            } // åˆ°æ­¤å¤„ä¼šé”€æ¯y
        }
    }
}
```

### ä¾‹å­: ç®€å•çš„åŠ æ³•

ä¸‹é¢æ˜¯ä¸€ä¸ªè®¡ç®— `_x + _y` çš„ä¸¤ç§å†™æ³•å¯¹æ¯”ï¼Œæ±‡ç¼–çš„è¯­æ³•èŠ‚çœäº† `1.76%` çš„ gasã€‚ assembly æ ¸å¿ƒæ˜¯æ›´ç»†ç²’åº¦çš„æ§åˆ¶ï¼Œçœ gas åªæ˜¯å®ƒçš„å¤–åœ¨è¡¨ç°ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    // è¾“å…¥ 1,2 ; è¾“å‡º 22307 gas
    function addSolidity(uint256 _x, uint256 _y) public pure returns (uint256) {
        return (_x + _y);
    }

    // è¾“å…¥ 1,2 ; è¾“å‡º 21915 gas
    function addAssembly(uint256 _x, uint256 _y) public pure returns (uint256) {
        assembly {
            // let result æ˜¯å£°æ˜ä¸€ä¸ªå˜é‡ result
            // add(_x, _y) æ˜¯è®¡ç®— x + y çš„ç»“æœ
            // := æ˜¯å°† x + y çš„ç»“æœèµ‹å€¼ç»™å˜é‡ result
            let result := add(_x, _y)

            // mstore(0x0, result) åœ¨å†…å­˜ `0x0` çš„ä½ç½®å‚¨å­˜ `result`
            mstore(0x0, result)

            // ä»å†…å­˜ç´¢å¼• 0x0 ä½ç½®è¿”å›32å­—èŠ‚
            return(0x0, 32)
        }
    }
}
```

## 2ï¸âƒ£ è¯­è¨€åŸºç¡€

Yul æä¾›äº†é«˜çº§ç»“æ„ï¼Œå¦‚ `for` å¾ªç¯ã€`if` è¯­å¥ `switch` å’Œå‡½æ•°è°ƒç”¨ç­‰ç­‰ï¼Œä¸‹é¢æŒ‰ç…§åˆ†ç±»è¿›è¡Œä»‹ç»ã€‚

åœ¨ Inline Assembly ä¸­ï¼Œä»¥ä¸‹å‡ ä¸ªç‚¹å¾ˆé‡è¦ï¼š

- èµ‹å€¼: ä½¿ç”¨çš„æ˜¯`:=`ï¼Œè€Œä¸æ˜¯`=`ã€‚
- å£°æ˜å˜é‡: ä½¿ç”¨ `let` å£°æ˜ï¼›ï¼ˆä¸æ˜¯æ­£å¸¸å¸¦æœ‰æŒ‡å®šç±»å‹çš„å¼ºç±»å‹æ–¹å¼ï¼‰

### å£°æ˜ä¸èµ‹å€¼

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly() public pure returns (uint256, uint256) {
        assembly {
            let x := 2  // å£°æ˜ xï¼Œèµ‹å€¼ä¸º2
            let y       // å£°æ˜ yï¼Œåˆå§‹åŒ–ä¸º 0
            y := 5      // èµ‹å€¼ y ä¸º5

            mstore(0x0, x) // å†…å­˜ä¸­å‚¨å­˜ x
            mstore(add(0x0, 32), y) // å†…å­˜ä¸­ç§»åŠ¨32ä½ï¼Œå†å‚¨å­˜y

            // è¿”å›å†…å­˜ä¸­ 0 - 64 çš„æ•°æ®
            return(0x0, 64)
        }
    }
}
```

ç»“æœå°±æ˜¯ `2,5`ï¼›

åœ¨ Solidity æ±‡ç¼–ä¸­å­—é¢é‡çš„å†™æ³•ä¸ Solidity ä¸€è‡´ã€‚ä½†æ˜¯ å­—ç¬¦ä¸²å­—é¢é‡ æœ€å¤šå¯ä»¥åŒ…å« 32 ä¸ªå­—ç¬¦ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly() public pure {
        assembly {
            let a := 0x123 // 16è¿›åˆ¶
            let b := 42 // 10è¿›åˆ¶
            let c := "hello world" // å­—ç¬¦ä¸²
            let d := "very long string more than 32 bytes" // é•¿åº¦ 35 çš„ å­—ç¬¦ä¸²ï¼Œé”™è¯¯ï¼
        }
    }
}
```

### æ±‡ç¼–åªèƒ½è¯»å–å±€éƒ¨å˜é‡

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    uint256 a = 2;
    function demoAssembly() public pure {
        uint256 b = 5;
        assembly {
            // å¯ä»¥è¯»å– x å’Œ y
            let x := add(2, 3)
            let y := 10
            let z := add(x, y)
        }
        assembly {
            // å¯ä»¥è¯»å– x å’Œ b
            let x := add(2, 3)
            let y := mul(x, b)
        }
        assembly {
            let x := add(2, 3)

            // âŒ TypeError: Only local variables are supported.
            // To access storage variables, use the ".slot" and ".offset" suffixes.
            let y := mul(x, a)
        }
    }
}
```

## 3ï¸âƒ£ æ¡ä»¶åˆ¤æ–­

- if
- switch

### if

ç‰¹ç‚¹å¦‚ä¸‹

- åªæœ‰ if ï¼Œæ²¡æœ‰ else
- if è¯­å¥å¼ºåˆ¶è¦æ±‚ä»£ç å—ä½¿ç”¨å¤§æ‹¬å·ï¼Œ`{}`ä¸å…è®¸çœç•¥

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly() public pure {
        uint256 x;
        assembly {
            // success
            if iszero(x) {
                x := sub(1, x)
            }

            // fail: æ²¡æœ‰ä½¿ç”¨ {} åŒ…è£¹ä»£ç 
            // if iszero(x) revert(0, 0)
        }
    }
}
```

å¦‚æœéœ€è¦åœ¨ Solidity å†…è”æ±‡ç¼–ä¸­æ£€æŸ¥å¤šç§æ¡ä»¶ï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨ switch è¯­å¥ã€‚

### switch

switch è¯­å¥æ”¯æŒ ä¸€ä¸ªé»˜è®¤åˆ†æ”¯ defaultï¼Œå½“è¡¨è¾¾å¼çš„å€¼ä¸åŒ¹é…ä»»ä½•å…¶ä»–åˆ†æ”¯æ¡ä»¶æ—¶ï¼Œå°† æ‰§è¡Œé»˜è®¤åˆ†æ”¯çš„ä»£ç ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly(uint256 x) public pure returns (uint256 result) {
        assembly {
            switch x
            case 0 {
                result := 0
            }
            case 1 {
                result := 1
            }
            default {
                result := mul(x, x)
            }
        }
    }
}
```

## 4ï¸âƒ£ for å¾ªç¯

for å¾ªç¯ä¹ŸåŒ…å« 3 ä¸ªå…ƒç´ 

- åˆå§‹åŒ–ï¼šæ¯”å¦‚`let i := 0`
- æ‰§è¡Œæ¡ä»¶ï¼šæ¯”å¦‚`lt(i, n)` ï¼Œå¿…é¡»æ˜¯å‡½æ•°é£æ ¼è¡¨è¾¾å¼
- è¿­ä»£åç»­æ­¥éª¤ï¼šæ¯”å¦‚`add(i, 1)`

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly() public pure returns (uint256 result) {
        uint256 leng = 10;

        assembly {
            for
            { let i := 0 }
            lt(i, leng)
            { i := add(i, 1) }
            {
                result := add(result, i)
            }

            // ä¸‹é¢å¯ä»¥çœç•¥
            mstore(0x0, result)
            return(0x0, 32)
        }
    }
}
```

for å¾ªç¯çš„**åˆå§‹åŒ–éƒ¨åˆ†**å’Œ**è¿­ä»£åç»­æ­¥éª¤**å¯ä»¥ç•™ç©º , æ”¹å†™ä¸ºä¸‹é¢çš„æ ¼å¼

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly() public pure returns (uint256 result) {
        uint256 leng = 10;
        assembly {
            let i := 0 // åˆå§‹æ¡ä»¶å†™åœ¨è¿™
            for {} lt(i, leng) {} {
                // æ ¸å¿ƒéƒ¨åˆ†
                result := add(result, i)

                // è¿­ä»£åç»­æ­¥éª¤å†™åœ¨è¿™
                i := add(i, 1)
            }

            // å¯ä»¥çœç•¥
            mstore(0x0, result)
            return(0x0, 32)
        }
    }
}
```

å¤‡æ³¨: `continue` or `break` è¯­å¥åªèƒ½åœ¨ `for` å¾ªç¯ä½“å†…ä½¿ç”¨

## 5ï¸âƒ£ å‡½æ•°çš„å®šä¹‰å’Œä½¿ç”¨

å‡½æ•°çš„è¿è¡Œæœºåˆ¶å¦‚ä¸‹ï¼š

- ä»å †æ ˆæå–å‚æ•°
- å°†ç»“æœå‹å…¥å †æ ˆ
- å’Œ Solidity å‡½æ•°ä¸åŒï¼Œä¸éœ€è¦æŒ‡å®šæ±‡ç¼–å‡½æ•°çš„å¯è§æ€§
  - ä¾‹å¦‚ public æˆ– privateï¼Œ å› ä¸ºæ±‡ç¼–å‡½æ•°ä»…åœ¨å®šä¹‰æ‰€åœ¨çš„æ±‡ç¼–ä»£ç å—å†…æœ‰æ•ˆã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly() public pure returns (uint256 free_memory_pointer) {
        assembly {
            // å‡½æ•°å®šä¹‰
            function allocate(length) -> pos {
                pos := mload(0x40)
                mstore(0x40, add(pos, length))
            }

            // å‡½æ•°ä½¿ç”¨
            free_memory_pointer := allocate(64)
        }
    }
}
```

## 6ï¸âƒ£ EVM å†…ç½®å‡½æ•°/å†…ç½®æ“ä½œç 

- ç®—æ•°æ“ä½œ
  - `add`: åŠ æ³•
  - `mul`:
- æ¯”è¾ƒæ“ä½œ
  - `lt`
  - `gt`
- ä½æ“ä½œ
  - `not`:
  - `and`:
- å¯†ç å­¦æ“ä½œï¼Œç›®å‰ä»…åŒ…å« keccak256
- ç¯å¢ƒæ“ä½œï¼Œä¸»è¦æŒ‡ä¸åŒºå—é“¾ç›¸å…³çš„å…¨å±€ä¿¡æ¯ï¼Œä¾‹å¦‚ blockhash æˆ– coinbase æ”¶æ¬¾è´¦å·
- å­˜å‚¨ã€å†…å­˜å’Œæ ˆæ“ä½œ
- äº¤æ˜“ä¸åˆçº¦è°ƒç”¨æ“ä½œ
- åœæœºæ“ä½œ
- æ—¥å¿—æ“ä½œ

ä¸‹é¢æ˜¯è¯¦ç»†çš„åˆ—è¡¨è¯´æ˜ï¼Œæ ‡è®°ä¸º`-`çš„æ“ä½œä¸è¿”å›ç»“æœï¼Œå…¶ä»–æ‰€æœ‰æ“ä½œç åªè¿”å›ä¸€ä¸ªå€¼ã€‚

æ ‡æœ‰ Fã€Hã€Bã€C ã€I å’Œ L åˆ†åˆ«è‡ªå‡ºç°çš„æ—¶é—´ï¼Œå¯¹åº”çš„å¦‚ä¸‹

- `F`: Frontier
- `H`: Homestead
- `B`: Byzantium
- `C`: Constantinople
- `I`: Istanbul
- `L`: London

å¸¸è§çš„å¸¸é‡å€¼æ˜¯ `0x20` / `0x40` , ä»£è¡¨åè¿›åˆ¶çš„ 32 å’Œ 64ã€‚

### æ•°å­¦è®¡ç®—

| æ“ä½œç¬¦å·        | è¿”å›å€¼ | ç‰ˆæœ¬ | è§£é‡Šè¯´æ˜                                                |
| --------------- | ------ | ---- | ------------------------------------------------------- |
| add(x, y)       |        | F    | `x + y`                                                 |
| sub(x, y)       |        | F    | `x - y`                                                 |
| mul(x, y)       |        | F    | `x * y`                                                 |
| div(x, y)       |        | F    | `x / y` (å¦‚æœ y ä¸º 0ï¼Œåˆ™ç»“æœä¸º 0)                       |
| mod(x, y)       |        | F    | `x % y` (å¦‚æœ y ä¸º 0ï¼Œåˆ™ç»“æœä¸º 0)                       |
| exp(x, y)       |        | F    | `x` çš„ `y` æ¬¡æ–¹                                         |
| addmod(x, y, m) |        | F    | `(x + y) % m` ä»»æ„ç²¾åº¦ç®—æœ¯ï¼Œå¦‚æœ m == 0 åˆ™ä¸º 0          |
| mulmod(x, y, m) |        | F    | `(x * y) % m` ä»»æ„ç²¾åº¦ç®—æœ¯ï¼Œå¦‚æœ m == 0 åˆ™ä¸º 0          |
| sdiv(x, y)      |        | F    | `x / y`, ä»¥äºŒè¿›åˆ¶è¡¥ç ä½œä¸ºç¬¦å· (å¦‚æœ y ä¸º 0ï¼Œåˆ™ç»“æœä¸º 0) |
| smod(x, y)      |        | F    | `x % y`, ä»¥äºŒè¿›åˆ¶è¡¥ç ä½œä¸ºç¬¦å· (å¦‚æœ y ä¸º 0ï¼Œåˆ™ç»“æœä¸º 0) |

#### add: åŠ æ³•

```
function demoAssembly(uint256 _x, uint256 _y)
    public
    pure
    returns (uint256)
{
    assembly {
        let result := add(_x, _y)
        mstore(0x0, result)
        return(0x0, 32)
    }
}
```

ä¸Šé¢åˆçº¦å‡½æ•°ï¼Œä¼ å…¥å‚æ•°:`1,2`ï¼Œè¿”å›`3`ã€‚

è¿™é‡Œéœ€è¦è¿”å›`uint256`ç±»å‹ï¼Œassembly å†…éƒ¨è¿”å›æ˜¯ï¼Œä»ä»€ä¹ˆä½ç½®å¼€å‘ï¼Œè¿”å›å¤šå°‘ä¸ªæ•°æ®ã€‚éœ€è¦è¿”å›ä¸¤ä¸ªæ•°æ®ã€‚æ¯”å¦‚æˆ‘æŠŠ uint256 æ”¹ä¸º uint8ï¼Œä»£ç å¦‚ä¸‹

```
function demoAssembly(uint8 _x, uint8 _y)
    public
    pure
    returns (uint8)
{
    assembly {
        let result := add(_x, _y)
        mstore(0x0, result)
        return(0x0, 2)
    }
}
```

ç›¸åŒçš„å‚æ•°ä¼šæŠ¥é”™: `error:Failed to decode output: Error: data out-of-bounds (length=2, offset=32, code=BUFFER_OVERRUN, version=abi/5.5.0)`

#### sub: å‡æ³•

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly(uint256 _x, uint256 _y)
        public
        pure
        returns (uint256)
    {
        assembly {
            let result := sub(_x, _y)
            mstore(0x0, result)
            return(0x0, 32)
        }
    }
}
```

ä¼ å…¥å‚æ•°:`2,1`ï¼Œè¿”å›`1`ã€‚

æ³¨æ„ï¼šè¿™æ—¶å€™å¦‚æœä¼ å‚ `1,2`ï¼Œä¼šæº¢å‡ºè¿”å›ï¼Œå¾—åˆ°çš„ç»“æœä¸ä¼šæŠ¥é”™ï¼Œåè€Œæ˜¯:`115792089237316195423570985008687907853269984665640564039457584007913129639935`ï¼Œå› ä¸º assembly ç»•è¿‡äº† solidity çš„å®‰å…¨æ£€æŸ¥ã€‚å½“æˆ‘ä»¬ä½¿ç”¨ assembly ç¼–ç æ—¶å€™ï¼Œå®‰å…¨é—®é¢˜éœ€è¦è‡ªå·±æ§åˆ¶ï¼Œä¸è¦é”™è¯¯çš„è®¤ä¸º solidity çš„é»˜è®¤æœºåˆ¶ä¼šä¿æŠ¤ä»£ç ã€‚

#### mul: ä¹˜æ³•

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly(uint256 _x, uint256 _y)
        public
        pure
        returns (uint256)
    {
        assembly {
            let result := mul(_x, _y)
            mstore(0x0, result)
            return(0x0, 32)
        }
    }
}
```

ä¼ å…¥å‚æ•°:`2,3`ï¼Œè¿”å›`6`ã€‚

#### div: é™¤æ³•

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly(uint256 _x, uint256 _y)
        public
        pure
        returns (uint256)
    {
        assembly {
            let result := div(_x, _y)
            mstore(0x0, result)
            return(0x0, 32)
        }
    }
}
```

- ä¼ å…¥å‚æ•°:`3,2`ï¼Œè¿”å›`1`ã€‚
- ä¼ å…¥å‚æ•°:`3,1`ï¼Œè¿”å›`3`ã€‚
- ä¼ å…¥å‚æ•°:`3,0`ï¼Œè¿”å›`0`ã€‚

#### mod: æ±‚æ¨¡

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly(uint256 _x, uint256 _y)
        public
        pure
        returns (uint256)
    {
        assembly {
            let result := mod(_x, _y)
            mstore(0x0, result)
            return(0x0, 32)
        }
    }
}
```

- ä¼ å…¥å‚æ•°:`3,2`ï¼Œè¿”å›`1`
- ä¼ å…¥å‚æ•°:`3,1`ï¼Œè¿”å›`0`
- ä¼ å…¥å‚æ•°:`3,0`,è¿”å›`0`
- ä¼ å…¥å‚æ•°:`3,30`,è¿”å›`3`

#### exp: æ¬¡æ–¹

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly(uint256 _x, uint256 _y)
        public
        pure
        returns (uint256)
    {
        assembly {
            let result := exp(_x, _y)
            mstore(0x0, result)
            return(0x0, 32)
        }
    }
}
```

- ä¼ å…¥å‚æ•°:`10,2`ï¼Œè¿”å›`100`ã€‚
- ä¼ å…¥å‚æ•°:`10,3`ï¼Œè¿”å›`1000`ã€‚

#### addmod: å…ˆæ±‚å’Œå†æ±‚æ¨¡

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly(
        uint256 _x,
        uint256 _y,
        uint256 _m
    ) public pure returns (uint256) {
        assembly {
            let result := addmod(_x, _y, _m)
            mstore(0x0, result)
            return(0x0, 32)
        }
    }
}
```

- ä¼ å…¥å‚æ•°:`2,3,3`ï¼Œè¿”å›`2`ã€‚

#### mulmod: å…ˆç›¸ä¹˜å†æ±‚æ¨¡

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly(
        uint256 _x,
        uint256 _y,
        uint256 _m
    ) public pure returns (uint256) {
        assembly {
            let result := mulmod(_x, _y, _m)
            mstore(0x0, result)
            return(0x0, 32)
        }
    }
}

```

- ä¼ å…¥å‚æ•°:`2,3,3`ï¼Œè¿”å›`0`ã€‚

#### äºŒè¿›åˆ¶è¡¥ç 

ä¸‹é¢ä¸¤ä¸ªæ–¹æ³•ï¼Œç”¨æ³•åŸºæœ¬å’Œ div / mod å·®ä¸å¤š

```
let result := sdiv(_x, _y)
```

```
let result := smod(_x, _y)
```

### æ¯”è¾ƒå…³ç³»

| æ“ä½œç¬¦å·  | è¿”å›å€¼ | ç‰ˆæœ¬ | è§£é‡Šè¯´æ˜                                          |
| --------- | ------ | ---- | ------------------------------------------------- |
| gt(x, y)  |        | F    | å¦‚æœ `x > y` ç­‰äº 1, å¦åˆ™ 0                       |
| lt(x, y)  |        | F    | å¦‚æœ `x < y` ç­‰äº 1, å¦åˆ™ 0                       |
| eq(x, y)  |        | F    | å¦‚æœ `x == y` ç­‰äº 1, å¦åˆ™ 0                      |
| iszero(x) |        | F    | å¦‚æœ `x == 0` ç­‰äº 1, å¦åˆ™ 0                      |
| slt(x, y) |        | F    | å¦‚æœ `x < y` ç­‰äº 1, å¦åˆ™ 0, ä»¥äºŒè¿›åˆ¶è¡¥ç ä½œä¸ºç¬¦å· |
| sgt(x, y) |        | F    | å¦‚æœ `x > y` ç­‰äº 1, å¦åˆ™ 0, ä»¥äºŒè¿›åˆ¶è¡¥ç ä½œä¸ºç¬¦å· |

#### gt: å¤§äº

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly(uint256 _x, uint256 _y)
        public
        pure
        returns (bool result)
    {
        assembly {
            result := gt(_x, _y)
        }
    }
}
```

- ä¼ å…¥å‚æ•°:`1,2`ï¼Œè¿”å› `false`
- ä¼ å…¥å‚æ•°:`10,3`ï¼Œè¿”å› `true`

#### lt: å°äº

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly(uint256 _x, uint256 _y)
        public
        pure
        returns (bool result)
    {
        assembly {
            result := lt(_x, _y)
        }
    }
}
```

- ä¼ å…¥å‚æ•°:`1,2`ï¼Œè¿”å› `true`
- ä¼ å…¥å‚æ•°:`10,3`ï¼Œè¿”å› `false`

#### eq: ç­‰äº

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly(uint256 _x, uint256 _y)
        public
        pure
        returns (bool result)
    {
        assembly {
            result := eq(_x, _y)
        }
    }
}
```

- ä¼ å…¥å‚æ•°:`1,2`ï¼Œè¿”å› `false`
- ä¼ å…¥å‚æ•°:`2,2`ï¼Œè¿”å› `true`

#### iszero: ç­‰äºé›¶

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly(uint256 _x)
        public
        pure
        returns (bool result)
    {
        assembly {
            result := iszero(_x)
        }
    }
}
```

æ³¨æ„è¯¥å‚æ•°åªæ¥æ”¶ä¸€ä¸ªå‚æ•°

- ä¼ å…¥å‚æ•°:`1`ï¼Œè¿”å› `false`
- ä¼ å…¥å‚æ•°:`0`ï¼Œè¿”å› `true`

### æŒ‰ä½ & ç§»ä½

| æ“ä½œç¬¦å·  | è¿”å›å€¼ | ç‰ˆæœ¬ | è§£é‡Šè¯´æ˜                            |
| --------- | ------ | ---- | ----------------------------------- |
| not(x)    |        | F    | å¯¹ x æŒ‰ä½å–å,ç±»ä¼¼`~x`;`x` çš„æŒ‰ä½é |
| and(x, y) |        | F    | x å’Œ y çš„æŒ‰ä½ä¸                     |
| or(x, y)  |        | F    | x å’Œ y çš„æŒ‰ä½æˆ–                     |
| xor(x, y) |        | F    | x å’Œ y çš„æŒ‰ä½å¼‚æˆ–                   |
| shl(x, y) |        | C    | y é€»è¾‘å·¦ç§» x ä½                     |
| shr(x, y) |        | C    | y é€»è¾‘å³ç§» x ä½                     |
| sar(x, y) |        | C    | å°† y ç®—æœ¯å³ç§» x ä½                  |

#### not: æŒ‰ä½é

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly(int256 _x) public pure returns (int256 result) {
        assembly {
            result := not(_x)
        }
    }
}
```

- ä¼ å…¥å‚æ•°:`0`ï¼Œè¿”å› `-1`
- ä¼ å…¥å‚æ•°:`1`ï¼Œè¿”å› `-2`
- ä¼ å…¥å‚æ•°:`-1`ï¼Œè¿”å› `0`
- ä¼ å…¥å‚æ•°:`-11`ï¼Œè¿”å› `10`

#### and: æŒ‰ä½ä¸

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly() public pure returns (int256 result) {
        int256 _x = 2;
        int256 _y = 3;
        assembly {
            result := and(_x, _y)
        }
    }
}
```

ç»“æœæ˜¯ 2

#### or: æŒ‰ä½æˆ–

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly() public pure returns (int256 result) {
        int256 _x = 2;
        int256 _y = 3;
        assembly {
            result := or(_x, _y)
        }
    }
}
```

ç»“æœæ˜¯ 3

#### xor: æŒ‰ä½å¼‚æˆ–

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly() public pure returns (int256 result) {
        int256 _x = 2;
        int256 _y = 3;
        assembly {
            result := xor(_x, _y)
        }
    }
}
```

ç»“æœ 1

#### shl: é€»è¾‘å·¦ç§»

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly() public pure returns (uint256 result) {
        uint256 A = 2;
        assembly {
            result := shl(A, 1) // 4
        }
    }
}
```

#### shr: é€»è¾‘å³ç§»

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly() public pure returns (uint256 result) {
        uint256 A = 2;
        assembly {
            result := shr(A, 1) // 0
        }
    }
}
```

#### sar: ç®—æœ¯å³ç§»

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly() public pure returns (uint256 result) {
        uint256 A = 2;
        assembly {
            result := sar(A, 1) // 0
        }
    }
}
```

### EVM åŒºå—äº¤æ˜“ç›¸å…³

<table border="1" class="docutils">
	<thead>
		<tr>
			<th>æ“ä½œç¬¦å·</th>
			<th>è¿”å›å€¼</th>
			<th>ç‰ˆæœ¬</th>
			<th>è§£é‡Šè¯´æ˜</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>address()</td>
			<td></td>
			<td>F</td>
			<td>å½“å‰åˆçº¦åœ°å€ / execution context</td>
		</tr>
		<tr>
			<td>balance(a)</td>
			<td></td>
			<td>F</td>
			<td>åœ°å€ a çš„ wei ä½™é¢</td>
		</tr>
		<tr>
			<td>selfbalance()</td>
			<td></td>
			<td>I</td>
			<td>ç›¸å½“äº <code>balance(address())</code>ï¼Œä½†æ›´ä¾¿å®œ</td>
		</tr>
		<tr>
			<td>extcodehash(a)</td>
			<td></td>
			<td>C</td>
			<td>åœ°å€ a çš„ä»£ç å“ˆå¸Œ</td>
		</tr>
		<tr>
			<td colspan="4"><center><strong>msg ç›¸å…³</strong></center></td>
		</tr>
		<tr>
			<td>caller()</td>
			<td></td>
			<td>F</td>
			<td>call sender ( ç±»ä¼¼<code>msg.sender</code>ï¼Ÿ) (excluding <code>delegatecall</code>)</td>
		</tr>
		<tr>
			<td>callvalue()</td>
			<td></td>
			<td>F</td>
			<td>wei sent together with the current callï¼ˆç±»ä¼¼<code>msg.value</code>ï¼Ÿï¼‰</td>
		</tr>
		<tr>
			<td colspan="4"><center><strong>block ç›¸å…³</strong></center></td>
		</tr>
		<tr>
			<td>chainid()</td>
			<td></td>
			<td>I</td>
			<td>å½“å‰ç½‘ç»œçš„é“¾ ID (EIP-1344)</td>
		</tr>
		<tr>
			<td>basefee()</td>
			<td></td>
			<td>L</td>
			<td>å½“å‰åŒºå—çš„åŸºæœ¬è´¹ç”¨ (EIP-3198 and EIP-1559)</td>
		</tr>
		<tr>
			<td>timestamp()</td>
			<td></td>
			<td>F</td>
			<td>å½“å‰å—çš„æ—¶é—´æˆ³ï¼Œè‡ªçºªå…ƒä»¥æ¥çš„ç§’æ•°</td>
		</tr>
		<tr>
			<td>coinbase()</td>
			<td></td>
			<td>F</td>
			<td>å½“å‰é‡‡çŸ¿å—ç›Šäºº</td>
		</tr>
		<tr>
			<td>number()</td>
			<td></td>
			<td>F</td>
			<td>å½“å‰åŒºå—å·</td>
		</tr>
		<tr>
			<td>difficulty()</td>
			<td></td>
			<td>F</td>
			<td>å½“å‰åŒºå—çš„éš¾åº¦</td>
		</tr>
		<tr>
			<td>gaslimit()</td>
			<td></td>
			<td>F</td>
			<td>å½“å‰åŒºå—çš„åŒºå— gas limit</td>
		</tr>
		<tr> 
			<td colspan="4"><center><strong>tx ç›¸å…³</strong></center></td>
		</tr>
		<tr>
			<td>origin()</td>
			<td></td>
			<td>F</td>
			<td>äº¤æ˜“å‘é€æ–¹</td>
		</tr>
		<tr>
			<td>gasprice()</td>
			<td></td>
			<td>F</td>
			<td>äº¤æ˜“çš„ gas ä»·æ ¼</td>
		</tr>
		<tr>
			<td colspan="4"><center><strong>å…¶å®ƒ</strong></center></td>
		</tr>
		<tr>
			<td>gas()</td>
			<td></td>
			<td>F</td>
			<td>å‰©ä½™ gas</td>
		</tr>
		<tr>
			<td>blockhash(b)</td>
			<td></td>
			<td>F</td>
			<td>æŒ‡å®š block çš„ hash - ä»…é€‚ç”¨äºæœ€å 256 ä¸ªå—ï¼Œä¸åŒ…æ‹¬å½“å‰å—</td>
		</tr>
	</tbody>
</table>

#### address()

ç›¸å½“äº `address(this)`

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly() public view returns (address ads1, address ads2) {
        assembly {
            ads1 := address()
        }

        ads2 = address(this);
    }
}
```

è¿”å›

- `0:address: ads1 0x3c725134d74D5c45B4E4ABd2e5e2a109b5541288`
- `1:address: ads2 0x3c725134d74D5c45B4E4ABd2e5e2a109b5541288`

#### balance(a)

ç›¸å½“äº `address.balance`

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly()
        public
        view
        returns (uint256 result1, uint256 result2)
    {
        address sender = msg.sender;
        assembly {
            result1 := balance(sender)
        }

        result2 = address(sender).balance;
    }
}
```

è¿”å›

- `0:uint256: result1 99999999999992173039`
- `1:uint256: result2 99999999999992173039`

#### selfbalance()

ç›¸å½“äº `balance(address())`ï¼Œä½†æ›´ä¾¿å®œ

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    constructor() payable {}

    function demoAssembly()
        public
        view
        returns (uint256 result1, uint256 result2)
    {
        assembly {
            result1 := balance(address())
        }

        result2 = address(this).balance;
    }
}
```

#### extcodehash(a)

ç›¸å½“äº `address.codehash`

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly()
        public
        view
        returns (bytes32 result1, bytes32 result2)
    {
        address sender = msg.sender;
        assembly {
            result1 := extcodehash(address())
        }
        result2 = address(this).codehash;
    }
}
```

- `0:bytes32: result1 0xcbefd958c5e7814e7e635b599c5859eb893c410292a7f9f82088c3e84ee3c0e9`
- `1:bytes32: result2 0xcbefd958c5e7814e7e635b599c5859eb893c410292a7f9f82088c3e84ee3c0e9`

#### caller()

ç›¸å½“äº `msg.sender`

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly() public view returns (address ads1, address ads2) {
        assembly {
            ads1 := caller()
        }

        ads2 = msg.sender;
    }
}
```

#### callvalue()

ç›¸å½“äº `msg.value`

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly()
        public
        payable
        returns (uint256 result1, uint256 result2)
    {
        assembly {
            result1 := callvalue()
        }
        result2 = msg.value;
    }
}
```

#### chainid()

ç›¸å½“äº `block.chainid`

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly()
        public
        view
        returns (uint256 result1, uint256 result2)
    {
        assembly {
            result1 := chainid() // 1
        }
        result2 = block.chainid; // 1
    }
}
```

#### basefee()

ç›¸å½“äº `block.basefee`

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly()
        public
        view
        returns (uint256 result1, uint256 result2)
    {
        assembly {
            result1 := basefee()
        }
        result2 = block.basefee;
    }
}
```

#### timestamp()

ç›¸å½“äº `block.timestamp`

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly()
        public
        view
        returns (uint256 result1, uint256 result2)
    {
        assembly {
            result1 := timestamp()
        }
        result2 = block.timestamp;
    }
}
```

#### coinbase()

ç›¸å½“äº `block.coinbase`

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly()
        public
        view
        returns (address result1, address result2)
    {
        assembly {
            result1 := coinbase()
        }
        result2 = block.coinbase;
    }
}
```

#### number()

ç›¸å½“äº `block.number`

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly()
        public
        view
        returns (uint256 result1, uint256 result2)
    {
        assembly {
            result1 := number()
        }
        result2 = block.number;
    }
}
```

#### difficulty()

ç›¸å½“äº `block.difficulty`

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly()
        public
        view
        returns (uint256 result1, uint256 result2)
    {
        assembly {
            result1 := difficulty()
        }
        result2 = block.difficulty;
    }
}
```

#### gaslimit()

ç›¸å½“äº `block.gaslimit`

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly()
        public
        view
        returns (uint256 result1, uint256 result2)
    {
        assembly {
            result1 := gaslimit()
        }
        result2 = block.gaslimit;
    }
}
```

#### origin()

ç›¸å½“äº `tx.origin`

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly()
        public
        view
        returns (address result1, address result2)
    {
        assembly {
            result1 := origin()
        }
        result2 = tx.origin;
    }
}
```

#### gasprice()

ç›¸å½“äº `tx.gasprice`

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly()
        public
        view
        returns (uint256 result1, uint256 result2)
    {
        assembly {
            result1 := gasprice()
        }
        result2 = tx.gasprice;
    }
}
```

#### gas()

ç›¸å½“äº `gasleft()`

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly()
        public
        view
        returns (uint256 result1, uint256 result2)
    {
        assembly {
            result1 := gas() // 2978815
        }

        // ä¸ assembly ä¹‹é—´çš„é¡ºåºä¸æ”¹å˜æœ€åçš„å€¼
        // æ‰€ä»¥ assembly ä¼˜å…ˆæ‰§è¡Œï¼Ÿ
        result2 = gasleft(); // 2978808
    }
}
```

#### blockhash(b)

ç›¸å½“äº `blockhash(number)`

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function demoAssembly()
        public
        view
        returns (bytes32 result1, bytes32 result2)
    {
        assembly {
            result1 := blockhash(1)
        }
        result2 = blockhash(1);
    }
}
```

### å¸¸è§æ–¹æ³•

| æ“ä½œç¬¦å·            | è¿”å›å€¼ | ç‰ˆæœ¬ | è§£é‡Šè¯´æ˜                              |
| ------------------- | ------ | ---- | ------------------------------------- |
| sload(p)            |        | F    | `storage[p]`                          |
| mload(p)            |        | F    | `mem[pâ€¦(p+32))`                       |
| sstore(p, v)        | -      | F    | `storage[p] := v`                     |
| mstore(p, v)        | -      | F    | `mem[pâ€¦(p+32)) := v`                  |
| mstore8(p, v)       | -      | F    | `mem[p] := v` & 0xff (åªä¿®æ”¹å•ä¸ªå­—èŠ‚) |
| keccak256(p, n)     |        | F    | `keccak(mem[pâ€¦(p+n)))`                |
| create(v, p, n)     |        | F    | create åˆ›å»ºåˆçº¦                       |
| create2(v, p, n, s) |        | C    | create2 åˆ›å»ºåˆçº¦                      |

å°ä¾‹å­:

- `mload(p)`: åˆ†é…æ•°æ®
- `mstore(offset, value)`: åœ¨ `offset` çš„ä½ç½®å‚¨å­˜ `value`

#### sload(p)

sload æ˜¯ storage loadï¼Œ`sload(key)` æ˜¯ä» storage çš„å“ªä¸ª slot æ¥ loadï¼Œè¯¦ç»†åŸç†å¯ä»¥åœ¨åé¢ä»‹ç»çš„ **çŠ¶æ€å˜é‡åœ¨å­˜å‚¨ä¸­çš„å¸ƒå±€** äº†è§£æ›´å¤šã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    uint256 public a = 123;
    uint256 public b = 456;

    function demoAssembly() public view returns (uint256) {
        assembly {
            // v æ˜¯é•¿åº¦æ˜¯ 32 bytes
            // ä» slot #0 è¯»æ•°æ® => è¯»åˆ°çš„æ˜¯ 123
            // ä» slot #1 è¯»æ•°æ® => è¯»åˆ°çš„æ˜¯ 456
            let v := sload(0)

            // åœ¨å†…å­˜ä½ç½® 0x80 å¤„å‚¨å­˜å˜é‡ v åé¢çš„æ•°æ®
            mstore(0x80, v)

            // è¿”å›å€¼:ä» 0x80 ä½ç½®ï¼Œè¿”å› 32ä¸ªå­—èŠ‚
            return(0x80, 32)
        }
    }
}
```

ä¸Šé¢ä¾‹å­ä¸­ï¼Œ`slot #0` æ˜¯ 123ï¼Œ`slot #1` æ˜¯ 456ã€‚

æ³¨æ„: `slot #0` å¯èƒ½æ˜¯å¤šä¸ªçŠ¶æ€å˜é‡å…¬ç”¨çš„ã€‚æ¯”å¦‚æŠŠçŠ¶æ€å˜é‡æ”¹ä¸ºå¦‚ä¸‹ç±»å‹,è¯» `slot #0` ï¼Œè¯¥ä½ç½®å‚¨å­˜äº†`a+b`;

```
uint128 public a = 1;
uint128 public b = 2;
uint256 public c = 456;
```

#### mload(p)

mload æ˜¯ memory loadï¼Œ`mload(key)` æ˜¯ä» memory çš„å“ªä¸ª slot æ¥ loadï¼Œç±»ä¼¼ `sload`ã€‚

- é—®é¢˜ï¼šå†…å­˜æ•°æ® mload æ—¶ä¸ºä»€ä¹ˆä»ç¬¬ 32 ä½å¼€å§‹?
  - ç­”æ¡ˆï¼šå‰ 32 ä¸ªå­—èŠ‚å­˜å‚¨çš„æ˜¯æ•°æ®çš„é•¿åº¦;
  - å‚è€ƒ: https://www.cnblogs.com/wanghui-garcia/p/9592807.html

#### sstore(p, v)

#### mstore(p, v)

ä¸‹é¢ name1 å’Œ name2 éƒ½è¿”å› "Anbang" çš„å­—ç¬¦ä¸²

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    // gas 23471
    bytes6 public name1 = "Anbang"; // 0x416e62616e67

    // gas 21229
    function name2() public pure returns (string memory) {
        assembly {
            // åœ¨ 0x20 å¤„ å‚¨å­˜å€¼ 0x20
            mstore(0x20, 0x20)

            // name1 length = 0x06
            // å‚æ•°1: 0x40 + length = 0x40 + 0x06 => 0x46
            // å‚æ•°2: length + name1  = 0x46 + 0x416e62616e67 => 0x06416e62616e67
            mstore(0x46, 0x06416e62616e67)

            // è¿”å› memory ä» 0x20å¤„ä¹‹åçš„ 0x60 é•¿åº¦çš„æ•°æ®
            return(0x20, 0x60)
        }
    }
}
```

ä¸Šé¢æ˜¯ä»`0x20`å¤„å¼€å§‹å†™æ•°æ®ï¼Œè¿™ä¸ªä½ç½®ä¸æ˜¯å¼ºåˆ¶çš„ï¼Œä½¿ç”¨`0x00`ä¹Ÿå¯ä»¥çš„ã€‚

#### mstore8(p, v)

#### keccak256(p, n)

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    // 0x01
    function solidityKeccak(bytes memory _input) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_input));
    }

    // 0x01
    function assemblyKeccak(bytes memory _input)
        public
        pure
        returns (bytes32 x)
    {
        assembly {
            x := keccak256(add(_input, 0x20), mload(_input))
        }
    }
}
```

#### create(v, p, n)

```
 assembly {
    // create(v,p,n);
    // v æ˜¯ å‘é€çš„ETHå€¼
    // p æ˜¯ å†…å­˜ä¸­æœºå™¨ç å¼€å§‹çš„ä½ç½®
    // n æ˜¯ å†…å­˜ä¸­æœºå™¨ç çš„å¤§å°
    // msg.value ä¸èƒ½ä½¿ç”¨ï¼Œéœ€è¦ç”¨ callvalue()
    adds := create(callvalue(), add(_code, 0x20), mload(_code))
}
```

#### create2(v, p, n, s)

ä¸‹é¢æ˜¯ [UniswapV2Factory](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Factory.sol) ä¸­åˆ›å»º pair æ ¸å¿ƒé€»è¾‘

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Z {
    bytes6 public name1 = "Anbang";
}

contract Demo {
    function addr() public returns (address pair) {
        bytes memory bytecode = type(Z).creationCode;
        // bytes32 salt = keccak256(abi.encodePacked(address(0), address(1)));
        uint256 salt = block.number;
        assembly {
            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)
        }
    }
}
```

### æ“ä½œæ•°æ®/å¤§å°

| æ“ä½œç¬¦å·                | è¿”å›å€¼ | ç‰ˆæœ¬ | è§£é‡Šè¯´æ˜                                                         |
| ----------------------- | ------ | ---- | ---------------------------------------------------------------- |
| msize()                 |        | F    | å†…å­˜å¤§å°ï¼Œå³æœ€å¤§è®¿é—®å†…å­˜ç´¢å¼•                                     |
| pc()                    |        | F    | å½“å‰åœ¨ä»£ç ä¸­çš„ä½ç½®                                               |
| codesize()              |        | F    | å½“å‰åˆçº¦çš„ä»£ç å¤§å° / execution context                           |
| codecopy(t, f, s)       | -      | F    | ä»ä½ç½® f çš„ä»£ç å¤åˆ¶ s ä¸ªå­—èŠ‚åˆ°ä½ç½® t çš„å†…å­˜                      |
| extcodesize(a)          |        | F    | è·å–åœ°å€ a çš„ä»£ç å¤§å°                                            |
| extcodecopy(a, t, f, s) | -      | F    | åƒ codecopy(t, f, s) ä½†åœ¨åœ°å€ a å¤„è·å–ä»£ç                        |
| signextend(i, x)        |        | F    | sign extend from `(i*8+7)`th bit counting from least significant |
| byte(n, x)              |        | F    | x çš„ç¬¬ n ä¸ªå­—èŠ‚ï¼Œè¿™ä¸ªç´¢å¼•æ˜¯ä» 0 å¼€å§‹çš„                           |
| pop(x)                  | -      | F    | ä¸¢å¼ƒå€¼ x                                                         |

#### msize()

å†…å­˜å¤§å°ï¼Œå³æœ€å¤§è®¿é—®å†…å­˜ç´¢å¼•

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    function test() public pure returns (int256) {
        int8 v0 = 1;
        assembly {
            v0 := msize()
        }
        return int256(v0);
    }
}
```

#### pc()

#### codesize()

#### codecopy(t, f, s)

#### extcodesize(a)

#### extcodecopy(a, t, f, s)

#### signextend(i, x)

#### byte(n, x)

#### pop(x)

### call ç›¸å…³

| æ“ä½œç¬¦å·                                     | è¿”å›å€¼ | ç‰ˆæœ¬ | è§£é‡Šè¯´æ˜                                                                                                  |
| -------------------------------------------- | ------ | ---- | --------------------------------------------------------------------------------------------------------- |
| calldataload(p)                              |        | F    | ä»ä½ç½® p å¼€å§‹è°ƒç”¨æ•°æ® (32 bytes)                                                                          |
| calldatasize()                               |        | F    | è°ƒç”¨æ•°æ®çš„å¤§å°ï¼ˆä»¥å­—èŠ‚ä¸ºå•ä½ï¼‰                                                                            |
| calldatacopy(t, f, s)                        | -      | F    | ä»ä½ç½® f çš„ calldata å¤åˆ¶ s ä¸ªå­—èŠ‚åˆ°ä½ç½® t çš„å†…å­˜                                                         |
| call(g, a, v, in, insize, out, outsize)      |        | F    | åœ¨åœ°å€ a è°ƒç”¨åˆçº¦ [See more](#yul-call-return-area)                                                       |
| callcode(g, a, v, in, insize, out, outsize)  |        | F    | ä¸ `call` ç›¸åŒï¼Œä½†ä»…ä½¿ç”¨ a ä¸­çš„ä»£ç ï¼Œå¦åˆ™ç•™åœ¨å½“å‰åˆçº¦çš„ä¸Šä¸‹æ–‡ä¸­ [See more](#yul-call-return-area)         |
| delegatecall(g, a, in, insize, out, outsize) |        | H    | ä¸ `callcode` ç›¸åŒï¼Œä½†ä¹Ÿä¿ç•™ `caller` å’Œ `callvalue` [See more](#yul-call-return-area)                    |
| staticcall(g, a, in, insize, out, outsize)   |        | B    | ä¸ `call(g, a, 0, in, insize, out, outsize)` ç›¸åŒï¼Œä½†ä¸å…è®¸çŠ¶æ€ä¿®æ”¹ ons [See more](#yul-call-return-area) |

### ç»“æŸæ‰§è¡Œ

| æ“ä½œç¬¦å·                | è¿”å›å€¼ | ç‰ˆæœ¬ | è§£é‡Šè¯´æ˜                                                 |
| ----------------------- | ------ | ---- | -------------------------------------------------------- |
| return(p, s)            | -      | F    | ç»“æŸæ‰§è¡Œ, return data mem[pâ€¦(p+s))                       |
| stop()                  | -      | F    | ç»“æŸæ‰§è¡Œ, ç±»ä¼¼ `return(0, 0)`                            |
| revert(p, s)            | -      | B    | ç»“æŸæ‰§è¡Œ, revert state changes, return data mem[pâ€¦(p+s)) |
| selfdestruct(a)         | -      | F    | ç»“æŸæ‰§è¡Œ, destroy current contract and send funds to a   |
| invalid()               | -      | F    | ç»“æŸæ‰§è¡Œ with invalid instruction                        |
| returndatasize()        |        | B    | æœ€åè¿”å›æ•°æ®çš„å¤§å°                                       |
| returndatacopy(t, f, s) | -      | B    | å°† s ä¸ªå­—èŠ‚ä»ä½ç½® f çš„ returndata å¤åˆ¶åˆ°ä½ç½® t çš„ mem    |

### log ä¿¡æ¯

| æ“ä½œç¬¦å·                   | è¿”å›å€¼ | ç‰ˆæœ¬ | è§£é‡Šè¯´æ˜                                             |
| -------------------------- | ------ | ---- | ---------------------------------------------------- |
| log0(p, s)                 | -      | F    | log without topics and data mem[pâ€¦(p+s))             |
| log1(p, s, t1)             | -      | F    | log with topic t1 and data mem[pâ€¦(p+s))              |
| log2(p, s, t1, t2)         | -      | F    | log with topics t1, t2 and data mem[pâ€¦(p+s))         |
| log3(p, s, t1, t2, t3)     | -      | F    | log with topics t1, t2, t3 and data mem[pâ€¦(p+s))     |
| log4(p, s, t1, t2, t3, t4) | -      | F    | log with topics t1, t2, t3, t4 and data mem[pâ€¦(p+s)) |

## ğŸ†— å®æˆ˜åº”ç”¨

### ä¾‹å­ 1:ä¸€ä¸ªæ¼”ç¤º

```
library VectorSum {
    // æ­¤å‡½æ•°æ•ˆç‡è¾ƒä½ï¼Œå› ä¸ºä¼˜åŒ–å™¨å½“å‰æ— æ³•åˆ é™¤æ•°ç»„è®¿é—®ä¸­çš„è¾¹ç•Œæ£€æŸ¥ã€‚
    function sumSolidity(uint256[] memory data)
        public
        pure
        returns (uint256 sum)
    {
        for (uint256 i = 0; i < data.length; ++i) sum += data[i];
    }

    // We know that we only access the array in bounds, so we can avoid the check.
    // 0x20 needs to be added to an array because the first slot contains the
    // array length.
    // æˆ‘ä»¬çŸ¥é“æˆ‘ä»¬åªåœ¨è¾¹ç•Œå†…è®¿é—®æ•°ç»„ï¼Œ
    // æ‰€ä»¥æˆ‘ä»¬å¯ä»¥é¿å…æ£€æŸ¥ã€‚0x20 éœ€è¦æ·»åŠ åˆ°æ•°ç»„ï¼Œå› ä¸ºç¬¬ä¸€ä¸ªæ§½åŒ…å«æ•°ç»„é•¿åº¦ã€‚
    function sumAsm(uint256[] memory data) public pure returns (uint256 sum) {
        for (uint256 i = 0; i < data.length; ++i) {
            assembly {
                sum := add(sum, mload(add(add(data, 0x20), mul(i, 0x20))))
            }
        }
    }

    // Same as above, but accomplish the entire code within inline assembly.
    function sumPureAsm(uint256[] memory data)
        public
        pure
        returns (uint256 sum)
    {
        assembly {
            // Load the length (first 32 bytes)
            let len := mload(data)

            // Skip over the length field.
            //
            // Keep temporary variable so it can be incremented in place.
            //
            // NOTE: incrementing data would result in an unusable
            //       data variable after this assembly block
            let dataElementLocation := add(data, 0x20)

            // Iterate until the bound is not met.
            for {
                let end := add(dataElementLocation, mul(len, 0x20))
            } lt(dataElementLocation, end) {
                dataElementLocation := add(dataElementLocation, 0x20)
            } {
                sum := add(sum, mload(dataElementLocation))
            }
        }
    }
}

```

### ä¾‹å­ 2:è·å–åˆçº¦ä»£ç 

gas ç›¸å·®æ— å‡ ï¼Œé‡ç‚¹çœ‹ä¸€ä¸‹ code çš„èƒŒååŸç†

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract Demo {
    // 24310 gas
    function codeBySolidity(address _addr)
        public
        view
        returns (bytes memory o_code)
    {
        return _addr.code;
    }

    // 24286 gas
    function codeByAssembly(address _addr)
        public
        view
        returns (bytes memory o_code)
    {
        assembly {
            // 1.ä½¿ç”¨ extcodesize è·å–åˆçº¦å†…çš„ä»£ç å¤§å°
            let size := extcodesize(_addr)

            // 2.ä½¿ç”¨ mload åˆ†é…è¾“å‡ºå­—èŠ‚æ•°ç»„
            // ç±»ä¼¼ o_code = new bytesï¼ˆsizeï¼‰
            o_code := mload(0x40)

            // åœ¨ 0x40 çš„ä½ç½®å­˜å…¥æ•°æ®
            //      add(size, 0x20) :
            //              size åŠ  0x20
            //      add(add(size, 0x20), 0x1f)
            //              size åŠ  0x20,å†åŠ  0x1f
            //      not(0x1f)
            //              0x1f çš„æŒ‰ä½é
            //      and(add(add(size, 0x20), 0x1f), not(0x1f))
            //          "size åŠ  0x20,å†åŠ  0x1f" å’Œ "0x1fçš„æŒ‰ä½é" çš„æŒ‰ä½ä¸
            mstore(
                0x40,
                add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f)))
            )

            // æŠŠé•¿åº¦ä¿å­˜åˆ°å†…å­˜ä¸­
            mstore(o_code, size)

            // å®é™…è·å–ä»£ç ï¼Œè¿™éœ€è¦æ±‡ç¼–è¯­è¨€
            extcodecopy(_addr, add(o_code, 0x20), 0, size)
        }
    }
}
```

### ä¾‹å­ 3:è®¡ç®—æ•°å€¼æ•°ç»„çš„å’Œ

```
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

library VectorSum {
    // å› ä¸ºç›®å‰çš„ä¼˜åŒ–å™¨åœ¨è®¿é—®æ•°ç»„æ—¶æ— æ³•ç§»é™¤è¾¹ç•Œæ£€æŸ¥ï¼Œ
    // æ‰€ä»¥è¿™ä¸ªå‡½æ•°çš„æ‰§è¡Œæ•ˆç‡æ¯”è¾ƒä½ã€‚
    function sumSolidity(uint256[] memory _data)
        public
        pure
        returns (uint256 o_sum)
    {
        for (uint256 i = 0; i < _data.length; ++i) o_sum += _data[i];
    }

    // æˆ‘ä»¬åªèƒ½åœ¨æ•°ç»„èŒƒå›´å†…è®¿é—®æ•°ç»„å…ƒç´ ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥åœ¨å†…è”æ±‡ç¼–ä¸­ä¸åšè¾¹ç•Œæ£€æŸ¥ã€‚
    // ç”±äº ABI ç¼–ç ä¸­æ•°ç»„æ•°æ®çš„ç¬¬ä¸€ä¸ªå­—ï¼ˆ32 å­—èŠ‚ï¼‰çš„ä½ç½®ä¿å­˜çš„æ˜¯æ•°ç»„é•¿åº¦ï¼Œ
    // æ‰€ä»¥æˆ‘ä»¬åœ¨è®¿é—®æ•°ç»„å…ƒç´ æ—¶éœ€è¦åŠ å…¥ 0x20 ä½œä¸ºåç§»é‡ã€‚
    function sumAsm(uint256[] memory _data)
        public
        pure
        returns (uint256 o_sum)
    {
        for (uint256 i = 0; i < _data.length; ++i) {
            assembly {
                o_sum := add(o_sum, mload(add(add(_data, 0x20), mul(i, 0x20))))
            }
        }
    }

    // å’Œä¸Šé¢ä¸€æ ·ï¼Œä½†åœ¨å†…è”æ±‡ç¼–å†…å®Œæˆæ•´ä¸ªä»£ç ã€‚
    function sumPureAsm(uint256[] memory _data)
        public
        pure
        returns (uint256 o_sum)
    {
        assembly {
            // å–å¾—æ•°ç»„é•¿åº¦ï¼ˆå–å‰ 32 å­—èŠ‚ï¼‰
            let len := mload(_data)

            // ç•¥è¿‡é•¿åº¦å­—æ®µã€‚
            //
            // ä¿æŒä¸´æ—¶å˜é‡ä»¥ä¾¿å®ƒå¯ä»¥åœ¨åŸåœ°å¢åŠ ã€‚
            //
            // æ³¨æ„ï¼šå¯¹ _data æ•°å€¼çš„å¢åŠ å°†å¯¼è‡´ _data åœ¨è¿™ä¸ªæ±‡ç¼–è¯­å¥å—ä¹‹åä¸å†å¯ç”¨ã€‚
            //      å› ä¸ºæ— æ³•å†åŸºäº _data æ¥è§£æåç»­çš„æ•°ç»„æ•°æ®ã€‚
            let data := add(_data, 0x20)

            // è¿­ä»£åˆ°æ•°ç»„æ•°æ®ç»“æŸ
            for {
                let end := add(data, mul(len, 0x20))
            } lt(data, end) {
                data := add(data, 0x20)
            } {
                o_sum := add(o_sum, mload(data))
            }
        }
    }
}
```

## #ï¸âƒ£ é—®ç­”é¢˜

- Assemblyï¼ˆå†…è”æ±‡ç¼–ï¼‰ä¸æ™®é€š Solidity ä»£ç æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ
  - ä½¿ç”¨å†…è”æ±‡ç¼–ï¼Œå¯ä»¥åœ¨ Solidity æºç¨‹åºä¸­åµŒå…¥æ±‡ç¼–ä»£ç ï¼Œå¯¹ EVM æœ‰æ›´ç»†ç²’åº¦çš„æ§åˆ¶ã€‚
- Assemblyï¼ˆå†…è”æ±‡ç¼–ï¼‰çš„ä½œç”¨ï¼Ÿ
  - å†…è”æ±‡ç¼–ä¸»è¦ç”¨åœ¨ç¼–å†™åº“å‡½æ•°æ—¶å¾ˆæœ‰ç”¨ï¼Œä¸€èˆ¬ç”¨äºå†™å·¥å…·å‡½æ•°ï¼Œæ¯”å¦‚æ¤­åœ†ç­¾åè§£æç­‰ã€‚
- Assemblyï¼ˆå†…è”æ±‡ç¼–ï¼‰çš„å¸¸è§æ–¹æ³•æœ‰ï¼Œä½œç”¨åˆ†åˆ«æ˜¯ä»€ä¹ˆï¼Ÿ
  - `:=`
  - `add`
  - `mload`
  - `mul`
  - `0x20` / `0x40`
- é—®é¢˜ï¼šå†…å­˜æ•°æ® mload æ—¶ä¸ºä»€ä¹ˆä»ç¬¬ 32 ä½å¼€å§‹?
