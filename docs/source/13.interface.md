# 13.interface:æ¥å£

å¾ˆå¤šæ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦è°ƒç”¨å·²ç»éƒ¨ç½²åœ¨é“¾ä¸Šçš„å·²ç»åˆçº¦ï¼Œè¿™æ—¶å€™å¯ä»¥é€šè¿‡æ¥å£åˆçº¦å®ç°éƒ¨åˆ†è°ƒç”¨çš„é€»è¾‘ï¼Œæˆ‘ä»¬åªéœ€è¦å†™ä¸€ä¸ªä¸ä¹‹å¯¹åº”çš„æ¥å£åˆçº¦ï¼Œå°±å¯ä»¥è°ƒç”¨äº†ã€‚

åœ¨ solidity è¯­è¨€ä¸­ï¼Œåªè¦æŸä¸ªåˆçº¦æœ‰å’Œæ¥å£ç§ç›¸åŒçš„å‡½æ•°å£°æ˜ï¼Œå°±å¯ä»¥è¢«æ­¤åˆçº¦æ‰€æ¥å—ã€‚æ¥å£å°±æ˜¯èµ·åˆ°ä¸€ä¸ªæ¡¥æ¥çš„ä½œç”¨ï¼›ç±»ä¼¼æ‰‹æœºçš„æ¥å£ï¼Œåªè¦åŒ¹é…ï¼Œå¯ä»¥è¿›è¡Œå……ç”µï¼Œä¹Ÿå¯ä»¥è¿›è¡Œå¬æ­Œã€‚

`interface` ç±»ä¼¼äº[æŠ½è±¡åˆçº¦](/source/10.inheritance.html#abstract) ï¼Œä½†å®ƒä»¬ä¸èƒ½å®ç°ä»»ä½•åŠŸèƒ½ã€‚è¿˜æœ‰å…¶ä»–é™åˆ¶ã€‚ `interface`å†…çš„å‡½æ•°è¢«éšå¼æ ‡è®°ä¸º`virtual`

## 1ï¸âƒ£ é™åˆ¶

- æ— æ³•å®ç°ä»»ä½•åŠŸèƒ½ï¼Œæ²¡æœ‰å‡½æ•°ä½“ã€‚
  - å¦åˆ™æŠ¥é”™:`Functions in interfaces must be declared external.`
- æ— æ³•ç»§æ‰¿å…¶ä»–åˆçº¦ã€‚(éœ€è¦éªŒè¯ï¼Œæ˜¯å¦å¯ä»¥ç»§æ‰¿æ¥å£ï¼Œæ–‡æ¡£å†…è¯´å¯ä»¥ç»§æ‰¿å…¶ä»–æ¥å£ã€‚)
- æ— æ³•å®šä¹‰æ„é€ å‡½æ•°ã€‚
- æ— æ³•å®šä¹‰çŠ¶æ€å˜é‡ã€‚
- ä¸å¯ä»¥å£°æ˜ä¿®æ”¹å™¨ã€‚
- æ— æ³•å®šä¹‰ç»“æ„ï¼ˆ`strct`ï¼‰ï¼ˆ`0.5.0` ç‰ˆæœ¬å¼€å§‹æ¥å£é‡Œå¯ä»¥æ”¯æŒå£°æ˜ `enum` ç±»å‹ï¼‰ã€‚
- æ‰€æœ‰å£°æ˜çš„å‡½æ•°å¿…é¡»æ˜¯ `external` çš„ï¼Œå°½ç®¡åœ¨åˆçº¦é‡Œå¯ä»¥æ˜¯ public

æ–‡æ¡£è¯´ï¼šå°†æ¥å¯èƒ½ä¼šè§£é™¤è¿™é‡Œçš„æŸäº›é™åˆ¶ã€‚

âš ï¸æ³¨æ„ï¼š interface å¯ä»¥åŸºäºåˆ«çš„ interfaceã€‚æ¯”å¦‚ `interface IERC20Metadata is IERC20{}`,å®šä¹‰ `IERC20Metadata` åŸºäº `IERC20` æ¥å£ã€‚

## 2ï¸âƒ£ å®šä¹‰å’Œä½¿ç”¨

æ¥å£éœ€è¦æœ‰ interface å…³é”®å­—ï¼Œå¹¶ä¸”å†…éƒ¨åªéœ€è¦æœ‰å‡½æ•°çš„å£°æ˜ï¼Œä¸ç”¨å®ç°ã€‚åªè¦æŸåˆçº¦ä¸­æœ‰å’Œè¯æ¥å£ç›¸åŒçš„å‡½æ•°å£°æ˜ï¼Œå°±å¯ä»¥è¢«æ­¤åˆçº¦æ‰€æ¥å—ã€‚è¯­æ³•å¦‚ä¸‹

```
interface æ¥å£å{
    å‡½æ•°å£°æ˜;
}
```

æ¥å£åŸºæœ¬ä¸Šä»…é™äºåˆçº¦ ABI å¯ä»¥è¡¨ç¤ºçš„å†…å®¹ï¼Œå¹¶ä¸” ABI å’Œæ¥å£ä¹‹é—´çš„è½¬æ¢ä¸åº”è¯¥ä¸¢å¤±ä»»ä½•ä¿¡æ¯ã€‚

åœ¨ä¸‹é¢çš„ä¾‹å­ä¸­ï¼Œå®šä¹‰äº† cat åˆçº¦ä»¥åŠ dog åˆçº¦ã€‚ä»–ä»¬éƒ½æœ‰ eat æ–¹æ³•.ä»¥æ­¤ä»–ä»¬éƒ½å¯ä»¥è¢«ä¸Šé¢çš„ animalEat æ¥å£æ‰€æ¥æ”¶ã€‚

### ä½¿ç”¨ä¾‹å­

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Cat {
    uint256 public age;

    function eat() public returns (string memory) {
        age++;
        return "cat eat fish";
    }

    function sleep1() public pure returns (string memory) {
        return "sleep1";
    }
}

contract Dog {
    uint256 public age;

    function eat() public returns (string memory) {
        age += 2;
        return "dog miss you";
    }

    function sleep2() public pure returns (string memory) {
        return "sleep2";
    }
}

interface AnimalEat {
    function eat() external returns (string memory);
}

contract Animal {
    function test(address _addr) external returns (string memory) {
        AnimalEat general = AnimalEat(_addr);
        return general.eat();
    }
}
```

æµ‹è¯•æµç¨‹:

1. éƒ¨ç½² Cat åˆçº¦
2. éƒ¨ç½² Dog åˆçº¦
3. éƒ¨ç½² Animal åˆçº¦
4. è°ƒç”¨ `Animal.test`,å‚æ•°æ˜¯ Cat åˆçº¦åœ°å€
   1. è¿”å› `"string: cat eat fish"`
   2. åœ¨ Cat åˆçº¦å†…æŸ¥çœ‹ `age` è¿”å›çš„æ•°å­—
5. è°ƒç”¨ `Animal.test`,å‚æ•°æ˜¯ Dog åˆçº¦åœ°å€
   1. è¿”å› `"string: dog miss you"`
   2. åœ¨ Dog åˆçº¦å†…æŸ¥çœ‹ `age` è¿”å›çš„æ•°å­—

åœ¨åˆçº¦ Animal ä¸­ï¼Œè°ƒç”¨å‡½æ•° testï¼Œå¦‚æœä¼ é€’çš„æ˜¯éƒ¨ç½²çš„ Cat çš„åˆçº¦åœ°å€ï¼Œé‚£ä¹ˆæˆ‘ä»¬åœ¨è°ƒç”¨æ¥å£çš„ eat æ–¹æ³•æ—¶ï¼Œå®åˆ™è°ƒç”¨äº† Cat åˆçº¦çš„ eat æ–¹æ³•ã€‚ åŒç†ï¼Œå¦‚æœä¼ é€’çš„æ˜¯éƒ¨ç½²çš„ Dog çš„åˆçº¦åœ°å€ï¼Œé‚£ä¹ˆæˆ‘ä»¬åœ¨è°ƒç”¨æ¥å£çš„ eat æ–¹æ³•æ—¶ï¼Œå®åˆ™è°ƒç”¨äº† dog åˆçº¦çš„ eat æ–¹æ³•ã€‚
### éšå¼çš„æ ‡è®°ä¸º`virtual`


å°±åƒç»§æ‰¿å…¶ä»–åˆçº¦ä¸€æ ·ï¼Œåˆçº¦å¯ä»¥ç»§æ‰¿æ¥å£ã€‚æ¥å£ä¸­çš„å‡½æ•°éƒ½ä¼šéšå¼çš„æ ‡è®°ä¸º
`virtual` ï¼Œæ„å‘³ç€ä»–ä»¬ä¼šè¢«é‡å†™å¹¶ä¸éœ€è¦ `override` å…³é”®å­—ã€‚
ä½†æ˜¯ä¸è¡¨ç¤ºé‡å†™ï¼ˆoverridingï¼‰å‡½æ•°å¯ä»¥å†æ¬¡é‡å†™ï¼Œä»…ä»…å½“é‡å†™çš„å‡½æ•°æ ‡è®°ä¸º
`virtual` æ‰å¯ä»¥å†æ¬¡é‡å†™ã€‚

æ¥å£å¯ä»¥ç»§æ‰¿å…¶ä»–çš„æ¥å£ï¼Œéµå¾ªåŒæ ·ç»§æ‰¿è§„åˆ™ã€‚

```
pragma solidity >=0.6.2 <0.9.0;

interface ParentA {
    function test() external returns (uint256);
}

interface ParentB {
    function test() external returns (uint256);
}

interface SubInterface is ParentA, ParentB {
    // å¿…é¡»é‡æ–°å®šä¹‰ test å‡½æ•°ï¼Œä»¥è¡¨ç¤ºå…¼å®¹çˆ¶åˆçº¦å«ä¹‰
    function test() external override(ParentA, ParentB) returns (uint256);
}
```


## 3ï¸âƒ£ å…¨å±€å±æ€§ `type(I).interfaceId`

è¿”å›æ¥å£`I` çš„ bytes4 ç±»å‹çš„æ¥å£ IDï¼Œæ¥å£ ID å‚è€ƒï¼š EIP-165 å®šä¹‰çš„ï¼Œ æ¥å£ ID è¢«å®šä¹‰ä¸º XOR ï¼ˆå¼‚æˆ–ï¼‰ æ¥å£å†…æ‰€æœ‰çš„å‡½æ•°çš„å‡½æ•°é€‰æ‹©å™¨ï¼ˆé™¤ç»§æ‰¿çš„å‡½æ•°ã€‚

## ğŸ†— å®æˆ˜: æ ‡å‡†çš„ ERC20 æ¥å£
### æ ‡å‡†

**é—®é¢˜: å¦‚ä½•åˆ¤æ–­ä¸€ä¸ª Token åˆçº¦æ˜¯å¦ä¸ºæ ‡å‡†çš„ ERC20 åˆçº¦ï¼Ÿ**

- åªè¦å«æœ‰ ERC20 æ¥å£è§„å®šçš„æ‰€æœ‰å†…å®¹ï¼Œå°±ç®—æ ‡å‡†çš„ ERC20 åˆçº¦ã€‚
  - è‡³äºæ–¹æ³•å†…çš„é€»è¾‘æ˜¯å¦‚ä½•å®ç°çš„ï¼Œæ˜¯ä¸åšåˆ¤æ–­ã€‚

### æ ‡å‡† ERC20 æ¥å£

- 1 ä¸ªæˆæƒ
  - `approve`: æˆæƒæŒ‡å®šåœ°å€å¯ä»¥æ“ä½œè°ƒç”¨è€…çš„æœ€å¤§ Token æ•°é‡ã€‚
- 2 ä¸ªäº‹ä»¶
  - `Transfer`
  - `Approval`
- 2 ä¸ªäº¤æ˜“
  - `transfer`: ä»å½“å‰è°ƒç”¨è€…åœ°å€å‘é€æŒ‡å®šæ•°é‡çš„ Token åˆ°æŒ‡å®šåœ°å€ã€‚
    - è¿™æ˜¯ä¸€ä¸ªå†™å…¥æ–¹æ³•ï¼Œæ‰€ä»¥è¿˜ä¼šæŠ›å‡ºä¸€ä¸ª `Transfer` äº‹ä»¶ã€‚
  - `transferFrom`: å½“å‘å¦å¤–ä¸€ä¸ªåˆçº¦åœ°å€å­˜æ¬¾æ—¶ï¼Œå¯¹æ–¹åˆçº¦å¿…é¡»è°ƒç”¨ transferFrom æ‰å¯ä»¥æŠŠ Token æ‹¿åˆ°å®ƒè‡ªå·±çš„åˆçº¦ä¸­ã€‚
- 3 ä¸ªæŸ¥è¯¢
  - `balanceOf`: æŸ¥è¯¢æŒ‡å®šåœ°å€çš„ Token æ•°é‡
  - `totalSupply`: æŸ¥è¯¢å½“å‰åˆçº¦çš„ Token æ€»é‡
  - `allowance`: æŸ¥è¯¢æŒ‡å®šåœ°å€å¯¹å¦å¤–ä¸€ä¸ªåœ°å€çš„å‰©ä½™æˆæƒé¢åº¦


```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

interface IERC20 {
    // 1ä¸ªæˆæƒ
    function approve(address spender, uint256 amount) external returns (bool);

    // 2ä¸ªäº‹ä»¶
    event Transfer(address indexed from, address indexed to, uint256 amount);
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 amount
    );

    // 2ä¸ªäº¤æ˜“
    function transfer(address recipient, uint256 amount)
        external
        returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    // 3ä¸ªæŸ¥è¯¢
    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function allowance(address owner, address spender)
        external
        view
        returns (uint256);
}
```

### ERC20 æ ‡å‡†åˆçº¦å®ç°

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

interface IERC20 {
    // 1ä¸ªæˆæƒ
    function approve(address spender, uint256 amount) external returns (bool);

    // 2ä¸ªäº‹ä»¶
    event Transfer(address indexed from, address indexed to, uint256 amount);
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 amount
    );

    // 2ä¸ªäº¤æ˜“
    function transfer(address recipient, uint256 amount)
        external
        returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    // 3ä¸ªæŸ¥è¯¢
    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function allowance(address owner, address spender)
        external
        view
        returns (uint256);
}

contract ERC20 is IERC20 {
    // çŠ¶æ€å˜é‡
    string public name;
    string public symbol;
    uint8 public immutable decimals;

    address public immutable owner;

    // uint256 public immutable totalSupply; // ä¸å¢åŠ æ€»é‡
    uint256 public totalSupply; // æ€»ä»·æ€»é‡
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    // å‡½æ•°ä¿®æ”¹å™¨
    modifier onlyOwner() {
        require(msg.sender == owner, "not owner");
        _;
    }

    // æ„é€ å‡½æ•°
    constructor(
        string memory _name,
        string memory _symbol,
        uint8 _decimals,
        uint256 _totalSupply
    ) {
        owner = msg.sender;
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply;
        balanceOf[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    // 1ä¸ªæˆæƒ
    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    // 2ä¸ªäº¤æ˜“
    function transfer(address recipient, uint256 amount)
        external
        returns (bool)
    {
        balanceOf[msg.sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool) {
        // msg.sender ä¹Ÿå°±æ˜¯å½“å‰è°ƒç”¨è€…ï¼Œæ˜¯è¢«æ‰¹å‡†è€…
        allowance[sender][msg.sender] -= amount;
        balanceOf[sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }

    // 1ä¸ªé“¸å¸ - éå¿…é¡»
    function mint(uint256 amount) external onlyOwner returns (bool) {
        totalSupply += amount;
        balanceOf[msg.sender] += amount;
        emit Transfer(address(0), msg.sender, amount);
        return true;
    }

    // 1ä¸ªé”€æ¯ - éå¿…é¡»
    function burn(uint256 amount) external returns (bool) {
        totalSupply -= amount;
        balanceOf[msg.sender] -= amount;
        emit Transfer(msg.sender, address(0), amount);
        return true;
    }
}
```

## ğŸ†— å®æˆ˜: ERC721 åˆçº¦

### åœºæ™¯è¯´æ˜

### åˆçº¦ä»£ç 

### æµ‹è¯•åˆçº¦

## ğŸ†— å®æˆ˜: ERC1155 åˆçº¦

## ğŸ†— å®æˆ˜: ERC3525 åˆçº¦

### å¯¹æ¯”

![](/_static/13/01.jpeg)

![](/_static/13/02.jpeg)

![](/_static/13/03.jpeg)

![](/_static/13/04.jpeg)


## ğŸ†— å®æˆ˜:è·å…°æ‹å–

### åŸç†

æ‹å– NFT

- éœ€è¦æ‹¥æœ‰ NFT
- éœ€è¦åœ¨ NFT åˆçº¦å†…å¯¹æ‹å–åˆçº¦åš `aoorove`;

### ä»£ç 

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

interface IERC721 {
    function transferFrom(
        address _form,
        address _to,
        uint256 _nftId
    ) external;
}

contract DutchAuction {
    uint256 private immutable duration;

    address payable public immutable seller;

    IERC721 public immutable nft;
    uint256 public immutable nftId;

    uint256 public immutable startingPrice;
    uint256 public immutable startAt;
    uint256 public immutable endAt;
    uint256 public immutable discountRate;

    constructor(
        address _nft,
        uint256 _nftId,
        uint256 _startingPrice,
        uint256 _duration,
        uint256 _discountRate
    ) {
        require(
            _startingPrice >= _duration * _discountRate,
            "starting price < discount"
        );
        seller = payable(msg.sender);
        nft = IERC721(_nft); // éœ€è¦ IERC721 è¿›è¡Œè½¬æ¢
        nftId = _nftId;
        duration = _duration;
        startingPrice = _startingPrice;
        discountRate = _discountRate;

        startAt = block.timestamp;
        endAt = block.timestamp + _duration;
    }

    // è·å–ä»·æ ¼
    function getPrice() public view returns (uint256) {
        uint256 timeElapsed = block.timestamp - startAt;
        uint256 discount = discountRate * timeElapsed;
        return startingPrice - discount;
    }

    // è´­ä¹°
    function buy() external payable {
        // æ‰“åŒ…æ—¶é—´éœ€è¦åœ¨æ‹å–æˆªæ­¢ä¹‹å‰
        require(block.timestamp < endAt, "Auction has ended");

        uint256 price = getPrice();
        require(msg.value >= price, "Insufficient amount");
        nft.transferFrom(seller, msg.sender, nftId);

        // å¦‚æœæœ‰å¤šä½™çš„é’±ï¼Œéœ€è¦æŠŠé’±é€€ä¼šè´­ä¹°è€…è´¦å·(æäº¤æ—¶é—´å’Œæ‰“åŒ…ç¡®è®¤æ—¶é—´ä¸ä¸€è‡´)
        uint256 refund = msg.value - price;
        if (refund > 0) {
            payable(msg.sender).transfer(refund);
        }
        selfdestruct(seller);
    }
}
```


## ğŸ†— å®æˆ˜:è‹±å¼æ‹å–

### åŸç†

æ‹å– NFT

- éœ€è¦æ‹¥æœ‰ NFT
- éœ€è¦åœ¨ NFT åˆçº¦å†…å¯¹æ‹å–åˆçº¦åš `aoorove`;

### ä»£ç 

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

interface IERC721 {
    function transferFrom(
        address _form,
        address _to,
        uint256 _nftId
    ) external;
}

// TODO: åŒºå—æ³¨é‡Šä¿¡æ¯ï¼Œå¯ä»¥é€‰æ‹©åœ¨åˆçº¦å®Œæˆååˆ é™¤
contract HelloComrades {
    /*
     * ========================================
     * State Variables
     * ========================================
     */

    address payable public immutable seller;

    IERC721 public immutable nft;
    uint256 public immutable nftId;

    uint32 public endAt; // ç»“æŸæ—¶é—´
    bool public started; // å¼€å§‹æ—¶é—´
    bool public ended; // ç»“æŸæ—¶é—´

    uint256 public highestBid; // æœ€é«˜å‡ºä»·
    address public highestBider; // æœ€é«˜å‡ºä»·äºº
    mapping(address => uint256) public bids; // é™¤äº†æœ€é«˜å‡ºä»·å¤–çš„æ‰€æœ‰å‡ºä»·äºº

    /*
     * ========================================
     * Events
     * ========================================
     */
    event Start();
    event End(address highestBider, uint256 amount);
    event Bid(address indexed sender, uint256 amount);
    event Withdraw(address indexed sender, uint256 amount);

    /*
     * ========================================
     * Modifier
     * ========================================
     */

    /*
     * ========================================
     * Errors
     * ========================================
     */

    /*
     * ========================================
     * Constructor
     * ========================================
     */
    constructor(
        address _nft,
        uint256 _nftId,
        uint256 _startingPrice
    ) {
        seller = payable(msg.sender);
        nft = IERC721(_nft); // éœ€è¦ IERC721 è¿›è¡Œè½¬æ¢
        nftId = _nftId;
        highestBid = _startingPrice;
    }

    /*
     * ========================================
     * Functions
     * ========================================
     */
    function start() external {
        require(msg.sender == seller, "Nor seller");
        require(!started, "started");

        started = true;
        endAt = uint32(block.timestamp + 60);
        nft.transferFrom(seller, address(this), nftId);

        emit Start();
    }

    function bid() external payable {
        require(started, "Not started"); //éœ€è¦æ—¶é—´å·²ç»å¼€å§‹
        require(block.timestamp < endAt, "ended"); // éœ€è¦æ—¶é—´è¿˜æ²¡æœ‰è¿‡æœŸ
        require(msg.value > highestBid, "invalid price"); // éœ€è¦é«˜äºä¸Šæ¬¡å‡ºä»·

        // æŠŠä¸Šä¸€æ¬¡æœ€é«˜å‡ºä»·å’Œå‡ºä»·äººå†™å…¥è´¦æœ¬
        if (highestBider != address(0)) {
            bids[highestBider] += highestBid;
        }

        // æ›´æ–°æœ€é«˜å‡ºä»·/æœ€é«˜å‡ºä»·äºº
        highestBid = msg.value;
        highestBider = msg.sender;
        emit Bid(msg.sender, msg.value);
    }

    // å–å›è‡ªå·±çš„å‡ºä»·
    function withdraw() external {
        uint256 bal = bids[msg.sender];
        require(bal > 0, "No amount can be refunded");
        bids[msg.sender] = 0; //ä¸ºäº†é˜²æ­¢æ¼æ´å‘ç”Ÿï¼Œéœ€è¦å…ˆæŠŠçŠ¶æ€ä¿®æ”¹
        payable(msg.sender).transfer(bal);
        emit Withdraw(msg.sender, bal);
    }

    // ç»“æŸæ‹å–;ä¸éœ€è¦åšèº«ä»½ç¡®è®¤ï¼Œå› ä¸ºéœ€è¦åšçš„äº‹æƒ…æ˜¯å›ºå®šçš„ï¼Œ
    // èƒ½ä¸åšèº«ä»½åˆ¤æ–­å°±ä¸éœ€è¦åšï¼Œå¯ä»¥èŠ‚çœGas
    function end() external {
        require(started, "Not started"); // éœ€è¦å·²ç»å¼€å§‹
        require(!ended, "is ended"); // éœ€è¦è¿˜æ²¡æœ‰ç»“æŸ
        require(block.timestamp >= endAt, "auction in progress");
        ended = true;

        if (highestBider != address(0)) {
            // å¦‚æœæœ‰äººå‡ºä»·åˆ™å°† NFT ç»™æœ€é«˜å‡ºä»·äººï¼Œæœ€é«˜ä»·æ ¼ç»™é”€å”®è€…
            nft.transferFrom(address(this), highestBider, nftId);
            seller.transfer(highestBid);
        } else {
            // å¦‚æœæ²¡æœ‰äººå‡ºä»·ï¼Œåˆ™NFTåŸè·¯è¿”è¿˜ç»™é”€å”®è€…
            nft.transferFrom(address(this), seller, nftId);
        }
        emit End(highestBider, highestBid);
    }

    /*
     * ========================================
     * Helper
     * ========================================
     */
    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}
```

### æµ‹è¯•æµç¨‹

- éƒ¨ç½² ERC721 ,NFT åˆçº¦åœ°å€æ˜¯ `nftContractAds`
- ç»™ `address1` min ä¸€ä¸ª ID æ˜¯ 1 çš„ NFT
- éƒ¨ç½²è‹±å¼æ‹å–åˆçº¦ `EnglishAuction`
  - è¾“å…¥ NFT åˆçº¦åœ°å€
  - è¾“å…¥ NFT ID å·
  - èµ·æ‹ä»·æ ¼:8
- åœ¨ `nftContractAds` ä¸­ approve `EnglishAuction` , ID ä¸º 1 çš„ NFT
- ä½¿ç”¨ `address2` å‡ºä»· 1,æŸ¥çœ‹æ˜¯å¦è¿”å›é”™è¯¯ `Not started`
- æŸ¥çœ‹åˆçº¦çš„çŠ¶æ€
  - `started`
  - `ended`
  - `getBalance`
  - `seller`
  - `nft`
  - `nftId`
  - `highestBider`
  - `highestBid`
- ä½¿ç”¨ `address1` å‡ºä»· 1, å¼€å§‹æ‹å–åˆçº¦ï¼ŒæŸ¥çœ‹æ˜¯å¦è¿”å›é”™è¯¯ `invalid price`
- å†æ¬¡æŸ¥çœ‹åˆçº¦çš„çŠ¶æ€
- ä½¿ç”¨ `address2` å‡ºä»· 10
- ä½¿ç”¨ `address3` å‡ºä»· 20
- ä½¿ç”¨ `address2` å‡ºä»· 50
- æŸ¥è¯¢ `address2` å¯é€€æ¢çš„ä¸»å¸
- æŸ¥è¯¢ `address3` å¯é€€æ¢çš„ä¸»å¸
- ç»“æŸæ‹å–
- ä½¿ç”¨ `address2` å–å›ä¸»å¸
- ä½¿ç”¨ `address3` å–å›ä¸»å¸


## #ï¸âƒ£ é—®ç­”é¢˜

- `interface` æœ‰å“ªäº›é™åˆ¶ï¼Ÿ
  - æ— æ³•å®ç°ä»»ä½•åŠŸèƒ½ï¼Œæ²¡æœ‰å‡½æ•°ä½“ã€‚
    - å¦åˆ™æŠ¥é”™:`Functions in interfaces must be declared external.`
  - æ— æ³•ç»§æ‰¿å…¶ä»–åˆçº¦ã€‚(éœ€è¦éªŒè¯ï¼Œæ˜¯å¦å¯ä»¥ç»§æ‰¿æ¥å£ï¼Œæ–‡æ¡£å†…è¯´å¯ä»¥ç»§æ‰¿å…¶ä»–æ¥å£ã€‚)
  - æ— æ³•å®šä¹‰æ„é€ å‡½æ•°ã€‚
  - æ— æ³•å®šä¹‰çŠ¶æ€å˜é‡ã€‚
  - ä¸å¯ä»¥å£°æ˜ä¿®æ”¹å™¨ã€‚
  - æ— æ³•å®šä¹‰ç»“æ„ï¼ˆ`strct`ï¼‰ï¼ˆ`0.5.0` ç‰ˆæœ¬å¼€å§‹æ¥å£é‡Œå¯ä»¥æ”¯æŒå£°æ˜ `enum` ç±»å‹ï¼‰ã€‚
  - æ‰€æœ‰å£°æ˜çš„å‡½æ•°å¿…é¡»æ˜¯ `external` çš„ï¼Œå°½ç®¡åœ¨åˆçº¦é‡Œå¯ä»¥æ˜¯ public
  - æ–‡æ¡£è¯´ï¼šå°†æ¥å¯èƒ½ä¼šè§£é™¤è¿™é‡Œçš„æŸäº›é™åˆ¶ã€‚
- `interface` çš„æ„ä¹‰ï¼Ÿ
  - æˆ‘ä»¬éœ€è¦è°ƒç”¨å·²ç»éƒ¨ç½²åœ¨é“¾ä¸Šçš„å·²ç»åˆçº¦ï¼Œè¿™æ—¶å€™å¯ä»¥é€šè¿‡æ¥å£åˆçº¦å®ç°éƒ¨åˆ†è°ƒç”¨çš„é€»è¾‘ï¼Œæˆ‘ä»¬åªéœ€è¦å†™ä¸€ä¸ªä¸ä¹‹å¯¹åº”çš„æ¥å£åˆçº¦ï¼Œå°±å¯ä»¥è°ƒç”¨äº†ã€‚
- `interface` å’Œ `abstract`(æŠ½è±¡åˆçº¦)æœ‰å•¥åŒºåˆ«ï¼Ÿåˆ†åˆ«ç”¨åœ¨ä»€ä¹ˆåœ°æ–¹ï¼Ÿ
- `interface` çš„å¸¸è§ç”¨æ³•æœ‰å“ªäº›ï¼Ÿ
  - åˆ¶å®šæ ‡å‡†ï¼Œæ¯”å¦‚æœ€æˆåŠŸçš„ `ERC20` æ¥å£åˆçº¦
- `ERC20` æ ‡å‡†æ¥å£æœ‰å“ªäº›å†…å®¹ï¼Ÿ
  - 1ä¸ªæˆæƒï¼ˆapproveï¼‰
  - 2ä¸ªäº‹ä»¶ï¼ˆTransfer/Approvalï¼‰
  - 2ä¸ªäº¤æ˜“ï¼ˆtransfer/transferFromï¼‰
  - 3ä¸ªæŸ¥è¯¢ï¼ˆtotalSupply/balanceOf/allowanceï¼‰
  - åªè¦æ»¡è¶³ä»¥ä¸Šæ¥å£çš„éƒ½æ˜¯ERC20æ ‡å‡†åˆçº¦ï¼Œå¾ˆå¤šåœŸç‹—åˆçº¦å–œæ¬¢åœ¨transferå†…é­”æ”¹ã€‚
- å…¨å±€å±æ€§ `type(I).interfaceId` ä½¿ç”¨ï¼Ÿ
  - æ²¡å•¥ç”¨ï¼Œå°±æ˜¯ç±»ä¼¼å‡½æ•°ç­¾åä¸€æ ·çš„åå…­è¿›åˆ¶æ•°æ®ï¼ŒçŸ¥é“æœ‰è¿™ä¸ªå±æ€§å°±å¥½ã€‚
- èŠä¸€èŠ `interface`
  - å°±åƒç»§æ‰¿å…¶ä»–åˆçº¦ä¸€æ ·ï¼Œåˆçº¦å¯ä»¥ç»§æ‰¿æ¥å£ã€‚æ¥å£ä¸­çš„å‡½æ•°éƒ½ä¼šéšå¼çš„æ ‡è®°ä¸º
`virtual` ï¼Œæ„å‘³ç€ä»–ä»¬ä¼šè¢«é‡å†™å¹¶ä¸éœ€è¦ `override` å…³é”®å­—ã€‚
ä½†æ˜¯ä¸è¡¨ç¤ºé‡å†™ï¼ˆoverridingï¼‰å‡½æ•°å¯ä»¥å†æ¬¡é‡å†™ï¼Œä»…ä»…å½“é‡å†™çš„å‡½æ•°æ ‡è®°ä¸º
`virtual` æ‰å¯ä»¥å†æ¬¡é‡å†™ã€‚