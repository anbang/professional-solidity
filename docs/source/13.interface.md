# 13.interface:æ¥å£

å¾ˆå¤šæ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦è°ƒç”¨å·²ç»éƒ¨ç½²åœ¨é“¾ä¸Šçš„å·²ç»åˆçº¦ï¼Œè¿™æ—¶å€™å¯ä»¥é€šè¿‡æ¥å£åˆçº¦å®ç°éƒ¨åˆ†è°ƒç”¨çš„é€»è¾‘ï¼Œæˆ‘ä»¬åªéœ€è¦å†™ä¸€ä¸ªä¸ä¹‹å¯¹åº”çš„æ¥å£åˆçº¦ï¼Œå°±å¯ä»¥è°ƒç”¨äº†ã€‚

åœ¨ solidity è¯­è¨€ä¸­ï¼Œåªè¦æŸä¸ªåˆçº¦æœ‰å’Œæ¥å£ç§ç›¸åŒçš„å‡½æ•°å£°æ˜ï¼Œå°±å¯ä»¥è¢«æ­¤åˆçº¦æ‰€æ¥å—ã€‚æ¥å£å°±æ˜¯èµ·åˆ°ä¸€ä¸ªæ¡¥æ¥çš„ä½œç”¨ï¼›ç±»ä¼¼æ‰‹æœºçš„æ¥å£ï¼Œåªè¦åŒ¹é…ï¼Œå¯ä»¥è¿›è¡Œå……ç”µï¼Œä¹Ÿå¯ä»¥è¿›è¡Œå¬æ­Œã€‚

`interface` ç±»ä¼¼äº[æŠ½è±¡åˆçº¦](/source/10.inheritance.html#abstract) ï¼Œä½†å®ƒä»¬ä¸èƒ½å®ç°ä»»ä½•åŠŸèƒ½ã€‚è¿˜æœ‰å…¶ä»–é™åˆ¶ã€‚ `interface`å†…çš„å‡½æ•°è¢«éšå¼æ ‡è®°ä¸º`virtual`

## 1ï¸âƒ£ é™åˆ¶

- æ— æ³•å®ç°ä»»ä½•åŠŸèƒ½ï¼Œæ²¡æœ‰å‡½æ•°ä½“ã€‚
- æ— æ³•å®šä¹‰æ„é€ å‡½æ•°ã€‚
- æ— æ³•å®šä¹‰çŠ¶æ€å˜é‡ã€‚
- æ— æ³•å®šä¹‰ç»“æ„ï¼ˆ`strct`ï¼‰ï¼ˆ`0.5.0` ç‰ˆæœ¬å¼€å§‹æ¥å£é‡Œå¯ä»¥æ”¯æŒå£°æ˜ `enum` ç±»å‹ï¼‰ã€‚
- ä¸å¯ä»¥å£°æ˜ä¿®æ”¹å™¨ã€‚
- æ‰€æœ‰å£°æ˜çš„å‡½æ•°å¿…é¡»æ˜¯ `external` çš„ï¼Œå°½ç®¡åœ¨åˆçº¦é‡Œå¯ä»¥æ˜¯ public
  - æ–‡æ¡£è¯´ï¼šå°†æ¥å¯èƒ½ä¼šè§£é™¤è¿™é‡Œçš„æŸäº›é™åˆ¶ã€‚

âš ï¸ æ³¨æ„ï¼š interface å¯ä»¥åŸºäºåˆ«çš„ interfaceï¼Œå¯ä»¥ç»§æ‰¿å…¶ä»–åˆçº¦ã€‚æ¯”å¦‚ `interface IERC20Metadata is IERC20{}`,å®šä¹‰ `IERC20Metadata` åŸºäº `IERC20` æ¥å£ã€‚

## 2ï¸âƒ£ å®šä¹‰å’Œä½¿ç”¨

æ¥å£éœ€è¦æœ‰ interface å…³é”®å­—ï¼Œå¹¶ä¸”å†…éƒ¨åªéœ€è¦æœ‰å‡½æ•°çš„å£°æ˜ï¼Œä¸ç”¨å®ç°ã€‚åªè¦æŸåˆçº¦ä¸­æœ‰å’Œè¯æ¥å£ç›¸åŒçš„å‡½æ•°å£°æ˜ï¼Œå°±å¯ä»¥è¢«æ­¤åˆçº¦æ‰€æ¥å—ã€‚è¯­æ³•å¦‚ä¸‹

```
interface æ¥å£å{
    å‡½æ•°å£°æ˜;
}
```

æ¥å£åŸºæœ¬ä¸Šä»…é™äºåˆçº¦ ABI å¯ä»¥è¡¨ç¤ºçš„å†…å®¹ï¼Œå¹¶ä¸” ABI å’Œæ¥å£ä¹‹é—´çš„è½¬æ¢ä¸åº”è¯¥ä¸¢å¤±ä»»ä½•ä¿¡æ¯ã€‚

åœ¨ä¸‹é¢çš„ä¾‹å­ä¸­ï¼Œå®šä¹‰äº† cat åˆçº¦ä»¥åŠ dog åˆçº¦ã€‚ä»–ä»¬éƒ½æœ‰ eat æ–¹æ³•.ä»¥æ­¤ä»–ä»¬éƒ½å¯ä»¥è¢«ä¸Šé¢çš„ animalEat æ¥å£æ‰€æ¥æ”¶ã€‚

### ä½¿ç”¨ä¾‹å­

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Cat {
    uint256 public age;

    function eat() public returns (string memory) {
        age++;
        return "cat eat fish";
    }

    function sleep1() public pure returns (string memory) {
        return "sleep1";
    }
}

contract Dog {
    uint256 public age;

    function eat() public returns (string memory) {
        age += 2;
        return "dog miss you";
    }

    function sleep2() public pure returns (string memory) {
        return "sleep2";
    }
}

interface AnimalEat {
    function eat() external returns (string memory);
}

contract Animal {
    function test(address _addr) external returns (string memory) {
        AnimalEat general = AnimalEat(_addr);
        return general.eat();
    }
}
```

æµ‹è¯•æµç¨‹:

1. éƒ¨ç½² Cat åˆçº¦
2. éƒ¨ç½² Dog åˆçº¦
3. éƒ¨ç½² Animal åˆçº¦
4. è°ƒç”¨ `Animal.test`,å‚æ•°æ˜¯ Cat åˆçº¦åœ°å€
   1. è¿”å› `"string: cat eat fish"`
   2. åœ¨ Cat åˆçº¦å†…æŸ¥çœ‹ `age` è¿”å›çš„æ•°å­—
5. è°ƒç”¨ `Animal.test`,å‚æ•°æ˜¯ Dog åˆçº¦åœ°å€
   1. è¿”å› `"string: dog miss you"`
   2. åœ¨ Dog åˆçº¦å†…æŸ¥çœ‹ `age` è¿”å›çš„æ•°å­—

åœ¨åˆçº¦ Animal ä¸­ï¼Œè°ƒç”¨å‡½æ•° testï¼Œå¦‚æœä¼ é€’çš„æ˜¯éƒ¨ç½²çš„ Cat çš„åˆçº¦åœ°å€ï¼Œé‚£ä¹ˆæˆ‘ä»¬åœ¨è°ƒç”¨æ¥å£çš„ eat æ–¹æ³•æ—¶ï¼Œå®åˆ™è°ƒç”¨äº† Cat åˆçº¦çš„ eat æ–¹æ³•ã€‚ åŒç†ï¼Œå¦‚æœä¼ é€’çš„æ˜¯éƒ¨ç½²çš„ Dog çš„åˆçº¦åœ°å€ï¼Œé‚£ä¹ˆæˆ‘ä»¬åœ¨è°ƒç”¨æ¥å£çš„ eat æ–¹æ³•æ—¶ï¼Œå®åˆ™è°ƒç”¨äº† dog åˆçº¦çš„ eat æ–¹æ³•ã€‚

### éšå¼çš„æ ‡è®°ä¸º`virtual`

å°±åƒç»§æ‰¿å…¶ä»–åˆçº¦ä¸€æ ·ï¼Œåˆçº¦å¯ä»¥ç»§æ‰¿æ¥å£ã€‚æ¥å£ä¸­çš„å‡½æ•°éƒ½ä¼šéšå¼çš„æ ‡è®°ä¸º
`virtual` ï¼Œæ„å‘³ç€ä»–ä»¬ä¼šè¢«é‡å†™å¹¶ä¸éœ€è¦ `override` å…³é”®å­—ã€‚
ä½†æ˜¯ä¸è¡¨ç¤ºé‡å†™ï¼ˆoverridingï¼‰å‡½æ•°å¯ä»¥å†æ¬¡é‡å†™ï¼Œä»…ä»…å½“é‡å†™çš„å‡½æ•°æ ‡è®°ä¸º
`virtual` æ‰å¯ä»¥å†æ¬¡é‡å†™ã€‚

æ¥å£å¯ä»¥ç»§æ‰¿å…¶ä»–çš„æ¥å£ï¼Œéµå¾ªåŒæ ·ç»§æ‰¿è§„åˆ™ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

interface ParentA {
    function test() external returns (uint256);
}

interface ParentB {
    function test() external returns (uint256);
}

interface SubInterface is ParentA, ParentB {
    // å¿…é¡»é‡æ–°å®šä¹‰ test å‡½æ•°ï¼Œä»¥è¡¨ç¤ºå…¼å®¹çˆ¶åˆçº¦å«ä¹‰
    function test() external override(ParentA, ParentB) returns (uint256);
}
```

## 3ï¸âƒ£ å…¨å±€å±æ€§ `type(I).interfaceId`

è¿”å›æ¥å£`I` çš„ bytes4 ç±»å‹çš„æ¥å£ IDï¼Œæ¥å£ ID å‚è€ƒï¼š EIP-165 å®šä¹‰çš„ï¼Œ æ¥å£ ID è¢«å®šä¹‰ä¸º XOR ï¼ˆå¼‚æˆ–ï¼‰ æ¥å£å†…æ‰€æœ‰çš„å‡½æ•°çš„å‡½æ•°é€‰æ‹©å™¨ï¼ˆé™¤ç»§æ‰¿çš„å‡½æ•°ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

interface ParentA {
    function test() external returns (uint256);
}

contract Demo {
    function interfaceId() public pure returns (bytes4) {
        return type(ParentA).interfaceId;
    }
}
```

## 4ï¸âƒ£ ERC20 æ ‡å‡†

### æ ‡å‡†

**é—®é¢˜: å¦‚ä½•åˆ¤æ–­ä¸€ä¸ª Token åˆçº¦æ˜¯å¦ä¸ºæ ‡å‡†çš„ ERC20 åˆçº¦ï¼Ÿ**

- åªè¦å«æœ‰ ERC20 æ¥å£è§„å®šçš„æ‰€æœ‰å†…å®¹ï¼Œå°±ç®—æ ‡å‡†çš„ ERC20 åˆçº¦ã€‚
  - è‡³äºæ–¹æ³•å†…çš„é€»è¾‘æ˜¯å¦‚ä½•å®ç°çš„ï¼Œæ˜¯ä¸åšåˆ¤æ–­ã€‚

è¯¦æƒ…å‚è€ƒ: https://eips.ethereum.org/EIPS/eip-20

### æ ‡å‡† ERC20 æ¥å£

- 3 ä¸ªæŸ¥è¯¢
  - `balanceOf`: æŸ¥è¯¢æŒ‡å®šåœ°å€çš„ Token æ•°é‡
  - `totalSupply`: æŸ¥è¯¢å½“å‰åˆçº¦çš„ Token æ€»é‡
  - `allowance`: æŸ¥è¯¢æŒ‡å®šåœ°å€å¯¹å¦å¤–ä¸€ä¸ªåœ°å€çš„å‰©ä½™æˆæƒé¢åº¦
- 2 ä¸ªäº¤æ˜“
  - `transfer`: ä»å½“å‰è°ƒç”¨è€…åœ°å€å‘é€æŒ‡å®šæ•°é‡çš„ Token åˆ°æŒ‡å®šåœ°å€ã€‚
    - è¿™æ˜¯ä¸€ä¸ªå†™å…¥æ–¹æ³•ï¼Œæ‰€ä»¥è¿˜ä¼šæŠ›å‡ºä¸€ä¸ª `Transfer` äº‹ä»¶ã€‚
  - `transferFrom`: å½“å‘å¦å¤–ä¸€ä¸ªåˆçº¦åœ°å€å­˜æ¬¾æ—¶ï¼Œå¯¹æ–¹åˆçº¦å¿…é¡»è°ƒç”¨ transferFrom æ‰å¯ä»¥æŠŠ Token æ‹¿åˆ°å®ƒè‡ªå·±çš„åˆçº¦ä¸­ã€‚
- 2 ä¸ªäº‹ä»¶
  - `Transfer`
  - `Approval`
- 1 ä¸ªæˆæƒ
  - `approve`: æˆæƒæŒ‡å®šåœ°å€å¯ä»¥æ“ä½œè°ƒç”¨è€…çš„æœ€å¤§ Token æ•°é‡ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

interface IERC20 {
    // 1ä¸ªæˆæƒ
    function approve(address spender, uint256 amount) external returns (bool);

    // 2ä¸ªäº‹ä»¶
    event Transfer(address indexed from, address indexed to, uint256 amount);
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 amount
    );

    // 2ä¸ªäº¤æ˜“
    function transfer(address recipient, uint256 amount)
        external
        returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    // 3ä¸ªæŸ¥è¯¢
    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function allowance(address owner, address spender)
        external
        view
        returns (uint256);
}
```

### ERC20 æ ‡å‡†åˆçº¦å®ç°

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

interface IERC20 {
    // 1ä¸ªæˆæƒ
    function approve(address spender, uint256 amount) external returns (bool);

    // 2ä¸ªäº‹ä»¶
    event Transfer(address indexed from, address indexed to, uint256 amount);
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 amount
    );

    // 2ä¸ªäº¤æ˜“
    function transfer(address recipient, uint256 amount)
        external
        returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    // 3ä¸ªæŸ¥è¯¢
    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function allowance(address owner, address spender)
        external
        view
        returns (uint256);
}

contract ERC20 is IERC20 {
    // çŠ¶æ€å˜é‡
    string public name;
    string public symbol;
    uint8 public immutable decimals;

    address public immutable owner;

    // uint256 public immutable totalSupply; // ä¸å¢åŠ æ€»é‡
    uint256 public totalSupply; // æ€»ä»·æ€»é‡
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    // å‡½æ•°ä¿®æ”¹å™¨
    modifier onlyOwner() {
        require(msg.sender == owner, "not owner");
        _;
    }

    // æ„é€ å‡½æ•°
    constructor(
        string memory _name,
        string memory _symbol,
        uint8 _decimals,
        uint256 _totalSupply
    ) {
        owner = msg.sender;
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply;
        balanceOf[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    // 1ä¸ªæˆæƒ
    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    // 2ä¸ªäº¤æ˜“
    function transfer(address recipient, uint256 amount)
        external
        returns (bool)
    {
        balanceOf[msg.sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool) {
        // msg.sender ä¹Ÿå°±æ˜¯å½“å‰è°ƒç”¨è€…ï¼Œæ˜¯è¢«æ‰¹å‡†è€…
        allowance[sender][msg.sender] -= amount;
        balanceOf[sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }

    // 1ä¸ªé“¸å¸ - éå¿…é¡»
    function mint(uint256 amount) external onlyOwner returns (bool) {
        totalSupply += amount;
        balanceOf[msg.sender] += amount;
        emit Transfer(address(0), msg.sender, amount);
        return true;
    }

    // 1ä¸ªé”€æ¯ - éå¿…é¡»
    function burn(uint256 amount) external returns (bool) {
        totalSupply -= amount;
        balanceOf[msg.sender] -= amount;
        emit Transfer(msg.sender, address(0), amount);
        return true;
    }

    // è½¬ç§» owner æƒé™ç­‰å…¶ä»–ä¸€äº›æ“ä½œå‡æ˜¯çœ‹å„è‡ªä¸šåŠ¡ï¼Œéå¿…éœ€çš„
}
```

## 5ï¸âƒ£ ERC721 æ ‡å‡†

å‚è€ƒèµ„æ–™:

- https://eips.ethereum.org/EIPS/eip-721
- https://ethereum.org/zh/developers/docs/standards/tokens/erc-721/

### åœºæ™¯è¯´æ˜

éåŒè´¨åŒ–ä»£å¸ï¼ˆNFTï¼‰ç”¨äºä»¥å”¯ä¸€çš„æ–¹å¼æ ‡è¯†æŸäººæˆ–è€…æŸç‰©ã€‚ æ­¤ç±»å‹çš„ä»£å¸å¯ä»¥è¢«å®Œç¾åœ°ç”¨äºå‡ºå”®ä¸‹åˆ—ç‰©å“çš„å¹³å°ï¼šæ”¶è—å“ã€å¯†é’¥ã€å½©ç¥¨ã€éŸ³ä¹ä¼šåº§ä½ç¼–å·ã€ä½“è‚²æ¯”èµ›ç­‰ã€‚ è¿™ç§ç±»å‹çš„ä»£å¸æœ‰ç€æƒŠäººçš„æ½œåŠ›ï¼Œå› æ­¤å®ƒéœ€è¦ä¸€ä¸ªé€‚å½“çš„æ ‡å‡†ã€‚ERC-721 å°±æ˜¯ä¸ºè§£å†³è¿™ä¸ªé—®é¢˜è€Œæ¥ï¼

æ‰€æœ‰ NFTs éƒ½æœ‰ä¸€ä¸ª `uint256` å˜é‡ï¼Œåä¸º `tokenId`ï¼Œæ‰€ä»¥å¯¹äºä»»ä½• ERC-721 åˆçº¦ï¼Œè¿™å¯¹å€¼ `contract address, tokenId` å¿…é¡»æ˜¯å…¨å±€å”¯ä¸€çš„ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œå»ä¸­å¿ƒåŒ–åº”ç”¨ç¨‹åºå¯ä»¥æœ‰ä¸€ä¸ªâ€œè½¬æ¢å™¨â€ï¼Œ ä½¿ç”¨ tokenId ä½œä¸ºè¾“å…¥å¹¶è¾“å‡ºä¸€äº›å¾ˆé…·çš„äº‹ç‰©å›¾åƒï¼Œä¾‹å¦‚åƒµå°¸ã€æ­¦å™¨ã€æŠ€èƒ½æˆ–ç¥å¥‡çš„å°çŒ«å’ªï¼

### åˆçº¦ä»£ç 

```
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev ERC165 æ ‡å‡†çš„æ¥å£ https://eips.ethereum.org/EIPS/eip-165
 * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified
 */
interface IERC165 {
    /// @notice æŸ¥è¯¢åˆçº¦æ˜¯å¦å®ç°æ¥å£
    /// @param interfaceID ERC-165 ä¸­æŒ‡å®šçš„æ¥å£æ ‡è¯†ç¬¦
    /// @dev æ¥å£æ ‡è¯†åœ¨ ERC-165 ä¸­æŒ‡å®šã€‚æ­¤åŠŸèƒ½éœ€è¦ä½äº 30,000 gasã€‚
    /// @return å¦‚æœåˆçº¦å®ç°äº† interfaceID ä¸” interfaceID ä¸æ˜¯ 0xffffffffï¼Œåˆ™ä¸º trueï¼Œå¦åˆ™ä¸º false
    function supportsInterface(bytes4 interfaceID) external view returns (bool);
}

/// @title ERC-721 Non-Fungible Token Standard
/// @dev See https://eips.ethereum.org/EIPS/eip-721
///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.
interface IERC721 is IERC165 {
    /**
     @dev å½“ä»»ä½• NFT çš„æ‰€æœ‰æƒé€šè¿‡ä»»ä½•å½¢å¼å‘ç”Ÿå˜åŒ–æ—¶ï¼Œéœ€è¦è§¦å‘è¯¥äº‹ä»¶ã€‚
     å½“ NFT åˆ›å»ºï¼ˆ`from` == 0ï¼‰å’Œé”€æ¯ï¼ˆ`to` == 0ï¼‰æ—¶ä¼šè§¦å‘æ­¤äº‹ä»¶ã€‚
     ä¾‹å¤–æƒ…å†µï¼šåœ¨åˆçº¦åˆ›å»ºæœŸé—´ï¼Œå¯ä»¥åˆ›å»ºå’Œåˆ†é…ä»»æ„æ•°é‡çš„ NFTï¼Œè€Œä¸ä¼šå‘å‡º Transferã€‚
     åœ¨ä»»ä½•å½¢å¼çš„èµ„äº§è½¬ç§»æ—¶ï¼Œè¯¥ NFTå¦‚æœæœ‰æ‰¹å‡†åœ°å€å°†é‡ç½®ä¸ºæ— ã€‚
    */
    event Transfer(
        address indexed _from,
        address indexed _to,
        uint256 indexed _tokenId
    );

    /**
     * å½“ NFT çš„æ‰¹å‡†åœ°å€è¢«æ›´æ”¹æˆ–é‡æ–°ç¡®è®¤æ—¶ï¼Œå®ƒä¼šå‘å‡ºã€‚
     * é›¶åœ°å€è¡¨ç¤ºæ²¡æœ‰æ‰¹å‡†çš„åœ°å€ã€‚
     * å½“ Transfer äº‹ä»¶å‘å‡ºæ—¶ï¼Œè¿™ä¹Ÿè¡¨æ˜è¯¥ NFT å¦‚æœæœ‰æ‰¹å‡†åœ°å€è¢«é‡ç½®ä¸ºæ— ã€‚
     */
    event Approval(
        address indexed _owner,
        address indexed _approved,
        uint256 indexed _tokenId
    );

    /// @dev å½“ä¸ºæ‰€æœ‰è€…å¯ç”¨æˆ–ç¦ç”¨æ“ä½œå‘˜æ—¶ï¼Œå®ƒä¼šå‘å‡ºã€‚ è¿è¥è€…å¯ä»¥ç®¡ç†æ‰€æœ‰è€…çš„æ‰€æœ‰ NFTã€‚
    event ApprovalForAll(
        address indexed _owner,
        address indexed _operator,
        bool _approved
    );

    /// @notice æ‰€æœ‰è€…çš„ NFT æ•°é‡
    /// @dev åˆ†é…ç»™é›¶åœ°å€çš„ NFT è¢«è®¤ä¸ºæ˜¯æ— æ•ˆçš„ï¼Œå¹¶ä¸”è¯¥å‡½æ•°æŠ›å‡ºæœ‰å…³é›¶åœ°å€çš„æŸ¥è¯¢ã€‚
    /// @param _owner æŸ¥è¯¢ä½™é¢çš„åœ°å€
    /// @return `_owner` æ‹¥æœ‰çš„ NFT æ•°é‡ï¼Œå¯èƒ½ä¸ºé›¶
    function balanceOf(address _owner) external view returns (uint256);

    /// @notice æ‰¾åˆ° NFT çš„æ‰€æœ‰è€…
    /// @dev åˆ†é…ç»™é›¶åœ°å€çš„ NFT è¢«è®¤ä¸ºæ˜¯æ— æ•ˆçš„ï¼Œå¹¶ä¸”å¯¹å®ƒä»¬çš„æŸ¥è¯¢ç¡®å®ä¼šæŠ›å‡ºå¼‚å¸¸ã€‚
    /// @param _tokenId NFT çš„æ ‡è¯†ç¬¦
    /// @return NFTæ‰€æœ‰è€…çš„åœ°å€
    function ownerOf(uint256 _tokenId) external view returns (address);

    /// @notice å°† NFT çš„æ‰€æœ‰æƒä»ä¸€ä¸ªåœ°å€è½¬ç§»åˆ°å¦ä¸€ä¸ªåœ°å€
    /// @dev Throws unless `msg.sender` is the current owner, an authorized
    ///  operator, or the approved address for this NFT. Throws if `_from` is
    ///  not the current owner. Throws if `_to` is the zero address. Throws if
    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function
    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls
    ///  `onERC721Received` on `_to` and throws if the return value is not
    ///  `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.
    /// @param _from NFTçš„å½“å‰æ‰€æœ‰è€…
    /// @param _to æ–° owner
    /// @param _tokenId è½¬ç§»çš„ NFT
    /// @param data æ²¡æœ‰æŒ‡å®šæ ¼å¼çš„é™„åŠ æ•°æ®ï¼Œåœ¨è°ƒç”¨ _to æ—¶å‘é€
    function safeTransferFrom(
        address _from,
        address _to,
        uint256 _tokenId,
        bytes calldata data
    ) external payable;

    /// @notice å°† NFT çš„æ‰€æœ‰æƒä»ä¸€ä¸ªåœ°å€è½¬ç§»åˆ°å¦ä¸€ä¸ªåœ°å€
    /// @dev è¿™ä¸å…·æœ‰é¢å¤–æ•°æ®å‚æ•°çš„å…¶ä»–å‡½æ•°çš„å·¥ä½œæ–¹å¼ç›¸åŒï¼Œåªæ˜¯æ­¤å‡½æ•°åªæ˜¯å°†æ•°æ®è®¾ç½®ä¸ºâ€œâ€ã€‚
    /// @param _from NFTçš„å½“å‰æ‰€æœ‰è€…
    /// @param _to æ–° owner
    /// @param _tokenId è½¬ç§»çš„ NFT
    function safeTransferFrom(
        address _from,
        address _to,
        uint256 _tokenId
    ) external payable;

    /// @notice è½¬ç§» NFT çš„æ‰€æœ‰æƒâ€”â€”è°ƒç”¨è€…æœ‰è´£ä»»ç¡®è®¤ `_to` èƒ½å¤Ÿæ¥æ”¶ NFTSï¼Œå¦åˆ™å®ƒä»¬å¯èƒ½ä¼šæ°¸ä¹…ä¸¢å¤±
    /// @dev Throws unless `msg.sender` is the current owner, an authorized
    ///  operator, or the approved address for this NFT. Throws if `_from` is
    ///  not the current owner. Throws if `_to` is the zero address. Throws if
    ///  `_tokenId` is not a valid NFT.
    /// @param _from NFTçš„å½“å‰æ‰€æœ‰è€…
    /// @param _to æ–° owner
    /// @param _tokenId è½¬ç§»çš„ NFT
    function transferFrom(
        address _from,
        address _to,
        uint256 _tokenId
    ) external payable;

    /// @notice æ›´æ”¹æˆ–é‡ç”³ NFT çš„æ‰¹å‡†åœ°å€
    /// @dev The zero address indicates there is no approved address.
    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized
    ///  operator of the current owner.
    /// @param _approved æ–°æ‰¹å‡†çš„ NFT æ§åˆ¶å™¨
    /// @param _tokenId NFT æ‰¹å‡†
    function approve(address _approved, uint256 _tokenId) external payable;

    /// @notice å¯ç”¨æˆ–ç¦ç”¨å¯¹ç¬¬ä¸‰æ–¹ï¼ˆâ€œæ“ä½œå‘˜â€ï¼‰çš„æ‰¹å‡†ä»¥ç®¡ç†æ‰€æœ‰ `msg.sender` çš„èµ„äº§
    /// @dev å‘å‡º ApprovalForAll äº‹ä»¶ã€‚ åˆåŒå¿…é¡»å…è®¸æ¯ä¸ªæ‰€æœ‰è€…æœ‰å¤šä¸ªæ“ä½œå‘˜ã€‚
    /// @param _operator æ·»åŠ åˆ°æˆæƒè¿è¥å•†é›†ä¸­çš„åœ°å€
    /// @param _approved å¦‚æœè¿è¥å•†è·å¾—æ‰¹å‡†ï¼Œåˆ™ä¸º Trueï¼Œå¦‚æœæ’¤æ¶ˆæ‰¹å‡†ï¼Œåˆ™ä¸º false
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice è·å–å•ä¸ª NFT çš„è®¤å¯åœ°å€
    /// @dev å¦‚æœ _tokenId ä¸æ˜¯æœ‰æ•ˆçš„ NFTï¼Œåˆ™æŠ›å‡ºã€‚
    /// @param _tokenId NFTå¯»æ‰¾æ‰¹å‡†çš„åœ°å€
    /// @return æ­¤ NFT çš„æ‰¹å‡†åœ°å€ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä¸ºé›¶åœ°å€
    function getApproved(uint256 _tokenId) external view returns (address);

    /// @notice æŸ¥è¯¢ä¸€ä¸ªåœ°å€æ˜¯å¦æ˜¯å¦ä¸€ä¸ªåœ°å€çš„æˆæƒæ“ä½œå‘˜
    /// @param _owner æ‹¥æœ‰ NFT çš„åœ°å€
    /// @param _operator ä»£è¡¨æ‰€æœ‰è€…çš„åœ°å€
    /// @return å¦‚æœ _operator æ˜¯ _owner çš„æ‰¹å‡†è¿ç®—ç¬¦ï¼Œåˆ™ä¸ºçœŸï¼Œå¦åˆ™ä¸ºå‡
    function isApprovedForAll(address _owner, address _operator)
        external
        view
        returns (bool);
}
```

## 6ï¸âƒ£ ERC1155 æ ‡å‡†

å‚è€ƒèµ„æ–™:

- https://eips.ethereum.org/EIPS/eip-1155
- https://ethereum.org/zh/developers/docs/standards/tokens/erc-1155/

### åœºæ™¯è¯´æ˜

ç”¨äºå¤šç§ä»£å¸ç®¡ç†çš„åˆçº¦æ ‡å‡†æ¥å£ã€‚å•ä¸ªéƒ¨ç½²çš„åˆçº¦å¯ä»¥åŒ…æ‹¬åŒè´¨åŒ–ä»£å¸ã€éåŒè´¨åŒ–ä»£å¸æˆ–å…¶ä»–é…ç½®ï¼ˆå¦‚åŠåŒè´¨åŒ–ä»£å¸ï¼‰çš„ä»»ä½•ç»„åˆã€‚

å®ƒçš„ç›®çš„å¾ˆå•çº¯ï¼Œå°±æ˜¯åˆ›å»ºä¸€ä¸ªæ™ºèƒ½åˆçº¦æ¥å£ï¼Œå¯ä»¥ä»£è¡¨å’Œæ§åˆ¶ä»»ä½•æ•°é‡çš„åŒè´¨åŒ–å’ŒéåŒè´¨åŒ–ä»£å¸ç±»å‹ã€‚ è¿™æ ·ä¸€æ¥ï¼ŒERC-1155 ä»£å¸å°±å…·æœ‰ä¸ ERC-20 å’Œ ERC-721 ä»£å¸ç›¸åŒçš„åŠŸèƒ½ï¼Œç”šè‡³å¯ä»¥åŒæ—¶ä½¿ç”¨è¿™ä¸¤è€…çš„åŠŸèƒ½ã€‚ è€Œæœ€é‡è¦çš„æ˜¯ï¼Œå®ƒèƒ½æ”¹å–„è¿™ä¸¤ç§æ ‡å‡†çš„åŠŸèƒ½ï¼Œä½¿å…¶æ›´æœ‰æ•ˆç‡ï¼Œå¹¶çº æ­£ ERC-20 å’Œ ERC-721 æ ‡å‡†ä¸Šæ˜æ˜¾çš„å®æ–½é”™è¯¯ã€‚

### åˆçº¦ä»£ç 

```
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev ERC165 æ ‡å‡†çš„æ¥å£ https://eips.ethereum.org/EIPS/eip-165
 * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified
 */
interface IERC165 {
    /// @notice æŸ¥è¯¢åˆçº¦æ˜¯å¦å®ç°æ¥å£
    /// @param interfaceID ERC-165 ä¸­æŒ‡å®šçš„æ¥å£æ ‡è¯†ç¬¦
    /// @dev æ¥å£æ ‡è¯†åœ¨ ERC-165 ä¸­æŒ‡å®šã€‚æ­¤åŠŸèƒ½éœ€è¦ä½äº 30,000 gasã€‚
    /// @return å¦‚æœåˆçº¦å®ç°äº† interfaceID ä¸” interfaceID ä¸æ˜¯ 0xffffffffï¼Œåˆ™ä¸º trueï¼Œå¦åˆ™ä¸º false
    function supportsInterface(bytes4 interfaceID) external view returns (bool);
}

/**
    @title ERC-1155 Multi Token Standard
    @dev See https://eips.ethereum.org/EIPS/eip-1155
    Note: The ERC-165 identifier for this interface is 0xd9b67a26.
 */
interface IERC1155 is IERC165 {
    /**
        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred,
        including zero value transfers as well as minting or burning (see "Safe Transfer Rules" section of the standard).
        The `_operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).
        The `_from` argument MUST be the address of the holder whose balance is decreased.
        The `_to` argument MUST be the address of the recipient whose balance is increased.
        The `_id` argument MUST be the token type being transferred.
        The `_value` argument MUST be the number of tokens the holder balance is decreased by and match what the recipient balance is increased by.
        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).
        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).
    */
    event TransferSingle(
        address indexed _operator,
        address indexed _from,
        address indexed _to,
        uint256 _id,
        uint256 _value
    );

    /**
        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred,
        including zero value transfers as well as minting or burning (see "Safe Transfer Rules" section of the standard).
        The `_operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).
        The `_from` argument MUST be the address of the holder whose balance is decreased.
        The `_to` argument MUST be the address of the recipient whose balance is increased.
        The `_ids` argument MUST be the list of tokens being transferred.
        The `_values` argument MUST be the list of number of tokens (matching the list and order of tokens specified in _ids)
        the holder balance is decreased by and match what the recipient balance is increased by.
        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).
        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).
    */
    event TransferBatch(
        address indexed _operator,
        address indexed _from,
        address indexed _to,
        uint256[] _ids,
        uint256[] _values
    );

    /**
        @dev å¿…é¡»åœ¨æ‰¹å‡†ç¬¬äºŒæ–¹/è¿è¥å•†åœ°å€ç®¡ç†æ‰€æœ‰è€…åœ°å€çš„æ‰€æœ‰ä»¤ç‰Œæ—¶å¯ç”¨æˆ–ç¦ç”¨ï¼ˆæ²¡æœ‰äº‹ä»¶å‡å®šç¦ç”¨ï¼‰
    */
    event ApprovalForAll(
        address indexed _owner,
        address indexed _operator,
        bool _approved
    );

    /**
        @dev å¿…é¡»åœ¨ä¸ºä»¤ç‰Œ ID æ›´æ–° URI æ—¶å‘å‡ºã€‚
        URI åœ¨ RFC 3986 ä¸­å®šä¹‰ã€‚
        URI å¿…é¡»æŒ‡å‘ç¬¦åˆâ€œERC-1155 å…ƒæ•°æ® URI JSON æ¨¡å¼â€çš„ JSON æ–‡ä»¶ã€‚
    */
    event URI(string _value, uint256 indexed _id);

    /**
        @notice Transfers `_value` amount of an `_id` from the `_from` address
                to the `_to` address specified (with safety call).
        @dev Caller must be approved to manage the tokens being transferred
        out of the `_from` account (see "Approval" section of the standard).
        MUST revert if `_to` is the zero address.
        MUST revert if balance of holder for token `_id` is lower than the `_value` sent.
        MUST revert on any other error.
        MUST emit the `TransferSingle` event to reflect the balance change (see "Safe Transfer Rules" section of the standard).
        After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so,
        it MUST call `onERC1155Received` on `_to` and act appropriately (see "Safe Transfer Rules" section of the standard).
        @param _from    Source address
        @param _to      Target address
        @param _id      ID of the token type
        @param _value   Transfer amount
        @param _data    Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`
    */
    function safeTransferFrom(
        address _from,
        address _to,
        uint256 _id,
        uint256 _value,
        bytes calldata _data
    ) external;

    /**
        @notice å°† `_ids` çš„ `_values` æ•°é‡ä» `_from` åœ°å€è½¬ç§»åˆ°æŒ‡å®šçš„ `_to` åœ°å€ï¼ˆä½¿ç”¨å®‰å…¨è°ƒç”¨ï¼‰ã€‚
        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see "Approval" section of the standard).
        MUST revert if `_to` is the zero address.
        MUST revert if length of `_ids` is not the same as length of `_values`.
        MUST revert if any of the balance(s) of the holder(s) for token(s) in `_ids` is lower than the respective amount(s) in `_values` sent to the recipient.
        MUST revert on any other error.
        MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see "Safe Transfer Rules" section of the standard).
        Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).
        After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so,
        it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see "Safe Transfer Rules" section of the standard).
        @param _from    Source address
        @param _to      Target address
        @param _ids     æ¯ä¸ªä»¤ç‰Œç±»å‹çš„ IDï¼ˆé¡ºåºå’Œé•¿åº¦å¿…é¡»åŒ¹é… _values æ•°ç»„ï¼‰
        @param _values  æ¯ç§ä»£å¸ç±»å‹çš„è½¬è´¦é‡‘é¢ï¼ˆé¡ºåºå’Œé•¿åº¦å¿…é¡»åŒ¹é… _ids æ•°ç»„ï¼‰
        @param _data    æ²¡æœ‰æŒ‡å®šæ ¼å¼çš„é¢å¤–æ•°æ®ï¼Œå¿…é¡»åœ¨è°ƒç”¨ _to ä¸Šçš„ `ERC1155TokenReceiver` é’©å­æ—¶åŸå°ä¸åŠ¨åœ°å‘é€
    */
    function safeBatchTransferFrom(
        address _from,
        address _to,
        uint256[] calldata _ids,
        uint256[] calldata _values,
        bytes calldata _data
    ) external;

    /**
        @notice è·å–å¸æˆ·ä»¤ç‰Œçš„ä½™é¢ã€‚
        @param _owner  ä»¤ç‰ŒæŒæœ‰è€…çš„åœ°å€
        @param _id     ID of the token
        @return        è¯·æ±‚çš„ä»£å¸ç±»å‹çš„æ‰€æœ‰è€…ä½™é¢
     */
    function balanceOf(address _owner, uint256 _id)
        external
        view
        returns (uint256);

    /**
        @notice è·å–å¤šä¸ªè´¦æˆ·/ä»£å¸å¯¹çš„ä½™é¢
        @param _owners ä»£å¸æŒæœ‰è€…çš„åœ°å€
        @param _ids    ID of the tokens
        @return        è¯·æ±‚çš„ä»¤ç‰Œç±»å‹çš„ _owner ä½™é¢ï¼ˆå³æ¯ä¸ª (owner, id) å¯¹çš„ä½™é¢ï¼‰
     */
    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids)
        external
        view
        returns (uint256[] memory);

    /**
        @notice å¯ç”¨æˆ–ç¦ç”¨å¯¹ç¬¬ä¸‰æ–¹ï¼ˆâ€œæ“ä½œå‘˜â€ï¼‰çš„æ‰¹å‡†ä»¥ç®¡ç†æ‰€æœ‰è°ƒç”¨è€…çš„ä»¤ç‰Œã€‚
        @dev å¿…é¡»åœ¨æˆåŠŸæ—¶å‘å‡º ApprovalForAll äº‹ä»¶ã€‚
        @param _operator  æ·»åŠ åˆ°æˆæƒè¿è¥å•†é›†ä¸­çš„åœ°å€
        @param _approved  å¦‚æœè¿è¥å•†è·å¾—æ‰¹å‡†ï¼Œåˆ™ä¸º Trueï¼Œå¦‚æœæ’¤æ¶ˆæ‰¹å‡†ï¼Œåˆ™ä¸º false
    */
    function setApprovalForAll(address _operator, bool _approved) external;

    /**
        @notice æŸ¥è¯¢ç»™å®šæ‰€æœ‰è€…çš„æ“ä½œå‘˜çš„æ‰¹å‡†çŠ¶æ€ã€‚
        @param _owner     The owner of the tokens
        @param _operator  æˆæƒæ“ä½œå‘˜çš„åœ°å€
        @return           å¦‚æœæ“ä½œå‘˜è¢«æ‰¹å‡†åˆ™ä¸ºçœŸï¼Œå¦åˆ™ä¸ºå‡
    */
    function isApprovedForAll(address _owner, address _operator)
        external
        view
        returns (bool);
}
```

## 7ï¸âƒ£ ERC3525 æ ‡å‡†

æ¯ä¸ªç¬¦åˆ EIP-3525 çš„åˆçº¦éƒ½å¿…é¡»å®ç° EIP-3525ã€EIP-721 å’Œ EIP-165 æ¥å£

å‚è€ƒèµ„æ–™:

- https://eips.ethereum.org/EIPS/eip-3525

### åœºæ™¯è¯´æ˜

æè¿°ä¸€ç»„å…·æœ‰ç›¸åŒç±»å‹ï¼Œä½†æ˜¯æœ‰è½»å¾®ä¸åŒçš„ä¸œè¥¿ã€‚æ¯”å¦‚ç›¸åŒçš„ 100 å…ƒäººæ°‘å¸ï¼Œä¸€å…± 100 å¼ ï¼Œæ¯ä¸€å¼ éƒ½æ˜¯ä»·å€¼ 100 çš„çº¸å¸ï¼Œå¤§éƒ¨åˆ†çš„é˜²ä¼ªç­‰ç­‰éƒ½ä¸åŒï¼Œä½†æ˜¯æ¯ä¸€å¼ éƒ½ç¼–å·éƒ½ä¸åŒã€‚

### åˆçº¦ä»£ç 

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title EIP-3525 Semi-Fungible Token Standard
 * Note: the EIP-165 identifier for this interface is 0xd5358140.
 */

interface IERC3525  /* is IERC165, IERC721 */ {
    /**
     * @dev MUST emit when value of a token is transferred to another token with the same slot,
     *  including zero value transfers (_value == 0) as well as transfers when tokens are created
     *  (`_fromTokenId` == 0) or destroyed (`_toTokenId` == 0).
     * @param _fromTokenId The token id to transfer value from
     * @param _toTokenId The token id to transfer value to
     * @param _value The transferred value
     */
    event TransferValue(
        uint256 indexed _fromTokenId,
        uint256 indexed _toTokenId,
        uint256 _value
    );

    /**
     * @dev MUST emit when the approval value of a token is set or changed.
     * @param _tokenId The token to approve
     * @param _operator The operator to approve for
     * @param _value The maximum value that `_operator` is allowed to manage
     */
    event ApprovalValue(
        uint256 indexed _tokenId,
        address indexed _operator,
        uint256 _value
    );

    /**
     * @dev MUST emit when the slot of a token is set or changed.
     * @param _tokenId The token of which slot is set or changed
     * @param _oldSlot The previous slot of the token
     * @param _newSlot The updated slot of the token
     */
    event SlotChanged(
        uint256 indexed _tokenId,
        uint256 indexed _oldSlot,
        uint256 indexed _newSlot
    );

    /**
     * @notice Get the number of decimals the token uses for value - e.g. 6, means the user
     *  representation of the value of a token can be calculated by dividing it by 1,000,000.
     *  Considering the compatibility with third-party wallets, this function is defined as
     *  `valueDecimals()` instead of `decimals()` to avoid conflict with EIP-20 tokens.
     * @return The number of decimals for value
     */
    function valueDecimals() external view returns (uint8);

    /**
     * @notice Get the value of a token.
     * @param _tokenId The token for which to query the balance
     * @return The value of `_tokenId`
     */
    function balanceOf(uint256 _tokenId) external view returns (uint256);

    /**
     * @notice Get the slot of a token.
     * @param _tokenId The identifier for a token
     * @return The slot of the token
     */
    function slotOf(uint256 _tokenId) external view returns (uint256);

    /**
     * @notice Allow an operator to manage the value of a token, up to the `_value`.
     * @dev MUST revert unless caller is the current owner, an authorized operator, or the approved
     *  address for `_tokenId`.
     *  MUST emit the ApprovalValue event.
     * @param _tokenId The token to approve
     * @param _operator The operator to be approved
     * @param _value The maximum value of `_toTokenId` that `_operator` is allowed to manage
     */
    function approve(
        uint256 _tokenId,
        address _operator,
        uint256 _value
    ) external payable;

    /**
     * @notice Get the maximum value of a token that an operator is allowed to manage.
     * @param _tokenId The token for which to query the allowance
     * @param _operator The address of an operator
     * @return The current approval value of `_tokenId` that `_operator` is allowed to manage
     */
    function allowance(uint256 _tokenId, address _operator)
        external
        view
        returns (uint256);

    /**
     * @notice Transfer value from a specified token to another specified token with the same slot.
     * @dev Caller MUST be the current owner, an authorized operator or an operator who has been
     *  approved the whole `_fromTokenId` or part of it.
     *  MUST revert if `_fromTokenId` or `_toTokenId` is zero token id or does not exist.
     *  MUST revert if slots of `_fromTokenId` and `_toTokenId` do not match.
     *  MUST revert if `_value` exceeds the balance of `_fromTokenId` or its allowance to the
     *  operator.
     *  MUST emit `TransferValue` event.
     * @param _fromTokenId The token to transfer value from
     * @param _toTokenId The token to transfer value to
     * @param _value The transferred value
     */
    function transferFrom(
        uint256 _fromTokenId,
        uint256 _toTokenId,
        uint256 _value
    ) external payable;

    /**
     * @notice è½¬ç§»å°†æŒ‡å®šæ•°é‡çš„ä»£å¸åˆ°æ–°åœ°å€ã€‚è°ƒç”¨è€…åº”ç¡®è®¤ _to èƒ½å¤Ÿæ¥æ”¶ EIP-3525 èµ„äº§ã€‚
     * @dev This function MUST create a new EIP-3525 token with the same slot for `_to`,
     *  or find an existing token with the same slot owned by `_to`, to receive the transferred value.
     *  MUST revert if `_fromTokenId` is zero token id or does not exist.
     *  MUST revert if `_to` is zero address.
     *  MUST revert if `_value` exceeds the balance of `_fromTokenId` or its allowance to the
     *  operator.
     *  MUST emit `Transfer` and `TransferValue` events.
     * @param _fromTokenId The token to transfer value from
     * @param _to The address to transfer value to
     * @param _value The transferred value
     * @return ID of the token which receives the transferred value
     */
    function transferFrom(
        uint256 _fromTokenId,
        address _to,
        uint256 _value
    ) external payable returns (uint256);
}
```

### æ‰©å±•

æ›´å¤šå…³äº 3525 åè®®çš„å†…å®¹ï¼Œå‚è€ƒ https://cloud.tencent.com/developer/article/2155201

## 8ï¸âƒ£ å››ç§ä»£å¸æ ‡å‡†çš„å¯¹æ¯”

![](/_static/13/01.jpeg)

![](/_static/13/02.jpeg)

![](/_static/13/03.jpeg)

![](/_static/13/04.jpeg)

## ğŸ†— å®æˆ˜:è·å…°æ‹å–

### åŸç†

æ‹å– NFT

- éœ€è¦æ‹¥æœ‰ NFT
- éœ€è¦åœ¨ NFT åˆçº¦å†…å¯¹æ‹å–åˆçº¦åš `aoorove`;

### ä»£ç 

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

interface IERC721 {
    function transferFrom(
        address _form,
        address _to,
        uint256 _nftId
    ) external;
}

contract DutchAuction {
    uint256 private immutable duration;

    address payable public immutable seller;

    IERC721 public immutable nft;
    uint256 public immutable nftId;

    uint256 public immutable startingPrice;
    uint256 public immutable startAt;
    uint256 public immutable endAt;
    uint256 public immutable discountRate;

    constructor(
        address _nft,
        uint256 _nftId,
        uint256 _startingPrice,
        uint256 _duration,
        uint256 _discountRate
    ) {
        require(
            _startingPrice >= _duration * _discountRate,
            "starting price < discount"
        );
        seller = payable(msg.sender);
        nft = IERC721(_nft); // éœ€è¦ IERC721 è¿›è¡Œè½¬æ¢
        nftId = _nftId;
        duration = _duration;
        startingPrice = _startingPrice;
        discountRate = _discountRate;

        startAt = block.timestamp;
        endAt = block.timestamp + _duration;
    }

    // è·å–ä»·æ ¼
    function getPrice() public view returns (uint256) {
        uint256 timeElapsed = block.timestamp - startAt;
        uint256 discount = discountRate * timeElapsed;
        return startingPrice - discount;
    }

    // è´­ä¹°
    function buy() external payable {
        // æ‰“åŒ…æ—¶é—´éœ€è¦åœ¨æ‹å–æˆªæ­¢ä¹‹å‰
        require(block.timestamp < endAt, "Auction has ended");

        uint256 price = getPrice();
        require(msg.value >= price, "Insufficient amount");
        nft.transferFrom(seller, msg.sender, nftId);

        // å¦‚æœæœ‰å¤šä½™çš„é’±ï¼Œéœ€è¦æŠŠé’±é€€ä¼šè´­ä¹°è€…è´¦å·(æäº¤æ—¶é—´å’Œæ‰“åŒ…ç¡®è®¤æ—¶é—´ä¸ä¸€è‡´)
        uint256 refund = msg.value - price;
        if (refund > 0) {
            payable(msg.sender).transfer(refund);
        }
        selfdestruct(seller);
    }
}
```

## ğŸ†— å®æˆ˜:è‹±å¼æ‹å–

### åŸç†

æ‹å– NFT

- éœ€è¦æ‹¥æœ‰ NFT
- éœ€è¦åœ¨ NFT åˆçº¦å†…å¯¹æ‹å–åˆçº¦åš `aoorove`;

### ä»£ç 

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

interface IERC721 {
    function transferFrom(
        address _form,
        address _to,
        uint256 _nftId
    ) external;
}

// TODO: åŒºå—æ³¨é‡Šä¿¡æ¯ï¼Œå¯ä»¥é€‰æ‹©åœ¨åˆçº¦å®Œæˆååˆ é™¤
contract HelloComrades {
    /*
     * ========================================
     * State Variables
     * ========================================
     */

    address payable public immutable seller;

    IERC721 public immutable nft;
    uint256 public immutable nftId;

    uint32 public endAt; // ç»“æŸæ—¶é—´
    bool public started; // å¼€å§‹æ—¶é—´
    bool public ended; // ç»“æŸæ—¶é—´

    uint256 public highestBid; // æœ€é«˜å‡ºä»·
    address public highestBider; // æœ€é«˜å‡ºä»·äºº
    mapping(address => uint256) public bids; // é™¤äº†æœ€é«˜å‡ºä»·å¤–çš„æ‰€æœ‰å‡ºä»·äºº

    /*
     * ========================================
     * Events
     * ========================================
     */
    event Start();
    event End(address highestBider, uint256 amount);
    event Bid(address indexed sender, uint256 amount);
    event Withdraw(address indexed sender, uint256 amount);

    /*
     * ========================================
     * Modifier
     * ========================================
     */

    /*
     * ========================================
     * Errors
     * ========================================
     */

    /*
     * ========================================
     * Constructor
     * ========================================
     */
    constructor(
        address _nft,
        uint256 _nftId,
        uint256 _startingPrice
    ) {
        seller = payable(msg.sender);
        nft = IERC721(_nft); // éœ€è¦ IERC721 è¿›è¡Œè½¬æ¢
        nftId = _nftId;
        highestBid = _startingPrice;
    }

    /*
     * ========================================
     * Functions
     * ========================================
     */
    function start() external {
        require(msg.sender == seller, "Nor seller");
        require(!started, "started");

        started = true;
        endAt = uint32(block.timestamp + 60);
        nft.transferFrom(seller, address(this), nftId);

        emit Start();
    }

    function bid() external payable {
        require(started, "Not started"); //éœ€è¦æ—¶é—´å·²ç»å¼€å§‹
        require(block.timestamp < endAt, "ended"); // éœ€è¦æ—¶é—´è¿˜æ²¡æœ‰è¿‡æœŸ
        require(msg.value > highestBid, "invalid price"); // éœ€è¦é«˜äºä¸Šæ¬¡å‡ºä»·

        // æŠŠä¸Šä¸€æ¬¡æœ€é«˜å‡ºä»·å’Œå‡ºä»·äººå†™å…¥è´¦æœ¬
        if (highestBider != address(0)) {
            bids[highestBider] += highestBid;
        }

        // æ›´æ–°æœ€é«˜å‡ºä»·/æœ€é«˜å‡ºä»·äºº
        highestBid = msg.value;
        highestBider = msg.sender;
        emit Bid(msg.sender, msg.value);
    }

    // å–å›è‡ªå·±çš„å‡ºä»·
    function withdraw() external {
        uint256 bal = bids[msg.sender];
        require(bal > 0, "No amount can be refunded");
        bids[msg.sender] = 0; //ä¸ºäº†é˜²æ­¢æ¼æ´å‘ç”Ÿï¼Œéœ€è¦å…ˆæŠŠçŠ¶æ€ä¿®æ”¹
        payable(msg.sender).transfer(bal);
        emit Withdraw(msg.sender, bal);
    }

    // ç»“æŸæ‹å–;ä¸éœ€è¦åšèº«ä»½ç¡®è®¤ï¼Œå› ä¸ºéœ€è¦åšçš„äº‹æƒ…æ˜¯å›ºå®šçš„ï¼Œ
    // èƒ½ä¸åšèº«ä»½åˆ¤æ–­å°±ä¸éœ€è¦åšï¼Œå¯ä»¥èŠ‚çœGas
    function end() external {
        require(started, "Not started"); // éœ€è¦å·²ç»å¼€å§‹
        require(!ended, "is ended"); // éœ€è¦è¿˜æ²¡æœ‰ç»“æŸ
        require(block.timestamp >= endAt, "auction in progress");
        ended = true;

        if (highestBider != address(0)) {
            // å¦‚æœæœ‰äººå‡ºä»·åˆ™å°† NFT ç»™æœ€é«˜å‡ºä»·äººï¼Œæœ€é«˜ä»·æ ¼ç»™é”€å”®è€…
            nft.transferFrom(address(this), highestBider, nftId);
            seller.transfer(highestBid);
        } else {
            // å¦‚æœæ²¡æœ‰äººå‡ºä»·ï¼Œåˆ™NFTåŸè·¯è¿”è¿˜ç»™é”€å”®è€…
            nft.transferFrom(address(this), seller, nftId);
        }
        emit End(highestBider, highestBid);
    }

    /*
     * ========================================
     * Helper
     * ========================================
     */
    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}
```

### æµ‹è¯•æµç¨‹

- éƒ¨ç½² ERC721 ,NFT åˆçº¦åœ°å€æ˜¯ `nftContractAds`
- ç»™ `address1` min ä¸€ä¸ª ID æ˜¯ 1 çš„ NFT
- éƒ¨ç½²è‹±å¼æ‹å–åˆçº¦ `EnglishAuction`
  - è¾“å…¥ NFT åˆçº¦åœ°å€
  - è¾“å…¥ NFT ID å·
  - èµ·æ‹ä»·æ ¼:8
- åœ¨ `nftContractAds` ä¸­ approve `EnglishAuction` , ID ä¸º 1 çš„ NFT
- ä½¿ç”¨ `address2` å‡ºä»· 1,æŸ¥çœ‹æ˜¯å¦è¿”å›é”™è¯¯ `Not started`
- æŸ¥çœ‹åˆçº¦çš„çŠ¶æ€
  - `started`
  - `ended`
  - `getBalance`
  - `seller`
  - `nft`
  - `nftId`
  - `highestBider`
  - `highestBid`
- ä½¿ç”¨ `address1` å‡ºä»· 1, å¼€å§‹æ‹å–åˆçº¦ï¼ŒæŸ¥çœ‹æ˜¯å¦è¿”å›é”™è¯¯ `invalid price`
- å†æ¬¡æŸ¥çœ‹åˆçº¦çš„çŠ¶æ€
- ä½¿ç”¨ `address2` å‡ºä»· 10
- ä½¿ç”¨ `address3` å‡ºä»· 20
- ä½¿ç”¨ `address2` å‡ºä»· 50
- æŸ¥è¯¢ `address2` å¯é€€æ¢çš„ä¸»å¸
- æŸ¥è¯¢ `address3` å¯é€€æ¢çš„ä¸»å¸
- ç»“æŸæ‹å–
- ä½¿ç”¨ `address2` å–å›ä¸»å¸
- ä½¿ç”¨ `address3` å–å›ä¸»å¸

## #ï¸âƒ£ é—®ç­”é¢˜

- `interface` æœ‰å“ªäº›é™åˆ¶ï¼Ÿ
  - æ— æ³•å®ç°ä»»ä½•åŠŸèƒ½ï¼Œæ²¡æœ‰å‡½æ•°ä½“ã€‚
    - å¦åˆ™æŠ¥é”™:`Functions in interfaces must be declared external.`
  - æ— æ³•ç»§æ‰¿å…¶ä»–åˆçº¦ã€‚(éœ€è¦éªŒè¯ï¼Œæ˜¯å¦å¯ä»¥ç»§æ‰¿æ¥å£ï¼Œæ–‡æ¡£å†…è¯´å¯ä»¥ç»§æ‰¿å…¶ä»–æ¥å£ã€‚)
  - æ— æ³•å®šä¹‰æ„é€ å‡½æ•°ã€‚
  - æ— æ³•å®šä¹‰çŠ¶æ€å˜é‡ã€‚
  - ä¸å¯ä»¥å£°æ˜ä¿®æ”¹å™¨ã€‚
  - æ— æ³•å®šä¹‰ç»“æ„ï¼ˆ`strct`ï¼‰ï¼ˆ`0.5.0` ç‰ˆæœ¬å¼€å§‹æ¥å£é‡Œå¯ä»¥æ”¯æŒå£°æ˜ `enum` ç±»å‹ï¼‰ã€‚
  - æ‰€æœ‰å£°æ˜çš„å‡½æ•°å¿…é¡»æ˜¯ `external` çš„ï¼Œå°½ç®¡åœ¨åˆçº¦é‡Œå¯ä»¥æ˜¯ public
  - æ–‡æ¡£è¯´ï¼šå°†æ¥å¯èƒ½ä¼šè§£é™¤è¿™é‡Œçš„æŸäº›é™åˆ¶ã€‚
- `interface` çš„æ„ä¹‰ï¼Ÿ
  - æˆ‘ä»¬éœ€è¦è°ƒç”¨å·²ç»éƒ¨ç½²åœ¨é“¾ä¸Šçš„å·²ç»åˆçº¦ï¼Œè¿™æ—¶å€™å¯ä»¥é€šè¿‡æ¥å£åˆçº¦å®ç°éƒ¨åˆ†è°ƒç”¨çš„é€»è¾‘ï¼Œæˆ‘ä»¬åªéœ€è¦å†™ä¸€ä¸ªä¸ä¹‹å¯¹åº”çš„æ¥å£åˆçº¦ï¼Œå°±å¯ä»¥è°ƒç”¨äº†ã€‚
- `interface` å’Œ `abstract`(æŠ½è±¡åˆçº¦)æœ‰å•¥åŒºåˆ«ï¼Ÿåˆ†åˆ«ç”¨åœ¨ä»€ä¹ˆåœ°æ–¹ï¼Ÿ
- `interface` çš„å¸¸è§ç”¨æ³•æœ‰å“ªäº›ï¼Ÿ
  - åˆ¶å®šæ ‡å‡†ï¼Œæ¯”å¦‚æœ€æˆåŠŸçš„ `ERC20` æ¥å£åˆçº¦
- `ERC20` æ ‡å‡†æ¥å£æœ‰å“ªäº›å†…å®¹ï¼Ÿ
  - 1 ä¸ªæˆæƒï¼ˆapproveï¼‰
  - 2 ä¸ªäº‹ä»¶ï¼ˆTransfer/Approvalï¼‰
  - 2 ä¸ªäº¤æ˜“ï¼ˆtransfer/transferFromï¼‰
  - 3 ä¸ªæŸ¥è¯¢ï¼ˆtotalSupply/balanceOf/allowanceï¼‰
  - åªè¦æ»¡è¶³ä»¥ä¸Šæ¥å£çš„éƒ½æ˜¯ ERC20 æ ‡å‡†åˆçº¦ï¼Œå¾ˆå¤šåœŸç‹—åˆçº¦å–œæ¬¢åœ¨ transfer å†…é­”æ”¹ã€‚
- å…¨å±€å±æ€§ `type(I).interfaceId` ä½¿ç”¨ï¼Ÿ
  - æ²¡å•¥ç”¨ï¼Œå°±æ˜¯ç±»ä¼¼å‡½æ•°ç­¾åä¸€æ ·çš„åå…­è¿›åˆ¶æ•°æ®ï¼ŒçŸ¥é“æœ‰è¿™ä¸ªå±æ€§å°±å¥½ã€‚
- èŠä¸€èŠ `interface`
  - å°±åƒç»§æ‰¿å…¶ä»–åˆçº¦ä¸€æ ·ï¼Œåˆçº¦å¯ä»¥ç»§æ‰¿æ¥å£ã€‚æ¥å£ä¸­çš„å‡½æ•°éƒ½ä¼šéšå¼çš„æ ‡è®°ä¸º
    `virtual` ï¼Œæ„å‘³ç€ä»–ä»¬ä¼šè¢«é‡å†™å¹¶ä¸éœ€è¦ `override` å…³é”®å­—ã€‚
    ä½†æ˜¯ä¸è¡¨ç¤ºé‡å†™ï¼ˆoverridingï¼‰å‡½æ•°å¯ä»¥å†æ¬¡é‡å†™ï¼Œä»…ä»…å½“é‡å†™çš„å‡½æ•°æ ‡è®°ä¸º
    `virtual` æ‰å¯ä»¥å†æ¬¡é‡å†™ã€‚
