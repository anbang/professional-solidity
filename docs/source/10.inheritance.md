# 10.ç»§æ‰¿

å®žçŽ°ç»§æ‰¿çš„æ–¹å¼æ˜¯é€šè¿‡å¤åˆ¶åŒ…æ‹¬å¤šæ€çš„ä»£ç åˆ°å­ç±»æ¥å®žçŽ°çš„ã€‚åˆçº¦ç»§æ‰¿é€šè¿‡å…³é”®å­— `is` æ¥å®žçŽ°ã€‚ç”±äºŽ Solidity ç»§æ‰¿çš„å®žçŽ°æ–¹æ¡ˆæ˜¯ä»£ç æ‹·è´ï¼Œæ‰€ä»¥åˆçº¦ç»§æ‰¿åŽï¼Œéƒ¨ç½²åˆ°ç½‘ç»œæ—¶ï¼Œå°†å˜æˆä¸€ä¸ªåˆçº¦ï¼Œä»£ç å°†ä»Žçˆ¶ç±»æ‹·è´åˆ°å­ç±»ä¸­ã€‚

- ä¿®é¥°ç¬¦å¯ä»¥ç»§æ‰¿
- äº‹ä»¶ä¸å¯ä»¥ç»§æ‰¿ï¼Œä½†æ˜¯å¯ä»¥é‡è½½
- `fallback` å¯ä»¥ç»§æ‰¿ï¼Œä½†æ˜¯éœ€è¦ä¿æŒåŽŸæœ‰çš„ `payable/nonpayable`
- `receive` å¯ä»¥ç»§æ‰¿ï¼Œä½†æ˜¯éœ€è¦ä¿æŒåŽŸæœ‰çš„ `payable/nonpayable`

## 1ï¸âƒ£ ä½¿ç”¨ `is` å®žçŽ°ç»§æ‰¿

å½“ä¸€ä¸ªåˆçº¦ä»Žå¤šä¸ªåˆçº¦ç»§æ‰¿æ—¶ï¼Œåœ¨åŒºå—é“¾ä¸Šåªæœ‰ä¸€ä¸ªåˆçº¦è¢«åˆ›å»ºï¼Œæ‰€æœ‰åŸºç±»åˆçº¦ï¼ˆæˆ–ç§°ä¸ºçˆ¶åˆçº¦ï¼‰çš„ä»£ç è¢«ç¼–è¯‘åˆ°åˆ›å»ºçš„åˆçº¦ä¸­ã€‚è¿™æ„å‘³ç€å¯¹åŸºç±»åˆçº¦å‡½æ•°çš„æ‰€æœ‰å†…éƒ¨è°ƒç”¨ä¹Ÿåªæ˜¯ä½¿ç”¨å†…éƒ¨å‡½æ•°è°ƒç”¨ï¼ˆsuper.fï¼ˆ..ï¼‰å°†ä½¿ç”¨ JUMP è·³è½¬è€Œä¸æ˜¯æ¶ˆæ¯è°ƒç”¨ï¼‰ã€‚

- ç»§æ‰¿: **æ´¾ç”Ÿåˆçº¦**ç»§æ‰¿**åŸºç¡€åˆçº¦**çš„å±žæ€§å’Œæ–¹æ³•
- åŸºç¡€åˆçº¦é€šå¸¸ä¹Ÿè¢«ç§°ä¸º**çˆ¶åˆçº¦**ï¼Œæ´¾ç”Ÿåˆçº¦é€šå¸¸ä¹Ÿç§°ä½œ**å­åˆçº¦**ã€‚
- ä¸‹é¢æ˜¯: "ç”·äºº"ç»§æ‰¿"äºº"çš„æ¼”ç¤ºã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Person {
    string internal name;
    uint256 age; // çŠ¶æ€å˜é‡é»˜è®¤æ˜¯internalæƒé™

    event Log(string funName);

    modifier onlyOwner() virtual {
        age = 1;
        _;
    }

    fallback() external payable virtual {
        emit Log("fallback by Person");
    }

    receive() external payable virtual {
        emit Log("receive by Person");
    }
}

contract Man is Person {
    constructor() {
        name = "Anbang";
        age = 18;
    }

    event Log(string funName, address _ads);

    modifier onlyOwner() override {
        age = 99;
        _;
    }

    function getName() external view returns (string memory) {
        return name;
    }

    function getAge() external view returns (uint256) {
        return age;
    }

    function getAge2() external onlyOwner returns (uint256) {
        return age;
    }

    // fallback å’Œ receive ç»§æ‰¿çš„æ—¶å€™ï¼Œå¿…é¡»ä¿è¯ payable/nonpayable çŠ¶æ€ä¸å˜ã€‚
    // Overriding function changes state mutability from "payable" to "nonpayable".
    // fallback() external override {
    //     emit Log("fallback by man");
    // }

    fallback() external payable override {
        emit Log("fallback by man");
    }

    receive() external payable override {
        emit Log("receive by Man", msg.sender);
    }
}
```

- çˆ¶åˆçº¦å¿…é¡»å†™åœ¨å­åˆçº¦çš„å‰é¢ï¼Œ
  - å¦åˆ™ä¼šæŠ¥é”™: `TypeError: Definition of base has to precede definition of derived contract`

## 2ï¸âƒ£ å­ç±»å¯ä»¥ç»§æ‰¿çˆ¶ç±»å“ªäº›æ•°æ®ï¼Ÿ

å­ç±»å¯ä»¥è®¿é—®çˆ¶ç±»çš„æƒé™ä¿®é¥°ç¬¦åªæœ‰ï¼š`public/internal`ï¼Œä¸èƒ½æ˜¯ `external/private`ã€‚

- å¦‚æžœçˆ¶ç±»çš„çŠ¶æ€å˜é‡å’Œå‡½æ•°æ˜¯ `private` å’Œ `external`ï¼Œåˆ™å­ç±»ä¸å¯ä»¥ç»§æ‰¿å’Œè®¿é—®ã€‚
  - å¦‚æžœå­ç±»è°ƒç”¨çˆ¶ç±» `external` ä¿®é¥°çš„å‡½æ•°ï¼Œä¼šæŠ¥é”™:`Cannot call function via contract type name.`

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Person {
    string internal name;
    uint256 age; // çŠ¶æ€å˜é‡é»˜è®¤æ˜¯internalæƒé™
    uint256 public hand = 2;
    uint256 private privateState = 99;

    function publicFn() public pure returns (uint256) {
        return 1;
    }

    function internalFn() internal pure returns (uint256) {
        return 2;
    }

    function privateFn() private pure returns (uint256) {
        return 3;
    }
}

contract Man is Person {
    constructor() {
        name = "Anbang";
        age = 18;
    }

    function getInfo()
        external
        view
        returns (
            string memory,
            uint256,
            uint256
        )
    {
        return (name, age, hand);
        // privateState ä¸å¯ä»¥è®¿é—®
    }

    function getPublicFn() external pure returns (uint256) {
        return publicFn();
    }

    function getInternalFn() external pure returns (uint256) {
        return internalFn();
    }

    // ä¸å¯ä»¥è®¿é—® privateFn çš„æ–¹æ³•
    // function getPrivateFn() external pure returns (uint256) {
    //     return privateFn(); // Undeclared identifier.
    // }
}
```

## 3ï¸âƒ£ å¤šé‡ç»§æ‰¿ä¸­çš„é‡å

- ä¸€ä¸ªåˆçº¦åŒæ—¶ç»§æ‰¿ 2 ä¸ªåˆçº¦æ—¶ï¼Œè¿™ç§æƒ…å†µå«å¤šé‡ç»§æ‰¿
- å¤šé‡ç»§æ‰¿ä¸­ä¸å…è®¸å‡ºçŽ°ç›¸åŒçš„**å‡½æ•°å**ã€**äº‹ä»¶å**ã€**ä¿®æ”¹å™¨å**ä»¥åŠ**çŠ¶æ€å˜é‡å**ç­‰ã€‚

å¦‚ä¸‹ç»§æ‰¿ä¼šæŠ¥é”™ï¼Œä¸å…è®¸ç¼–è¯‘:

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract A {
    string internal name;
    event log();
    modifier onlyOwner() {
        _;
    }

    function test() internal {}
}

contract B {
    string internal name;
    event log();
    modifier onlyOwner() {
        _;
    }

    function test() internal {}
}

contract C is A, B {}
```

å¤šé‡ç»§æ‰¿å‡½æ•°ä¸­ getter å‡½æ•°é‡åä¹Ÿä¸å¯ä»¥ï¼Œå¦‚ä¸‹æ˜¯**æ¯”è¾ƒéšè”½çš„å†²çªæƒ…å†µ**ï¼š

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract A {
    uint256 public data = 10;
}

contract B {
    // dataå‡½æ•°ä¹‹æ‰€ä»¥å‡ºé”™
    // æ˜¯å› ä¸ºå’Œ A ä¸­çŠ¶æ€å˜é‡ data çš„ getter å‡½æ•°é‡åã€‚
    function data() public returns (uint256) {
        return 1;
    }
}

contract C is A, B {}
```

å½“ç»§æ‰¿æ—¶åˆçº¦å‡ºçŽ°äº†ä¸€ä¸‹ç›¸åŒåå­—ä¼šè¢«è®¤ä¸ºæ˜¯ä¸€ä¸ªé”™è¯¯ï¼š

- å‡½æ•° å’Œ ä¿®æ”¹å™¨/modifier åŒå
- å‡½æ•° å’Œ äº‹ä»¶åŒå
- äº‹ä»¶å’Œ ä¿®æ”¹å™¨/modifier åŒå
- æœ‰ä¸€ç§ä¾‹å¤–æƒ…å†µï¼ŒçŠ¶æ€å˜é‡çš„ `getter` å‡½æ•°å¯ä»¥è¦†ç›– `external` å‡½æ•°ã€‚

## 4ï¸âƒ£ é‡å†™å‡½æ•°

solidity å¼•å…¥äº† `abstract`, `virtual`, `override` å‡ ä¸ªå…³é”®å­—ï¼Œç”¨äºŽé‡å†™å‡½æ•°ã€‚çˆ¶åˆçº¦æ ‡è®°ä¸º `virtual`å‡½æ•°å¯ä»¥åœ¨ç»§æ‰¿åˆçº¦é‡Œé‡å†™(overridden)ä»¥æ›´æ”¹ä»–ä»¬çš„è¡Œä¸ºã€‚é‡å†™çš„å‡½æ•°éœ€è¦ä½¿ç”¨å…³é”®å­— `override` ä¿®é¥°ã€‚

ç»§æ‰¿çš„æ–¹æ³•é‡å†™éœ€è¦æ³¨æ„çš„ç‚¹:

- çˆ¶åˆçº¦æ–¹æ³•éœ€è¦æ ‡ç¤ºä¸º**å¯ä¿®æ”¹**ï¼Œä½¿ç”¨å…³é”®å­— `virtual`ï¼Œ
- å­åˆçº¦æ–¹æ³•éœ€è¦æ ‡ç¤ºä¸º**è¦†ç›–**ï¼Œä½¿ç”¨å…³é”®è¯ `override`
  - å¯¹äºŽå¤šé‡ç»§æ‰¿ï¼Œå¦‚æžœæœ‰å¤šä¸ªçˆ¶åˆçº¦æœ‰ç›¸åŒå®šä¹‰çš„å‡½æ•°ï¼Œ override å…³é”®å­—åŽå¿…é¡»æŒ‡å®šæ‰€æœ‰çˆ¶åˆçº¦åã€‚
- åŸºç¡€åˆçº¦ä¸­å¯ä»¥åŒ…å«æ²¡æœ‰å®žçŽ°ä»£ç çš„å‡½æ•°ï¼Œä¹Ÿå°±æ˜¯çº¯è™šå‡½æ•°ï¼Œé‚£ä¹ˆåŸºç¡€åˆçº¦å¿…é¡»å£°æ˜Žä¸º `abstract`ã€‚
- ç»§æ‰¿å¤šä¸ªåˆçº¦æ—¶ï¼Œæ‰€æœ‰åŒåçš„å¯ä¿®æ”¹å‡½æ•°éƒ½éœ€è¦é‡å†™
- ç»§æ‰¿åŽé‡å†™åˆçº¦æ–¹æ³•ï¼Œå„ä¸ªåˆçº¦å†…çš„å‡½æ•°å¯è§æ€§éœ€è¦ä¸€è‡´
- å¯å˜æ€§å¯ä»¥æŒ‰ç…§ä»¥ä¸‹é¡ºåºæ›´æ”¹ä¸ºæ›´ä¸¥æ ¼çš„ä¸€ç§ï¼š `nonpayable` å¯ä»¥è¢« `view` å’Œ`pure` è¦†ç›–ã€‚ `view` å¯ä»¥è¢« `pure` è¦†ç›–ã€‚ `payable`æ˜¯ä¸€ä¸ªä¾‹å¤–ï¼Œä¸èƒ½æ›´æ”¹ä¸ºä»»ä½•å…¶ä»–å¯å˜æ€§ã€‚

### 1.virtual å’Œ override

ä»¥ä¸‹ä¾‹å­ï¼ŒB ç»§æ‰¿ Aï¼ŒC ç»§æ‰¿ B

- A æ˜¯çˆ·çˆ·
- B æ˜¯çˆ¸çˆ¸
- C æ˜¯å­™å­

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract A {
    function test1() public pure virtual returns (string memory) {
        return "test1 from A";
    }

    // ä½¿ç”¨ public å’Œ external éƒ½å¯ä»¥
    function test2() external pure virtual returns (string memory) {
        return "test2 from A";
    }

    function test3() public pure virtual returns (string memory) {
        return "test3 from A";
    }
}

contract B is A {
    function test1() public pure virtual override returns (string memory) {
        return "test1 from B";
    }

    function test2() external pure override returns (string memory) {
        return "test2 from B";
    }
}

contract C is B {
    function test1() public pure override returns (string memory) {
        return "test1 from C";
    }
}
```

å¯¹äºŽå¤šé‡ç»§æ‰¿ï¼Œå¦‚æžœæœ‰å¤šä¸ªçˆ¶åˆçº¦æœ‰ç›¸åŒå®šä¹‰çš„å‡½æ•°ï¼Œ `override` å…³é”®å­—åŽå¿…é¡»æŒ‡å®šæ‰€æœ‰çˆ¶åˆçº¦åã€‚

```
pragma solidity >=0.7.0 <0.9.0;

contract Base1
{
    function foo() virtual public {}
}

contract Base2
{
    function foo() virtual public {}
}

contract Inherited is Base1, Base2
{
    // ç»§æ‰¿è‡ªä¸¤ä¸ªåŸºç±»åˆçº¦å®šä¹‰çš„foo(), å¿…é¡»æ˜¾ç¤ºçš„æŒ‡å®š override
    function foo() public override(Base1, Base2) {}
}
```

ä¸è¿‡å¦‚æžœï¼ˆé‡å†™çš„ï¼‰å‡½æ•°ç»§æ‰¿è‡ªä¸€ä¸ªå…¬å…±çš„çˆ¶åˆçº¦ï¼Œ `override` æ˜¯å¯ä»¥ä¸ç”¨æ˜¾ç¤ºæŒ‡å®šçš„ã€‚ ä¾‹å¦‚ï¼š

```
pragma solidity >=0.7.0 <0.9.0;

contract A { function f() public pure{} }
contract B is A {}
contract C is A {}
// ä¸ç”¨æ˜¾ç¤º  override
contract D is B, C {}
```

æ›´æ­£å¼åœ°è¯´ï¼Œå¦‚æžœå­˜åœ¨çˆ¶åˆçº¦æ˜¯ç­¾åå‡½æ•°çš„æ‰€æœ‰é‡å†™è·¯å¾„çš„ä¸€éƒ¨åˆ†ï¼Œåˆ™ä¸éœ€è¦é‡å†™ï¼ˆç›´æŽ¥æˆ–é—´æŽ¥ï¼‰ä»Žå¤šä¸ªåŸºç¡€ç»§æ‰¿çš„å‡½æ•°ï¼Œå¹¶ä¸”ï¼ˆ1ï¼‰çˆ¶åˆçº¦å®žçŽ°äº†è¯¥å‡½æ•°ï¼Œä»Žå½“å‰åˆçº¦åˆ°çˆ¶åˆçº¦çš„è·¯å¾„éƒ½æ²¡æœ‰æåˆ°å…·æœ‰è¯¥ç­¾åçš„å‡½æ•°ï¼Œæˆ–è€…ï¼ˆ2ï¼‰çˆ¶åˆçº¦æ²¡æœ‰å®žçŽ°è¯¥å‡½æ•°ï¼Œå¹¶ä¸”å­˜åœ¨ä»Žå½“å‰åˆçº¦åˆ°è¯¥çˆ¶åˆçº¦çš„æ‰€æœ‰è·¯å¾„ä¸­ï¼Œæœ€å¤šåªèƒ½æåŠè¯¥å‡½æ•°ã€‚

ä»Žè¿™ä¸ªæ„ä¹‰ä¸Šè¯´ï¼Œç­¾åå‡½æ•°çš„é‡å†™è·¯å¾„æ˜¯é€šè¿‡ç»§æ‰¿å›¾çš„è·¯å¾„ï¼Œè¯¥è·¯å¾„å§‹äºŽæ‰€è€ƒè™‘çš„åˆçº¦ï¼Œå¹¶ç»ˆæ­¢äºŽæåŠå…·æœ‰è¯¥ç­¾åçš„å‡½æ•°çš„åˆçº¦ã€‚

å¦‚æžœå‡½æ•°æ²¡æœ‰æ ‡è®°ä¸º `virtual` ï¼Œé‚£ä¹ˆæ´¾ç”Ÿåˆçº¦å°†ä¸èƒ½æ›´æ”¹å‡½æ•°çš„è¡Œä¸ºï¼ˆå³ä¸èƒ½é‡å†™ï¼‰ã€‚

.. note::`private` çš„å‡½æ•°æ˜¯ä¸å¯ä»¥æ ‡è®°ä¸º `virtual` çš„ã€‚

.. note::é™¤æŽ¥å£ä¹‹å¤–ï¼ˆå› ä¸ºæŽ¥å£ä¼šè‡ªåŠ¨ä½œä¸º `virtual` ï¼‰ï¼Œæ²¡æœ‰å®žçŽ°çš„å‡½æ•°å¿…é¡»æ ‡è®°ä¸º`virtual`

.. note::ä»Ž Solidity 0.8.8 å¼€å§‹, åœ¨é‡å†™æŽ¥å£å‡½æ•°æ—¶ä¸å†è¦æ±‚ `override`
å…³é”®å­—ï¼Œé™¤éžå‡½æ•°åœ¨å¤šä¸ªçˆ¶åˆçº¦å®šä¹‰ã€‚

å¦‚æžœ getter å‡½æ•°çš„å‚æ•°å’Œè¿”å›žå€¼éƒ½å’Œå¤–éƒ¨å‡½æ•°ä¸€è‡´æ—¶ï¼Œå¤–éƒ¨ï¼ˆexternalï¼‰å‡½æ•°æ˜¯å¯ä»¥è¢« public çš„çŠ¶æ€å˜é‡è¢«é‡å†™çš„ï¼Œä¾‹å¦‚ï¼š

```

    pragma solidity >=0.7.0 <0.9.0;

    contract A
    {
        function f() external view virtual returns(uint) { return 5; }
    }

    contract B is A
    {
        uint public override f;
    }

```

âš ï¸ : å°½ç®¡ public çš„çŠ¶æ€å˜é‡å¯ä»¥é‡å†™å¤–éƒ¨å‡½æ•°ï¼Œä½†æ˜¯ public çš„çŠ¶æ€å˜é‡ä¸èƒ½è¢«é‡å†™ã€‚

### 2.abstractï¼ˆæŠ½è±¡åˆçº¦ï¼‰

åŸºç¡€åˆçº¦ä¸­å¯ä»¥åŒ…å«æ²¡æœ‰å®žçŽ°ä»£ç çš„å‡½æ•°ï¼Œä¹Ÿå°±æ˜¯çº¯è™šå‡½æ•°ï¼Œé‚£ä¹ˆåŸºç¡€åˆçº¦å¿…é¡»å£°æ˜Žä¸º `abstract`ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

abstract contract IERC20 {
    function transfer() external virtual returns (bool);
}

contract ERC20 is IERC20 {
    function transfer() external pure override returns (bool) {
        return true;
    }
}
```

æ‰©å±•: è¿™é‡Œçš„ `abstract`ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ `interface` æ¥è§£å†³ã€‚ æ›´å¤š `interface` å†…å®¹ï¼Œè¯·å‚è€ƒ [interface:æŽ¥å£](/source/13.interface.html) è¯¦ç»†é˜…è¯»ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

interface IERC20 {
    function transfer() external returns (bool);
}

contract ERC20 is IERC20 {
    function transfer() external pure returns (bool) {
        return true;
    }
}
```

## 5ï¸âƒ£ å¤šçº§ç»§æ‰¿çš„ä»£ç ä¹¦å†™é¡ºåºï¼ˆçº¿æ€§åŒ–ï¼‰

Solidity è¯­è¨€çš„å¤šé‡ç»§æ‰¿é‡‡ç”¨çº¿æ€§ç»§æ‰¿æ–¹å¼ã€‚ç»§æ‰¿é¡ºåºå¾ˆé‡è¦ï¼Œåˆ¤æ–­é¡ºåºçš„ä¸€ä¸ªç®€å•è§„åˆ™æ˜¯æŒ‰ç…§**ä»Žâ€œæœ€ç±»ä¼¼åŸºç±»â€åˆ°â€œæœ€å¤šæ´¾ç”Ÿâ€çš„é¡ºåºæŒ‡å®šåŸºç±»**ã€‚

åŽŸåˆ™ï¼š**å…ˆå†™åŸºç¡€åˆçº¦ï¼Œå†å†™æ´¾ç”Ÿåˆçº¦ã€‚**

**å°æŠ€å·§ï¼šå¯ä»¥å…ˆç”»ç»§æ‰¿é€»è¾‘å›¾ï¼Œç„¶åŽæŒ‰ç…§ä»Žä¸Šåˆ°ä¸‹ï¼Œä»Žå·¦åˆ°å³çš„é¡ºåºæ¥å†™åˆçº¦ï¼›**

ä¸Šé¢ **virtual å’Œ override** çš„ä»‹ç»ä¾‹å­ä¸­ï¼Œåˆçº¦ç»§æ‰¿é€»è¾‘å›¾å¦‚ä¸‹ï¼š

```
/**
A
|
B
|
C
 */
```

B ç»§æ‰¿ Aï¼ŒC ç»§æ‰¿ Bã€‚æ‰€ä»¥å†™çš„æ—¶å€™é¡ºåºæ˜¯: `A => B => C`

### 1.ç»§æ‰¿æ¡ˆä¾‹ä¸€

```
/**
 B   A
  \ /
   C
 */
```

C ç»§æ‰¿ A å’Œ Bã€‚

å†™çš„æ—¶å€™é¡ºåºæ˜¯: `A > B > C` / `B > A > C` éƒ½æ˜¯å¯ä»¥çš„

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract A {
    function test1() public pure virtual returns (string memory) {
        return "test1 from A";
    }
}

contract B {
    function test2() public pure virtual returns (string memory) {
        return "test2 from B";
    }
}

contract C is A, B {
    function test3() public pure returns (string memory) {
        return "test3 from C";
    }
}
```

### 2.ç»§æ‰¿æ¡ˆä¾‹äºŒ

```
/**
    A
  / |
B   |
  \ |
    C
 */
```

B ç»§æ‰¿ Aï¼ŒC ç»§æ‰¿ A å’Œ Bã€‚**æ³¨æ„:è¿™é‡Œæ˜¯ C ç»§æ‰¿ A å’Œ Bï¼Œä¸æ˜¯ C ç»§æ‰¿ B å’Œ A**ã€‚

å†™çš„æ—¶å€™é¡ºåºæ˜¯: `A > B > C`

**ä»£ç å¦‚ä¸‹:**

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract A {
    function test1() public pure virtual returns (string memory) {
        return "test1 from A";
    }

    // ä½¿ç”¨ public å’Œ external éƒ½å¯ä»¥
    function test2() external pure virtual returns (string memory) {
        return "test2 from A";
    }

    function test3() public pure virtual returns (string memory) {
        return "test3 from A";
    }
}

contract B is A {
    function test1() public pure virtual override returns (string memory) {
        return "test1 from B";
    }

    function test2() external pure virtual override returns (string memory) {
        return "test2 from B";
    }
}

// è¿™é‡Œå¿…é¡»æ˜¯ contract C is A, B
// ä¸èƒ½ä½¿ç”¨ contract C is B, A
contract C is A, B {
    function test1() public pure override(A, B) returns (string memory) {
        return "test1 from C";
    }

    // overridå†…å‚æ•°é¡ºåºæ— æ‰€è°“ï¼Œ
    // C å†…å¿…é¡»é‡å†™ A å’Œ Bï¼Œå¦åˆ™ä¼šæŠ¥é”™
    function test2() public pure override(B, A) returns (string memory) {
        return "test1 from C";
    }
}
```

- **C ç»§æ‰¿ A å’Œ B æ—¶å€™ï¼Œæ‰€æœ‰ A å’Œ B å‡½æ•°ç›¸åŒåå­—çš„æ–¹æ³•ï¼Œéƒ½éœ€è¦é‡å†™ã€‚**
  - å¦åˆ™ä¼šæŠ¥é”™:
  ```
  Derived contract must override function "functionName".
  Two or more base classes define function with same name and parameter types.
  ```
- **å¤šé‡ç»§æ‰¿æ—¶å€™ï¼Œéœ€è¦å…ˆå†™åŸºç¡€åˆçº¦ï¼Œå†å†™æ´¾ç”Ÿåˆçº¦**
  - å†™åˆçº¦ C çš„æ—¶å€™ï¼Œå¿…é¡»å†™æˆ`contract C is A, B`ï¼Œä¸èƒ½å†™`contract C is B, A`
  - å¦åˆ™ä¼šæŠ¥é”™:`TypeError: Linearization of inheritance graph impossible`ã€‚

### 3.ç»§æ‰¿æ¡ˆä¾‹ä¸‰

```
/**
    A
  / |
B   |
  \ |
    C
    |
    D
 */
```

B ç»§æ‰¿ Aï¼ŒC ç»§æ‰¿ A å’Œ Bï¼ŒD ç»§æ‰¿ Cã€‚ï¼ˆ**æ³¨æ„:è¿™é‡Œæ˜¯ C ç»§æ‰¿ A å’Œ Bï¼Œä¸æ˜¯ C ç»§æ‰¿ B å’Œ A**ï¼‰ï¼Œæ‰€ä»¥å†™çš„æ—¶å€™é¡ºåºæ˜¯: `A > B > C > D`

D ç»§æ‰¿ C æ—¶å€™ï¼Œæ²¡æœ‰åŒåå‡½æ•°çš„å†²çªï¼Œæ‰€ä»¥ test1 å’Œ test2 éšä¾¿æ˜¯å¦é‡å†™ã€‚

**ä»£ç å¦‚ä¸‹**

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract A {
    function test1() public pure virtual returns (string memory) {
        return "test1 from A";
    }

    // ä½¿ç”¨ public å’Œ external éƒ½å¯ä»¥
    function test2() external pure virtual returns (string memory) {
        return "test2 from A";
    }

    function test3() public pure virtual returns (string memory) {
        return "test3 from A";
    }
}

contract B is A {
    function test1() public pure virtual override returns (string memory) {
        return "test1 from B";
    }

    function test2() external pure virtual override returns (string memory) {
        return "test2 from B";
    }
}

// è¿™é‡Œå¿…é¡»æ˜¯ contract C is A, B
// ä¸èƒ½ä½¿ç”¨ contract C is B, A
contract C is A, B {
    function test1()
        public
        pure
        virtual
        override(A, B)
        returns (string memory)
    {
        return "test1 from C";
    }

    // overridå†…å‚æ•°é¡ºåºæ— æ‰€è°“ï¼Œ
    function test2()
        public
        pure
        virtual
        override(B, A)
        returns (string memory)
    {
        return "test1 from C";
    }
}

contract D is C {
    function test1() public pure override returns (string memory) {
        return "test1 from D";
    }
}
```

### 4.ç»§æ‰¿æ¡ˆä¾‹å››

```
/**
     A
   / |
  /  |
B    C
  \  |
   \ D
    \|
     E
 */
```

B ç»§æ‰¿ Aï¼ŒC ç»§æ‰¿ Aï¼ŒD ç»§æ‰¿ Cï¼ŒE ç»§æ‰¿ B å’Œ Dã€‚æ‰€ä»¥å†™çš„æ—¶å€™é¡ºåºæ˜¯: `A > B > C > D`

**ä¾‹å­å¦‚ä¸‹:**

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract A {
    function test1() public pure virtual returns (string memory) {
        return "test1 from A";
    }

    // ä½¿ç”¨ public å’Œ external éƒ½å¯ä»¥
    function test2() external pure virtual returns (string memory) {
        return "test2 from A";
    }

    function test3() public pure virtual returns (string memory) {
        return "test3 from A";
    }
}

contract B is A {
    function test1() public pure virtual override returns (string memory) {
        return "test1 from B";
    }

    function test2() external pure virtual override returns (string memory) {
        return "test2 from B";
    }
}

contract C is A {
    function test1() public pure virtual override returns (string memory) {
        return "test1 from C";
    }
}

contract D is C {
    function test1() public pure virtual override returns (string memory) {
        return "test1 from D";
    }
}

contract D is B, D {
    function test1() public pure override(B, D) returns (string memory) {
        return "test1 from E";
    }

    // å¿…é¡»è¦é‡å†™ test2 ï¼Œå› ä¸ºæ­¤æ—¶ B å’Œ D å†…éƒ½æœ‰test2æ–¹æ³•ï¼Œä½†æ˜¯Då†…ç»§æ‰¿Açš„test2æ–¹æ³•ï¼Œå†²çªäº†ã€‚
    // éœ€è¦è¦å†™  override(B, A)ï¼Œä¸èƒ½å†™ override(B, D)ï¼Œå¦åˆ™ä¼šæŠ¥å¦‚ä¸‹é”™è¯¯
    // Function needs to specify overridden contract "A".
    // Invalid contract specified in override list: "D".

    // ä¸‹é¢æ˜¯é”™è¯¯çš„å†™æ³•
    // function test2() public pure override(B, D) returns (string memory) {

    // ä¸‹é¢æ˜¯æ­£ç¡®çš„å†™æ³•
    function test2() public pure override(B, A) returns (string memory) {
        return "test2 from E";
    }
}
```

E å†…å¿…é¡»è¦é‡å†™ test2 ï¼Œå› ä¸ºæ­¤æ—¶ B å’Œ D å†…éƒ½æœ‰ test2 æ–¹æ³•ï¼Œä½†æ˜¯ D å†…ç»§æ‰¿ A çš„ test2 æ–¹æ³•ï¼Œéœ€è¦è¦å†™ override(B, A)ï¼Œä¸èƒ½å†™ override(B, D)ï¼Œå¦åˆ™ä¼šæŠ¥é”™è¯¯:

```
Function needs to specify overridden contract "A".
Invalid contract specified in override list: "D".
```

## 6ï¸âƒ£ ç»§æ‰¿ä¸­ä¸¤ç§æž„é€ å‡½æ•°ä¼ å‚æ–¹å¼

ç»§æ‰¿çš„çˆ¶åˆçº¦ï¼Œå¦‚æžœæœ‰æž„é€ å‡½æ•°å¹¶ä¸”éœ€è¦ä¼ å…¥å‚æ•°ï¼Œæˆ‘ä»¬æœ‰ä»¥ä¸‹å‡ ç§æ–¹æ³•è¿›è¡Œå‚æ•°ä¼ å…¥

### ä¸¤ç§ä¼ å‚æ–¹æ³•

- **æ–¹æ³• 1**: å›ºå®šå€¼ä¼ å‚ã€‚ï¼ˆè¯¥æ–¹å¼ä¸èƒ½åœ¨éƒ¨ç½²æ—¶åŠ¨æ€è¾“å…¥ï¼‰ã€‚
  - å¦‚æžœæˆ‘ä»¬å·²ç»çŸ¥é“åŸºç±»åˆå§‹åŒ–å‚æ•°ï¼Œé‚£ä¹ˆå°±å¯ä»¥åœ¨æ´¾ç”Ÿç±»çš„ç»§æ‰¿å£°æ˜Žä¸­ï¼Œç›´æŽ¥ä¼ é€’å‚æ•°ç»™åŸºç±»çš„æž„é€ å‡½æ•°ã€‚
  ```
  contract C is A("n"),B("v") {}
  ```
- **æ–¹æ³• 2**: åŠ¨æ€ä¼ å‚
  - å¦‚æžœæˆ‘ä»¬éœ€è¦åœ¨éƒ¨ç½²æ—¶æˆ–è€…è¿è¡Œæ—¶ï¼Œç”±è°ƒç”¨æ–¹ä¼ é€’åŸºç±»åˆå§‹åŒ–å‚æ•°ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬éœ€è¦ç¼–å†™ä¸€ä¸ªæ–°çš„æž„é€ å‡½æ•°ï¼Œä¼ é€’å‚æ•°ç»™åŸºç±»ã€‚
  - éƒ¨ç½²å­åˆçº¦çš„æ—¶å€™ï¼Œä¼ å…¥å‚æ•°åˆ°æž„é€ å‡½æ•°ï¼Œè¯¥ç§æ–¹æ³•æ˜¯åŠ¨æ€çš„å€¼ï¼Œå¯ä»¥éƒ¨ç½²çš„æ—¶å€™åŠ¨æ€è¾“å…¥
  ```
  contract D is A {
    constructor(string memory _name) A(_name) {}
  }
  ```
- **æ··å†™**: æ–¹æ³• 1 å’Œæ–¹æ³• 2 å¯ä»¥æ··åˆä½¿ç”¨
  ```
  contract E is A, B("EEEEEEEEEEEEE") {
    constructor(string memory _name) A(_name) {}
  }
  ```

**ä¾‹å­å¦‚ä¸‹:**

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract A {
    string public nameA;

    constructor(string memory _name) {
        nameA = _name;
    }
}

contract B {
    string public nameB;

    constructor(string memory _name) {
        nameB = _name;
    }
}

// æ–¹æ³•1: ç»§æ‰¿æ—¶å€™ç›´æŽ¥ä¼ å…¥å‚æ•°ï¼Œè¯¥ç§æ–¹æ³•æ˜¯å›ºå®šå€¼ï¼Œä¸èƒ½åŠ¨æ€è¾“å…¥
contract C is A("Name From C") {

}

// æ–¹æ³•2: éƒ¨ç½²å­åˆçº¦çš„æ—¶å€™ï¼Œä¼ å…¥å‚æ•°åˆ°æž„é€ å‡½æ•°ï¼Œè¯¥ç§æ–¹æ³•æ˜¯åŠ¨æ€çš„å€¼ï¼Œå¯ä»¥éƒ¨ç½²çš„æ—¶å€™åŠ¨æ€è¾“å…¥
contract D is A {
    constructor(string memory _name) A(_name) {}
}

//  æ··åˆä½¿ç”¨
contract E is A, B("EEEEEEEEEEEEE") {
    constructor(string memory _name) A(_name) {}
}
```

## 7ï¸âƒ£ ç»§æ‰¿ä¸­æž„é€ å‡½æ•°çš„æ‰§è¡Œé¡ºåº

å¤šé‡ç»§æ‰¿ä¸­ï¼Œæž„é€ å‡½æ•°çš„æ‰§è¡Œä¼šæŒ‰ç…§å®šä¹‰æ—¶çš„ç»§æ‰¿é¡ºåºè¿›è¡Œï¼Œä¸Žæž„é€ å‡½æ•°ä¸­å®šä¹‰é¡ºåºæ— å…³ã€‚

åŽŸåˆ™: **æž„é€ å‡½æ•°çš„æ‰§è¡Œé¡ºåºæŒ‰ç…§ç»§æ‰¿çš„é¡ºåºã€‚**

**ä¾‹å­:**

1. å¦‚ä¸‹æ˜¯å…ˆæ‰§è¡Œ Aï¼Œå†æ‰§è¡Œ B

```
contract E is A, B("EEEEEEEEEEEEE") {
    constructor(string memory _name) A(_name) {}
}
```

2. å¦‚ä¸‹æ˜¯å…ˆæ‰§è¡Œ Bï¼Œå†æ‰§è¡Œ A

```
contract E is B("EEEEEEEEEEEEE"),A {
    constructor(string memory _name) A(_name) {}
}
```

**ä¾‹å­å¦‚ä¸‹**:

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract A {
    event logA(string);

    constructor(string memory _name) {
        emit logA(_name);
    }
}

contract B {
    event logB(string);

    constructor(string memory _name) {
        emit logB(_name);
    }
}

//  æ··åˆä½¿ç”¨
contract E is A, B("EEE") {
    constructor(string memory _name) A(_name) {}
}

contract F is B("FFF"), A {
    constructor(string memory _name) A(_name) {}
}
```

éƒ¨ç½² E æ—¶å€™ï¼Œè¾“å…¥ `Anbang`ï¼Œè¾“å‡ºçš„ log å¦‚ä¸‹:**å…ˆæ‰§è¡Œ Aï¼Œå†æ‰§è¡Œ B**

```json
[
	{
		"from": "0xed27012c24FDa47A661De241c4030ecB9D18a76d",
		"topic": "0xb911c6b2723a9b89f3c8a0ce3f2dca6648150807aa6d6959fb18fa31748efcee",
		"event": "logA",
		"args": {
			"0": "Anbang"
		}
	},
	{
		"from": "0xed27012c24FDa47A661De241c4030ecB9D18a76d",
		"topic": "0x2a205cc759862a651d0a138a2245cac3f4b3214b93707a9d0fe4eb716f66f786",
		"event": "logB",
		"args": {
			"0": "EEE"
		}
	}
]
```

éƒ¨ç½² F æ—¶å€™ï¼Œè¾“å…¥ `Anbang`ï¼Œè¾“å‡ºçš„ log å¦‚ä¸‹:**å…ˆæ‰§è¡Œ Bï¼Œå†æ‰§è¡Œ A**

```json
[
	{
		"from": "0x3D42AD7A3AEFDf99038Cd61053913CFCA4944b95",
		"topic": "0x2a205cc759862a651d0a138a2245cac3f4b3214b93707a9d0fe4eb716f66f786",
		"event": "logB",
		"args": {
			"0": "FFF"
		}
	},
	{
		"from": "0x3D42AD7A3AEFDf99038Cd61053913CFCA4944b95",
		"topic": "0xb911c6b2723a9b89f3c8a0ce3f2dca6648150807aa6d6959fb18fa31748efcee",
		"event": "logA",
		"args": {
			"0": "Anbang"
		}
	}
]
```

## 8ï¸âƒ£ ä¸¤ç§å­åˆçº¦è°ƒç”¨çˆ¶åˆçº¦çš„æ–¹æ³•

æœ‰ä¸¤ç§æ–¹æ³•å¯ä»¥è°ƒç”¨

1. ç›´æŽ¥ä½¿ç”¨åˆçº¦åè°ƒç”¨ `ParentContractName.functionName()`;
2. ä½¿ç”¨ super å…³é”®å­— `super.functionName()`
   - super ä¼šè‡ªåŠ¨å¯»æ‰¾çˆ¶åˆçº¦ï¼Œå¹¶æ‰§è¡Œå¯¹åº”çš„æ–¹æ³•ï¼›
   - **å¦‚æžœæ˜¯å¤šä¸ªçˆ¶çº§ï¼Œé‚£ä¹ˆçˆ¶çº§éƒ½ä¼šæ‰§è¡Œã€‚ä½†æœ‰æ—¶å€™åˆä¸ä¼šï¼Œæ‰§è¡Œé¡ºåºçš„åŽŸç†ï¼Œè¿™äº›éœ€è¦è¯¦ç»†çš„äº†è§£**
   - å¦‚æžœ super å¯¼è‡´ 2 ä¸ªçˆ¶çº§åŒæ—¶è§¦å‘åŒä¸€ä¸ªçˆ·çˆ·åˆçº¦çš„ç›¸åŒæ–¹æ³•ï¼›åˆ™çˆ·çˆ·çš„æ–¹æ³•åªæ‰§è¡Œä¸€æ¬¡ã€‚ä¸€ä¸ªåˆçº¦çš„åŒä¸€ä¸ªæ–¹æ³•åªä¼šæ‰§è¡Œä¸€æ¬¡ï¼Œä¸ä¼šæ‰§è¡Œå¤šæ¬¡ã€‚

### 1.ç›´æŽ¥ä½¿ç”¨åˆçº¦åè°ƒç”¨

æ‰§è¡Œé¡ºåºï¼šåƒæ°´ä¸­çš„å†’æ³¡ä¸€æ ·ï¼Œç”±ä¸‹å‘ä¸Šè¿›è¡Œæ‰§è¡Œã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract A {
    event Log(string msg);

    function test1() public virtual {
        emit Log("A.test1");
    }
}

contract B is A {
    function test1() public virtual override {
        emit Log("B.test1");
        A.test1();
    }
}
```

ä¸Šé¢çš„ä¾‹å­æ‰§è¡Œé¡ºåºæ˜¯

```
1. B.test1
2. A.test1
```

### 2.ä½¿ç”¨ super å…³é”®å­—è°ƒç”¨

#### åŸºç¡€ç»§æ‰¿

æ‰§è¡Œé¡ºåºï¼šåƒæ°´ä¸­çš„å†’æ³¡ä¸€æ ·ï¼Œç”±ä¸‹å‘ä¸Šè¿›è¡Œæ‰§è¡Œã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract A {
    event Log(string msg);

    function test1() public virtual {
        emit Log("A.test1");
    }
}

contract C is A {
    function test1() public virtual override {
        emit Log("C.test1");
        super.test1();
    }
}
```

ä¸Šé¢çš„ä¾‹å­æ‰§è¡Œé¡ºåºæ˜¯

```
1. C.test1
2. A.test1
```

#### å¤šé‡ç»§æ‰¿

å†™ä¸€ä¸ªå¦‚ä¸‹é€»è¾‘çš„ç»§æ‰¿

```
/**
   A
 /   \
B     C
 \   /
   D
 */
```

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract A {
    event Log(string msg);

    function test1() public virtual {
        emit Log("A.test1");
    }
}

contract B is A {
    function test1() public virtual override {
        emit Log("B.test1");
        A.test1();
    }
}

contract C is A {
    function test1() public virtual override {
        emit Log("C.test1");
        super.test1();
    }
}

contract D is B, C {
    function test1() public override(B, C) {
        emit Log("D.test1");
        // å› ä¸º B å’Œ C éƒ½æ˜¯ D çš„çˆ¶çº§ï¼Œæ‰€ä»¥Bå’ŒCéƒ½ä¼šæ‰§è¡Œ
        super.test1();
    }
}
```

æ‰§è¡Œé¡ºåºï¼šåƒæ°´ä¸­çš„å†’æ³¡ä¸€æ ·ï¼Œç”±ä¸‹å‘ä¸Šè¿›è¡Œæ‰§è¡Œã€‚

```
1. D.test1
1. C.test1
1. B.test1
1. A.test1 (è¿™é‡Œ A åªæ‰§è¡Œä¸€æ¬¡)
```

âŒ **ç¬¬ 1.TODO** : ä¸ºä»€ä¹ˆå…ˆè¾“å‡º Cï¼ŒåŽè¾“å‡º B ?

ä¸Šé¢çš„ä¾‹å­ï¼Œå¦‚æžœä»£ç ä¸­ B å’Œ C æ¢é¡ºåºï¼Œè¿˜æ˜¯æ‰§è¡Œçš„ `DCBA`ã€‚å¼€å§‹æ€€ç–‘å’Œå‡½æ•°åå­—çš„ hash ç»“æžœé¡ºåºæœ‰å…³ç³»ï¼Œçœ‹å®Œä¸‹é¢çš„ç»§ç»­ç ”ç©¶ä»£ç ï¼Œå¯ä»¥å¾—å‡ºç»“è®ºï¼Œå¤æ‚ç»§æ‰¿çš„æ—¶å€™ï¼Œsupper æ–¹å¼å°±åƒä¸€ä¸ªç–¯å­ä¸€æ ·æ²¡æœ‰è§„å¾‹å¯è¨€ã€‚æˆ‘ä»¬èƒ½åšçš„å°±æ˜¯é¿å¼€ä½¿ç”¨å®ƒã€‚

## 9ï¸âƒ£ å¤šé‡ç»§æ‰¿åˆçº¦ä¸è¦ä½¿ç”¨ supper

å†™ä¸€ä¸ªå¦‚ä¸‹é€»è¾‘çš„ç»§æ‰¿

```
/**
   A
 /   \
B     C
| \  /|
|  \/ |
|  /\ |
| /  \|
D     E
 */
```

**ä»£ç å¦‚ä¸‹**:

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract A {
    event Log(string msg);

    // ç»§æ‰¿åŽé‡å†™åˆçº¦æ–¹æ³•ï¼Œå¯è§æ€§éœ€è¦ä¸€è‡´
    function test1() public virtual {
        emit Log("A.test1");
    }
}

contract B is A {
    // æ‰§è¡Œ B.test1 åŽ
    // 1. B.test1
    // 2. A.test1
    function test1() public virtual override {
        emit Log("B.test1");
        A.test1();
    }
}

contract C is A {
    // æ‰§è¡Œ C.test1 åŽ
    // 1. C.test1
    // 2. A.test1
    function test1() public virtual override {
        emit Log("C.test1");
        super.test1();
    }
}

contract D is B, C {
    // æ‰§è¡Œ D.test1 åŽ
    // 1. D.test1
    // 2. C.test1
    // 3. B.test1
    // 4. A.test1
    function test1() public override(B, C) {
        emit Log("D.test1");
        super.test1();
    }
}

// TODO: ä»£ç  contract D is B, C æ”¹æˆ contract E is C, B åŽ , C.test1 ä¸æ‰§è¡Œäº†ã€‚
contract E is C, B {
    // æ‰§è¡Œ E.test1 åŽ
    // 1. E.test1
    // 3. B.test1
    // 4. A.test1
    function test1() public override(B, C) {
        emit Log("E.test1");
        // B å’Œ C éƒ½æ˜¯ E çš„çˆ¶çº§ï¼Œä¸ºå•¥Bæ‰§è¡Œï¼Œè€ŒCä¸æ‰§è¡Œ
        super.test1();
    }
}
```

**ç–‘é—®: æ‰§è¡Œ E.test1 åŽ,è¾“å‡ºå¦‚ä¸‹ç»“æžœï¼Œè¿™æ˜¯æ²¡æœ‰ä»»ä½•è§„å¾‹çš„ï¼Œå¹¶ä¸”ä¸¢å¤±æ•°æ®**ï¼Œåœ¨è¿™ç§å¤šé‡ç»§æ‰¿çš„æ—¶å€™ï¼Œè°ƒç”¨çˆ¶åˆçº¦ä¸è¦ supperï¼Œç›´æŽ¥ä½¿ç”¨åˆçº¦åå­—æ˜¯æœ€ç¨³å¦¥çš„åŠžæ³•ï¼Œåˆ‡è®°åˆ‡è®°ã€‚

```
1. E.test1
3. B.test1
4. A.test1
```

## ðŸ†— å®žæˆ˜åº”ç”¨

ä¸‹é¢çš„ä¾‹å­è¿›è¡Œäº†è¯¦ç»†çš„è¯´æ˜Žã€‚

```
    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.7.0 <0.9.0;

    contract Owned {
        constructor() public { owner = payable(msg.sender); }
        address payable owner;
    }

    // ä½¿ç”¨ is ä»Žå¦ä¸€ä¸ªåˆçº¦æ´¾ç”Ÿã€‚æ´¾ç”Ÿåˆçº¦å¯ä»¥è®¿é—®æ‰€æœ‰éžç§æœ‰æˆå‘˜ï¼ŒåŒ…æ‹¬å†…éƒ¨ï¼ˆinternalï¼‰å‡½æ•°å’ŒçŠ¶æ€å˜é‡ï¼Œ
    // ä½†æ— æ³•é€šè¿‡ this æ¥å¤–éƒ¨è®¿é—®ã€‚
    contract Destructible is Owned {

     // å…³é”®å­—`virtual`è¡¨ç¤ºè¯¥å‡½æ•°å¯ä»¥åœ¨æ´¾ç”Ÿç±»ä¸­â€œoverridingâ€ã€‚

         function destroy() virtual public { if (msg.sender == owner)
selfdestruct(owner); } }

    // è¿™äº›æŠ½è±¡åˆçº¦ä»…ç”¨äºŽç»™ç¼–è¯‘å™¨æä¾›æŽ¥å£ã€‚
    // æ³¨æ„å‡½æ•°æ²¡æœ‰å‡½æ•°ä½“ã€‚
    // å¦‚æžœä¸€ä¸ªåˆçº¦æ²¡æœ‰å®žçŽ°æ‰€æœ‰å‡½æ•°ï¼Œåˆ™åªèƒ½ç”¨ä½œæŽ¥å£ã€‚
    abstract contract Config {
        function lookup(uint id) public virtual returns (address adr);
    }

    abstract contract NameReg {
        function register(bytes32 name) public virtual;
        function unregister() public virtual;
     }

    // å¯ä»¥å¤šé‡ç»§æ‰¿ã€‚è¯·æ³¨æ„ï¼Œowned ä¹Ÿæ˜¯ Destructible çš„åŸºç±»ï¼Œ
    // ä½†åªæœ‰ä¸€ä¸ª owned å®žä¾‹ï¼ˆå°±åƒ C++ ä¸­çš„è™šæ‹Ÿç»§æ‰¿ï¼‰ã€‚
    contract Named is Owned, Destructible {
        constructor(bytes32 name) {
            Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);
            NameReg(config.lookup(1)).register(name);
        }

        // å‡½æ•°å¯ä»¥è¢«å¦ä¸€ä¸ªå…·æœ‰ç›¸åŒåç§°å’Œç›¸åŒæ•°é‡/ç±»åž‹è¾“å…¥çš„å‡½æ•°é‡è½½ã€‚
        // å¦‚æžœé‡è½½å‡½æ•°æœ‰ä¸åŒç±»åž‹çš„è¾“å‡ºå‚æ•°ï¼Œä¼šå¯¼è‡´é”™è¯¯ã€‚
        // æœ¬åœ°å’ŒåŸºäºŽæ¶ˆæ¯çš„å‡½æ•°è°ƒç”¨éƒ½ä¼šè€ƒè™‘è¿™äº›é‡è½½ã€‚

//å¦‚æžœè¦è¦†ç›–å‡½æ•°ï¼Œåˆ™éœ€è¦ä½¿ç”¨ `override` å…³é”®å­—ã€‚
å¦‚æžœæ‚¨æƒ³å†æ¬¡è¦†ç›–æ­¤å‡½æ•°ï¼Œåˆ™éœ€è¦å†æ¬¡æŒ‡å®š`virtual`å…³é”®å­—ã€‚

        function destroy() public virtual override {
            if (msg.sender == owner) {
                Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);
                NameReg(config.lookup(1)).unregister();
                // ä»ç„¶å¯ä»¥è°ƒç”¨ç‰¹å®šçš„é‡è½½å‡½æ•°ã€‚
                Destructible.destroy();
            }
        }
    }

    // å¦‚æžœæž„é€ å‡½æ•°æŽ¥å—å‚æ•°ï¼Œ
    // åˆ™éœ€è¦åœ¨å£°æ˜Žï¼ˆåˆçº¦çš„æž„é€ å‡½æ•°ï¼‰æ—¶æä¾›ï¼Œ
    // æˆ–åœ¨æ´¾ç”Ÿåˆçº¦çš„æž„é€ å‡½æ•°ä½ç½®ä»¥ä¿®æ”¹å™¨è°ƒç”¨é£Žæ ¼æä¾›ï¼ˆè§ä¸‹æ–‡ï¼‰ã€‚
    contract PriceFeed is Owned, Destructible, Named("GoldFeed") {
        function updateInfo(uint newInfo) public {
            if (msg.sender == owner) info = newInfo;
        }

        // Here, we only specify `override` and not `virtual`.
        // This means that contracts deriving from `PriceFeed`
        // cannot change the behaviour of `destroy` anymore.
        function destroy() public override(Destructible, Named) { Named.destroy(); }

        function get() public view returns(uint r) { return info; }

        uint info;
    }
```

æ³¨æ„ï¼Œåœ¨ä¸Šè¾¹çš„ä»£ç ä¸­ï¼Œæˆ‘ä»¬è°ƒç”¨ `Destructible.destroy()`
æ¥"è½¬å‘"é”€æ¯è¯·æ±‚ã€‚ è¿™æ ·åšæ³•æ˜¯æœ‰é—®é¢˜çš„ï¼Œåœ¨ä¸‹é¢çš„ä¾‹å­ä¸­å¯ä»¥çœ‹åˆ°ï¼š

```

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.7.0 <0.9.0;

    contract owned {
        constructor() { owner = payable(msg.sender); }
        address owner;
    }

    contract Destructible is owned {
        function destroy() public virtual {
            if (msg.sender == owner) selfdestruct(owner);
        }
    }

    contract Base1 is Destructible {
        function destroy() public virtual override  {
            /* æ¸…é™¤æ“ä½œ 1 */
            Destructible.destroy();
        }
    }

    contract Base2 is Destructible {
        function destroy() public { /* æ¸…é™¤æ“ä½œ 2 */ Destructible.destroy(); }
    }

    contract Final is Base1, Base2 {
        function destroy() public override(Base1, Base2) { Base2.destroy(); }
    }

```

ã€‚ è§£å†³æ­¤é—®é¢˜çš„æ–¹æ³•æ˜¯ä½¿ç”¨ superï¼š

è°ƒç”¨ `Final.destroy()` æ—¶ä¼šè°ƒç”¨ `Base2.destroy`ï¼Œ
å› ä¸ºæˆ‘ä»¬åœ¨æœ€ç»ˆé‡å†™ä¸­æ˜¾å¼æŒ‡å®šäº†å®ƒã€‚ ä½†æ˜¯æ­¤å‡½æ•°å°†ç»•è¿‡ `Base1.destroy`,
è§£å†³è¿™ä¸ªé—®é¢˜çš„æ–¹æ³•æ˜¯ä½¿ç”¨ `super`ï¼š

```

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.7.0 <0.9.0;

    contract owned {
        constructor() { owner = payable(msg.sender); }
        address owner;
    }

    contract Destructible is owned {
        function destroy() virtual public {
            if (msg.sender == owner) selfdestruct(owner);
        }
    }

    contract Base1 is Destructible {
        function destroy() public virtual override { /* æ¸…é™¤æ“ä½œ 1 */ super.destroy(); }
    }


    contract Base2 is Destructible {
        function destroy() public  virtual override { /* æ¸…é™¤æ“ä½œ 2 */ super.destroy(); }
    }

    contract Final is Base1, Base2 {
        function destroy() public override(Base1, Base2) { super.destroy(); }
    }

```

å¦‚æžœ `Base2` è°ƒç”¨ `super` çš„å‡½æ•°ï¼Œå®ƒä¸ä¼šç®€å•åœ¨å…¶åŸºç±»åˆçº¦ä¸Šè°ƒç”¨è¯¥å‡½æ•°ã€‚
ç›¸åï¼Œå®ƒåœ¨æœ€ç»ˆçš„ç»§æ‰¿å…³ç³»å›¾è°±çš„ä¸‹ä¸€ä¸ªåŸºç±»åˆçº¦ä¸­è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œæ‰€ä»¥å®ƒä¼šè°ƒç”¨
`Base1.destroy()` ï¼ˆæ³¨æ„æœ€ç»ˆçš„ç»§æ‰¿åºåˆ—æ˜¯------ä»Žæœ€ç»ˆæ´¾ç”Ÿåˆçº¦å¼€å§‹ï¼šFinal,
Base2, Base1, Destructible, ownerdï¼‰ã€‚ åœ¨ç±»ä¸­ä½¿ç”¨ super
è°ƒç”¨çš„å®žé™…å‡½æ•°åœ¨å½“å‰ç±»çš„ä¸Šä¸‹æ–‡ä¸­æ˜¯æœªçŸ¥çš„ï¼Œå°½ç®¡å®ƒçš„ç±»åž‹æ˜¯å·²çŸ¥çš„ã€‚
è¿™ä¸Žæ™®é€šçš„è™šæ‹Ÿæ–¹æ³•æŸ¥æ‰¾ç±»ä¼¼ã€‚

## #ï¸âƒ£ é—®ç­”é¢˜

- ç»§æ‰¿å¦‚ä½•å®žçŽ°ï¼Ÿ
  - ä½¿ç”¨ `is` å®žçŽ°ç»§æ‰¿
  - ç»§æ‰¿: **æ´¾ç”Ÿåˆçº¦**ç»§æ‰¿**åŸºç¡€åˆçº¦**çš„å±žæ€§å’Œæ–¹æ³•
  - åŸºç¡€åˆçº¦é€šå¸¸ä¹Ÿè¢«ç§°ä¸º**çˆ¶åˆçº¦**ï¼Œæ´¾ç”Ÿåˆçº¦é€šå¸¸ä¹Ÿç§°ä½œ**å­åˆçº¦**ã€‚
  - çˆ¶åˆçº¦å¿…é¡»å†™åœ¨å­åˆçº¦çš„å‰é¢ï¼Œå¦åˆ™ä¼šæŠ¥é”™
- å­ç±»å¯ä»¥ç»§æ‰¿çˆ¶ç±»å“ªäº›æ•°æ®ï¼Ÿ
  - å­ç±»å¯ä»¥è®¿é—®çˆ¶ç±»çš„æƒé™ä¿®é¥°ç¬¦åªæœ‰ï¼š`public/internal`ï¼Œä¸èƒ½æ˜¯ `external/private`ã€‚
- å¤šé‡ç»§æ‰¿ä¸­å“ªäº›å±žäºŽé‡åï¼Ÿ
  - ä¸€ä¸ªåˆçº¦åŒæ—¶ç»§æ‰¿ 2 ä¸ªåˆçº¦æ—¶ï¼Œè¿™ç§æƒ…å†µå«å¤šé‡ç»§æ‰¿
  - å¤šé‡ç»§æ‰¿ä¸­ä¸å…è®¸å‡ºçŽ°ç›¸åŒçš„**å‡½æ•°å**ã€**äº‹ä»¶å**ã€**ä¿®æ”¹å™¨å**ä»¥åŠ**çŠ¶æ€å˜é‡å**ç­‰ã€‚å¤šé‡ç»§æ‰¿å‡½æ•°ä¸­ getter å‡½æ•°é‡åä¹Ÿä¸å¯ä»¥ã€‚
  - å½“ç»§æ‰¿æ—¶åˆçº¦å‡ºçŽ°äº†ä¸€ä¸‹ç›¸åŒåå­—ä¼šè¢«è®¤ä¸ºæ˜¯ä¸€ä¸ªé”™è¯¯ï¼š
    - å‡½æ•° å’Œ ä¿®æ”¹å™¨/modifier åŒå
    - å‡½æ•° å’Œ äº‹ä»¶åŒå
    - äº‹ä»¶å’Œ ä¿®æ”¹å™¨/modifier åŒå
    - æœ‰ä¸€ç§ä¾‹å¤–æƒ…å†µï¼ŒçŠ¶æ€å˜é‡çš„ `getter` å‡½æ•°å¯ä»¥è¦†ç›– `external` å‡½æ•°ã€‚
- å¦‚ä½•é‡å†™å‡½æ•°ï¼Ÿ
  - solidity å¼•å…¥äº† `abstract`, `virtual`, `override` å‡ ä¸ªå…³é”®å­—ï¼Œç”¨äºŽé‡å†™å‡½æ•°ã€‚
  - çˆ¶åˆçº¦æ–¹æ³•éœ€è¦æ ‡ç¤ºä¸º**å¯ä¿®æ”¹**ï¼Œä½¿ç”¨å…³é”®å­— `virtual`ï¼Œ
  - å­åˆçº¦æ–¹æ³•éœ€è¦æ ‡ç¤ºä¸º**è¦†ç›–**ï¼Œä½¿ç”¨å…³é”®è¯ `override`
    - å¯¹äºŽå¤šé‡ç»§æ‰¿ï¼Œå¦‚æžœæœ‰å¤šä¸ªçˆ¶åˆçº¦æœ‰ç›¸åŒå®šä¹‰çš„å‡½æ•°ï¼Œ override å…³é”®å­—åŽå¿…é¡»æŒ‡å®šæ‰€æœ‰çˆ¶åˆçº¦åã€‚
  - åŸºç¡€åˆçº¦ä¸­å¯ä»¥åŒ…å«æ²¡æœ‰å®žçŽ°ä»£ç çš„å‡½æ•°ï¼Œä¹Ÿå°±æ˜¯çº¯è™šå‡½æ•°ï¼Œé‚£ä¹ˆåŸºç¡€åˆçº¦å¿…é¡»å£°æ˜Žä¸º `abstract`ã€‚ï¼ˆ`abstract`ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ `interface` æ¥è§£å†³ã€‚ï¼‰
  - ç»§æ‰¿å¤šä¸ªåˆçº¦æ—¶ï¼Œæ‰€æœ‰åŒåçš„å¯ä¿®æ”¹å‡½æ•°éƒ½éœ€è¦é‡å†™
  - ç»§æ‰¿åŽé‡å†™åˆçº¦æ–¹æ³•ï¼Œå„ä¸ªåˆçº¦å†…çš„å‡½æ•°å¯è§æ€§éœ€è¦ä¸€è‡´
  - å¯å˜æ€§å¯ä»¥æŒ‰ç…§ä»¥ä¸‹é¡ºåºæ›´æ”¹ä¸ºæ›´ä¸¥æ ¼çš„ä¸€ç§ï¼š `nonpayable` å¯ä»¥è¢« `view` å’Œ`pure` è¦†ç›–ã€‚ `view` å¯ä»¥è¢« `pure` è¦†ç›–ã€‚ `payable`æ˜¯ä¸€ä¸ªä¾‹å¤–ï¼Œä¸èƒ½æ›´æ”¹ä¸ºä»»ä½•å…¶ä»–å¯å˜æ€§ã€‚
- å¤šçº§ç»§æ‰¿çš„ä»£ç ä¹¦å†™é¡ºåºï¼Ÿ
  - æŒ‰ç…§ä»Žâ€œæœ€ç±»ä¼¼åŸºç±»â€åˆ°â€œæœ€å¤šæ´¾ç”Ÿâ€çš„é¡ºåºæŒ‡å®šåŸºç±»ã€‚
  - åŽŸåˆ™ï¼šå…ˆå†™åŸºç¡€åˆçº¦ï¼Œå†å†™æ´¾ç”Ÿåˆçº¦ã€‚
  - å°æŠ€å·§ï¼šå¯ä»¥å…ˆç”»ç»§æ‰¿é€»è¾‘å›¾ï¼Œç„¶åŽæŒ‰ç…§ä»Žä¸Šåˆ°ä¸‹ï¼Œä»Žå·¦åˆ°å³çš„é¡ºåºæ¥å†™åˆçº¦ï¼›
- ç»§æ‰¿ä¸­ä¸¤ç§æž„é€ å‡½æ•°ä¼ å‚æ–¹å¼ã€‚
  - **æ–¹æ³• 1**: å›ºå®šå€¼ä¼ å‚ã€‚ï¼ˆè¯¥æ–¹å¼ä¸èƒ½åœ¨éƒ¨ç½²æ—¶åŠ¨æ€è¾“å…¥ï¼‰ã€‚
    - å¦‚æžœæˆ‘ä»¬å·²ç»çŸ¥é“åŸºç±»åˆå§‹åŒ–å‚æ•°ï¼Œé‚£ä¹ˆå°±å¯ä»¥åœ¨æ´¾ç”Ÿç±»çš„ç»§æ‰¿å£°æ˜Žä¸­ï¼Œç›´æŽ¥ä¼ é€’å‚æ•°ç»™åŸºç±»çš„æž„é€ å‡½æ•°ã€‚
    ```
    contract C is A("n"),B("v") {}
    ```
  - **æ–¹æ³• 2**: åŠ¨æ€ä¼ å‚
    - å¦‚æžœæˆ‘ä»¬éœ€è¦åœ¨éƒ¨ç½²æ—¶æˆ–è€…è¿è¡Œæ—¶ï¼Œç”±è°ƒç”¨æ–¹ä¼ é€’åŸºç±»åˆå§‹åŒ–å‚æ•°ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬éœ€è¦ç¼–å†™ä¸€ä¸ªæ–°çš„æž„é€ å‡½æ•°ï¼Œä¼ é€’å‚æ•°ç»™åŸºç±»ã€‚
    - éƒ¨ç½²å­åˆçº¦çš„æ—¶å€™ï¼Œä¼ å…¥å‚æ•°åˆ°æž„é€ å‡½æ•°ï¼Œè¯¥ç§æ–¹æ³•æ˜¯åŠ¨æ€çš„å€¼ï¼Œå¯ä»¥éƒ¨ç½²çš„æ—¶å€™åŠ¨æ€è¾“å…¥
    ```
    contract D is A {
      constructor(string memory _name) A(_name) {}
    }
    ```
  - **æ··å†™**: æ–¹æ³• 1 å’Œæ–¹æ³• 2 å¯ä»¥æ··åˆä½¿ç”¨
    ```
    contract E is A, B("EEEEEEEEEEEEE") {
      constructor(string memory _name) A(_name) {}
    }
    ```
- ç»§æ‰¿ä¸­æž„é€ å‡½æ•°çš„æ‰§è¡Œé¡ºåº
  - å¤šé‡ç»§æ‰¿ä¸­ï¼Œæž„é€ å‡½æ•°çš„æ‰§è¡Œä¼šæŒ‰ç…§å®šä¹‰æ—¶çš„ç»§æ‰¿é¡ºåºè¿›è¡Œï¼Œä¸Žæž„é€ å‡½æ•°ä¸­å®šä¹‰é¡ºåºæ— å…³ã€‚åŽŸåˆ™: **æž„é€ å‡½æ•°çš„æ‰§è¡Œé¡ºåºæŒ‰ç…§ç»§æ‰¿çš„é¡ºåºã€‚**
  - å¦‚ä¸‹æ˜¯å…ˆæ‰§è¡Œ Aï¼Œå†æ‰§è¡Œ B
    ```
    contract E is A, B("EEEEEEEEEEEEE") {
        constructor(string memory _name) A(_name) {}
    }
    ```
  - å¦‚ä¸‹æ˜¯å…ˆæ‰§è¡Œ Bï¼Œå†æ‰§è¡Œ A
    ```
    contract E is B("EEEEEEEEEEEEE"),A {
        constructor(string memory _name) A(_name) {}
    }
    ```
- å­åˆçº¦è°ƒç”¨çˆ¶åˆçº¦çš„æ–¹æ³•
  1. ç›´æŽ¥ä½¿ç”¨åˆçº¦åè°ƒç”¨ `ParentContractName.functionName()`;
  2. ä½¿ç”¨ super å…³é”®å­— `super.functionName()`
     - super ä¼šè‡ªåŠ¨å¯»æ‰¾çˆ¶åˆçº¦ï¼Œå¹¶æ‰§è¡Œå¯¹åº”çš„æ–¹æ³•ï¼›
     - **å¦‚æžœæ˜¯å¤šä¸ªçˆ¶çº§ï¼Œé‚£ä¹ˆçˆ¶çº§éƒ½ä¼šæ‰§è¡Œã€‚ä½†æœ‰æ—¶å€™åˆä¸ä¼šï¼Œæ‰§è¡Œé¡ºåºçš„åŽŸç†ï¼Œè¿™äº›éœ€è¦è¯¦ç»†çš„äº†è§£**
     - å¦‚æžœ super å¯¼è‡´ 2 ä¸ªçˆ¶çº§åŒæ—¶è§¦å‘åŒä¸€ä¸ªçˆ·çˆ·åˆçº¦çš„ç›¸åŒæ–¹æ³•ï¼›åˆ™çˆ·çˆ·çš„æ–¹æ³•åªæ‰§è¡Œä¸€æ¬¡ã€‚ä¸€ä¸ªåˆçº¦çš„åŒä¸€ä¸ªæ–¹æ³•åªä¼šæ‰§è¡Œä¸€æ¬¡ï¼Œä¸ä¼šæ‰§è¡Œå¤šæ¬¡ã€‚
  3. æ‰§è¡Œé¡ºåºï¼šåƒæ°´ä¸­çš„å†’æ³¡ä¸€æ ·ï¼Œç”±ä¸‹å‘ä¸Šè¿›è¡Œæ‰§è¡Œã€‚ä½†æ˜¯å¦‚æžœå¤šå±‚çº§çš„æ‰§è¡Œï¼Œé¡ºåºè§„å¾‹è¿˜æ²¡æœ‰æ‰¾åˆ°è§„å¾‹ã€‚
- èŠä¸€èŠåˆçº¦ç»§æ‰¿
  - ä»¥ä¸Šçš„å†…å®¹ç²¾ç®€å›žç­”
  - ä¿®é¥°ç¬¦å¯ä»¥ç»§æ‰¿
  - äº‹ä»¶ä¸å¯ä»¥ç»§æ‰¿ï¼Œä½†æ˜¯å¯ä»¥é‡è½½
  - `fallback` å¯ä»¥ç»§æ‰¿ï¼Œä½†æ˜¯éœ€è¦ä¿æŒåŽŸæœ‰çš„ `payable/nonpayable`
  - `receive` å¯ä»¥ç»§æ‰¿ï¼Œä½†æ˜¯éœ€è¦ä¿æŒåŽŸæœ‰çš„ `payable/nonpayable`
